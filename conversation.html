<template>
    <div class="page no-tabbar no-sidebar" data-name="cart">
        <!-- Navbar remains unchanged -->
        <div id="conversation-navbar" class="navbar">
            <div class="navbar-bg"></div>
            <div class="navbar-inner">
                <div class="left">
                    <a href="#" class="link" @click="${openConversationsSidebar}">
                        <i class="icon material-icons">chevron_right</i>
                    </a>
                </div>
                <div class="title">${chat.title}</div>
                <div class="right">
                    <a href="#" data-tooltip="Reproducir conversaci�n" class="link tooltip-init icon-only"><i
                            class="icon material-icons">play</i></a>
                    <a href="#" @click="${startNewConversation}" data-tooltip="New conversation"
                       class="link tooltip-init icon-only"><i class="icon material-icons">add</i></a>

                    <a href="#" data-tooltip="Configuration" class="link tooltip-init icon-only"
                       @click="${openPopupConfig}">
                        <i class="icon material-icons">settings</i>
                    </a>
                    ${assistant ? $h`
                    <a href="#" class="link icon-only popover-open tooltip-init" data-popover="#popover-assistants"
                       data-tooltip="Change Assistant">
                        <img class="shape-circle" width="40" src="${assistant.avatar}"/>

                    </a>
                    ` : ''}
                </div>
            </div>
        </div>

        <div class="toolbar messagebar messagebar-chat" style="${showBottomBar ? '' : 'display:none'}">
            <div id="page-toolbar" class="toolbar-inner" style="min-height: 70px;">

            </div>
        </div>
        <!-- Page content with messages and messagebar inside -->
        <div class="page-content" id="conversationPage">
            <div class="row justify-content-center no-gap padding-horizontal-half"
                 style="--f7-card-margin-horizontal: 8px;">
                <div id="message-area" class="col-100 medium-65 margin-bottom-half margin-top large-70 xlarge-65">
                    <div style=""
                         class="messages-content justify-content-center padding-top row">
                        <div class="col-90 large-60 medium-75 messages xlarge-70" id="messages-space">

                        </div>
                        <!-- Centered messagebar component (only show when no messages) -->

                        <div id="prompt-area"
                             class="centered-messagebar-container">
                            ${!showBottomBar ? $h`
                            <div class="display-flex justify-content-center width-100">
                                <img src="${assistant ? assistant.mainImage : ''}" width="300" class=""/>
                            </div>

                            <div class="block-title-large margin text-align-center">
                                ${myDevice ?
                                (assistant ? assistant.greeting : '') :
                                (chat && chat.mainAssistant && chat.mainAssistant.deviceSelector ?
                                'Please select a device.' :
                                (assistant ? assistant.greeting : ''))}
                            </div>
                            <!-- Remaining components unchanged -->

                            ` : ''}
                            <div id="messagebar-chat"
                                 style=""
                                 class="messagebar-chat centered-messagebar auto-height">

                                <div class="messagebar-inner">
                                    <div class="messagebar-area" style="overflow:visible; width: 100%;">
                                        ${showAssistantChip ? $h`
                                        <div class="chip bg-color-chrome margin-bottom-half">
                                            <div class="chip-media"><img src="${assistant.avatar}"/></div>
                                            <div class="chip-label">${assistant.name} will respond</div>
                                            <a href="#" @click="${returnToOriginalAssistant}"  data-tooltip="Return to ${originalAssistant.name}" class="chip-delete tooltip-init"></a>
                                        </div>
                                        ` : ''}
                                        <div class="file-dropzone invisible" id="file-dropzone">
                                            <input type="file" id="file-upload" multiple class="file-upload-input"
                                                   style="display:none;"/>
                                        </div>
                                        <textarea
                                                style="${(chat && chat.mainAssistant && chat.mainAssistant.deviceSelector) ? (myDevice ? '' : 'display:none') : ''}"
                                                id="prompt"
                                                placeholder="${(chat && chat.mainAssistant && chat.mainAssistant.deviceSelector && !myDevice) ? 'Ask anything about one particular device (please select a device first)...' : (assistant ? assistant.placeholder : '')}"
                                                @input="${handlePromptTextArea}"
                                                @keydown="${handleKeyDown}"
                                                class="input-with-value resizable keyboard-mode">
                                    </textarea>
                                        <div id="assistants-suggestions" class="assistants-suggestions"
                                             style="display: none;">
                                            <div class="assistants-suggestions-title">Available Assistants</div>
                                            <div class="assistants-suggestions-list"></div>
                                        </div>
                                    </div>
                                </div>
                                <div class="messagebar-buttons-bottom">
                                    <div class="row align-items-center">
                                        <div class="col-90">
                                            <div id="device-list"
                                                 class="block float-left margin-bottom-auto margin-horizontal-auto inset margin-vertical"
                                                 style="">

                                                ${(myDevice || (chat && chat.mainAssistant &&
                                                chat.mainAssistant.deviceSelector === false)) ? $h`
                                                ${chat && chat.mainAssistant && chat.mainAssistant.deviceSelector ? $h`
                                                <div data-tooltip="Select other device"
                                                     class="tooltip-init bg-color-blue chip cursor-pointer"
                                                     @click="${handleOpenDeviceSelection}">
                                                    <div class="chip-label">${myDevice}</div>
                                                </div>
                                                ` : ''}


                                                ${chat && chat.mainAssistant && chat.mainAssistant.activeDropzone !== false ? $h`
                                                <a href="#" @click="${handleFileUploadClick}"
                                                   style="height: 35px!important;" data-tooltip="Upload a document"
                                                   class="tooltip-init link button-outline float-left margin-right-half button border-color-chrome button-icon button-round color-gray">
                                                    <i class="fa fa-paperclip"></i>
                                                </a>
                                                ` : ''}
                                                ${chat && chat.tools && chat.tools.length > 0 ? $h`
                                                <a href="#" class="link button-outline float-left margin-right-half button border-color-chrome button-icon button-round color-gray popover-open tooltip-init"
                                                   style="height: 35px!important;"
                                                   data-tooltip="Manage tools"
                                                   data-popover="#popover-tools">
                                                    <i class="icon material-icons">tune</i>
                                                </a>
                                                ` : ''}
                                                ${window.proxyInfo && window.proxyInfo.services && window.proxyInfo.services.length > 0 && activeTools['retrieve_data_from_corporate_services'] === true && assistant?.activeProxy === true ? $h`
                                                <a href="#" class="link button-outline float-left margin-right-half button border-color-chrome button-icon button-round color-gray popover-open tooltip-init"
                                                   style="height: 35px!important;"
                                                   data-tooltip="Manage proxy services"
                                                   data-popover="#popover-proxy-services">
                                                    <i class="icon material-icons text-color-lightgreen">cloud_sync</i>
                                                </a>
                                                ` : ''}
                                                ${$h`
                                                <a href="#" @click="${toggleIterativeReasoning}"
                                                   style="height: 35px!important;"
                                                   data-tooltip="${iterativeReasoningEnabled ? 'Disable iterative reasoning' : 'Enable iterative reasoning'}"
                                                   class="tooltip-init link button-outline float-left margin-right-half button border-color-chrome button-icon button-round ${iterativeReasoningEnabled ? 'color-blue' : 'color-gray'}">
                                                    <i class="icon material-icons">${iterativeReasoningEnabled ? 'hub' : 'linear_scale'}</i>
                                                </a>
                                                `}
                                                ${currentModelCategory === 'reasoning' ? $h`
                                                <a href="#" @click="${toggleReasoning}"
                                                   style="height: 35px!important;"
                                                   data-tooltip="${isReasoningEnabled() ? 'Disable reasoning' : 'Enable reasoning'}"
                                                   class="tooltip-init link button-outline float-left margin-right-half button border-color-chrome button-icon button-round ${isReasoningEnabled() ? 'color-blue' : 'color-gray'}">
                                                    <i class="icon material-icons">${isReasoningEnabled() ? 'psychology' : 'psychology_alt'}</i>
                                                </a>
                                                ` : ''}
                                                ${chat && chat.noSelectionInstructions &&
                                                chat.noSelectionInstructions.length > 0 ? $h`
                                                <div data-tooltip="Open shortcuts"
                                                     class="tooltip-init bg-color-bluegray chip cursor-pointer"
                                                     @click="${() => actionsCustomLayout.open()}">
                                                    <div class="chip-media">
                                                        <i class="fa fa-bookmark fa-icon"></i>
                                                    </div>
                                                    <div class="chip-label">${chat.noSelectionInstructions.length} shortcuts
                                                    </div>
                                                </div>
                                                ` : ''}

                                                ` : $h`
                                                `}
                                                ${chat && chat.mainAssistant && chat.mainAssistant.deviceSelector ?
                                                devices.map((device, index) => $h`
                                                <label style="${myDevice ? 'display:none' : ''}"
                                                       class="chip-selectable">
                                                    ${myDevice === device ? $h`
                                                    <input type="radio" @change="${handleDeviceSelection}"
                                                           name="chip-selectable-device" checked="checked"
                                                           value="${device}"/>
                                                    ` : $h`
                                                    <input type="radio" @change="${handleDeviceSelection}"
                                                           name="chip-selectable-device" value="${device}"/>
                                                    `}
                                                    <div class="chip">
                                                        <div class="chip-label">${device}</div>
                                                    </div>
                                                </label>
                                                `)
                                                : ''}
                                                ${Object.keys(highlights).length > 0 ? $h`
                                                <a href="#" @click="${showHighlights}"
                                                   style="height: 35px!important;"
                                                   data-tooltip="Review selected text"
                                                   class="tooltip-init link button-outline float-left margin-right-half button border-color-chrome button-icon button-round color-gray">
                                                    <i class="fa fa-highlighter" style="color:yellow!important"></i>
                                                </a>
                                                ` : ''}
                                            </div>
                                        </div>
                                        <div class="col-10 display-flex justify-content-right align-items-center">
                                            ${(() => {
                                            const voiceConfigData = configManager.getConfig();
                                            const shouldShowVoiceButton = voiceConfigData.voiceEnabled && voiceSupported;
                                            const shouldShowDisabledButton = !voiceConfigData.voiceEnabled && voiceConfigData.voiceShowButton;

                                            return shouldShowVoiceButton ? $h`
                                            <a href="#" @click="${handleVoiceButtonClick}"
                                               style="margin-right: 8px;"
                                               data-tooltip='${isRecording ? 'Stop recording' : isProcessingVoice ? 'Processing...' : 'Start voice recording'}'
                                            class="link tooltip-init message-bar-icon ripple-color-gray ${isRecording ? 'recording-active' : isProcessingVoice ? 'processing-voice' : ''}">
                                            <i class="fa fa-2x ${isRecording ? 'fa-stop-circle' : isProcessingVoice ? 'fa-spinner fa-spin' : 'fa-microphone'} fa-icon"
                                               style="color: ${isRecording ? '#FF5252' : isProcessingVoice ? '#FF9800' : '#2196F3'};"></i>
                                            </a>
                                            ` : shouldShowDisabledButton ? $h`
                                            <a href="#" @click="${showVoiceDisabledMessage}"
                                               style="margin-right: 8px; opacity: 0.5;"
                                               data-tooltip='Voice features disabled - Enable in settings'
                                               class="link tooltip-init message-bar-icon">
                                                <i class="fa fa-2x fa-microphone-slash fa-icon" style="color: #999;"></i>
                                            </a>
                                            ` : '';
                                            })()}
                                            ${isResponding ? $h`
                                            <a href="#" @click="${stopStreaming}" style=""
                                               data-tooltip='Stop response'
                                               class="link tooltip-init margin-right float-right message-bar-icon ripple-color-gray">
                                                <i class="fa fa-2x fa-stop-circle fa-icon" style="color: #FF5252;"></i>
                                            </a>
                                            ` : ((!prompt || !myDevice) && (chat && chat.mainAssistant &&
                                            chat.mainAssistant.deviceSelector)) ? $h`
                                            <a href="#" @click="${sendPrompt}" style=""
                                               data-tooltip='Send message'
                                               class="disabled link tooltip-init margin-right float-right message-bar-icon ripple-color-gray">
                                                <i class="fa fa-2x fa-arrow-circle-up fa-icon"
                                                   style="color: #ffffff;"></i>
                                            </a>
                                            ` : $h`
                                            <a href="#" @click="${sendPrompt}" style=""
                                               data-tooltip='Send message'
                                               class="link tooltip-init margin-right float-right message-bar-icon ripple-color-gray">
                                                <i class="fa fa-2x fa-arrow-circle-up fa-icon"
                                                   style="color: #4CAF50;"></i>
                                            </a>
                                            `}
                                        </div>
                                    </div>
                                </div>
                            </div>

                            ${quick_actions && quick_actions.length > 0 && !showBottomBar ? $h`
                            <div class="quick-actions-container no-margin-top text-align-center"
                                 style="max-width:650px!important">
                                <div class="block float-left">
                                    ${quick_actions.map((action, index) => $h`
                                    <div data-tooltip="${action.description}"
                                         style="background-color:${action.color} "
                                         class="quick-action-chip link chip-outline tooltip-init padding chip cursor-pointer"
                                         @click="${() => {
                 // Primero crear la conversaci�n
                 quick_actions = [];
                 createConversation(assistant.guid).then(() => {
                     // Luego ejecutar el c�digo de la acci�n
                     if (action.code) {
                         eval(action.code);
                     }
                 });
             }}">
                                        <div style="color:white" class="chip-media">
                                            <i class="fa ${action.icon || 'fa-bolt'} fa-icon"
                                               style="color:${action.color}"></i>
                                        </div>
                                        <div class="font-size-16 chip-label">${action.shortTitle}</div>
                                    </div>
                                    `)}
                                </div>
                            </div>
                            ` : ''}
                            <div id="legal-info" class="margin-bottom-half legal-info text-align-center">SIMBA may make
                                mistakes. Consider verifying
                                important information. See the <a href="/screens/terms/" class="link">disclaimer</a> for
                                details.
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            <div id="scrollToBottom" @click="${scrollToBottom}"
                 class="fab fab-center-bottom hidden color-gray opacity-75">
                <a href="#">
                    <i class="fa fa-arrow-down"></i>
                </a>
            </div>
            <div class="block-footer"></div>
        </div>

        <!-- Fixed bottom messagebar (only show when there are messages) -->
        <!-- Fixed bottom messagebar (only show when there are messages) -->


        <div id="dialog-choice-chip" class="dialog">
            <div class="dialog-inner">
                <div class="dialog-title">Choose te reason for your feedback</div>
                <form name="dialog-choice-chip" action="#" method="POST" enctype="multipart/form-data"
                      @submit="${(event) => event.preventDefault()}">
                    <div class="block margin-top no-margin-bottom no-padding-horizontal">
                        ${unlikeReasons.map((option, index) => $h`
                        <label data-tooltip="${option.description}" class="tooltip-init chip-selectable">
                            <input type="checkbox" name="interests" value="${option.value}"/>
                            <div class="chip color-pink">
                                <div class="chip-label">${option.reason}</div>
                            </div>
                        </label>
                        `)}
                        <textarea class="padding margin"
                                  style="width:90%;height:200px;background-color:#333333!important"
                                  placeholder="Please describe your feedback"></textarea>

                    </div>
                </form>
            </div>
            <div class="dialog-buttons">
                <span class="dialog-button color-gray" @click="${closeDialogChoiceChip}">Cancel</span>
                <span class="dialog-button" @click="${submitFormDialogChoiceChip}">OK</span>
            </div>
        </div>

        <div id="popup-api-keys" class="popup">
            <div class="page">
                <div class="navbar">
                    <div class="navbar-bg"></div>
                    <div class="navbar-inner">
                        <div class="title">Required API Configuration</div>
                        <!-- No bot�n de cerrar para forzar configuraci�n -->
                    </div>
                </div>

                <div class="page-content">
                    <div class="block block-strong inset margin-vertical">
                        <div class="margin-top text-align-center">
                            <div class="font-size-24 font-weight-bold">API Keys Required</div>
                            <div class="font-size-16 margin-top-half text-color-gray">
                                Please configure your API keys to continue using the application.
                            </div>
                        </div>
                    </div>

                    <form name="api-keys" action="#" method="POST" enctype="multipart/form-data">
                        <div class="list inset margin-vertical">
                            <ul>

                                <li>
                                    <div class="item-content item-input item-input-outline">
                                        <div class="item-inner">
                                            <div class="item-title item-floating-label">mySim API Key</div>
                                            <div class="item-input-wrap">
                                                <input type="password" name="assistant_auth_token"
                                                       placeholder="Your mySim API key" required/>
                                                <span class="input-clear-button"></span>
                                            </div>
                                        </div>
                                    </div>
                                </li>
                                <li>
                                    <div class="item-content item-input item-input-outline">
                                        <div class="item-inner">
                                            <div class="item-title item-floating-label">Completion API Key</div>
                                            <div class="item-input-wrap">
                                                <input type="password" name="completion_api_key"
                                                       placeholder="Your completion API key" required/>
                                                <span class="input-clear-button"></span>
                                            </div>
                                        </div>
                                    </div>
                                </li>
                                <li>
                                    <div class="item-content">
                                        <div class="item-inner">
                                            <button type="submit" class="button button-fill button-large">
                                                Save API Keys & Continue
                                            </button>
                                        </div>
                                    </div>
                                </li>
                            </ul>
                        </div>
                    </form>
                </div>
            </div>
        </div>
        <div id="popup-ticket" class="popup">
            <div class="page">
                <div class="navbar">
                    <div class="navbar-bg"></div>
                    <div class="navbar-inner">
                        <div class="title">Confirm Support Ticket</div>
                        <div class="right">
                            <a class="link icon-only" @click="${() => closePopupTicket(false)}">
                                <i class="icon material-icons">cancel</i>
                            </a>
                        </div>
                    </div>
                </div>

                <div class="page-content">

                    <div class="block block-strong inset margin-vertical">
                        <div class="margin-top text-align-center">
                            <div class="font-size-24 font-weight-bold">Confirm Support Ticket</div>
                            <div class="font-size-16 margin-top-half text-color-gray">Please confirm the details of your
                                support request.
                            </div>
                        </div>
                    </div>
                    <form name="ticket" action="#" method="POST" enctype="multipart/form-data">
                        <div class="list inset margin-vertical">
                            <ul class="padding-vertical-half">
                                <li>
                                    <div class="item-content item-input item-input-outline">
                                        <div class="item-inner">
                                            <div class="item-input-wrap">
                                                <div class="item-media">
                                                    <i class="icon material-icons">devices</i>
                                                </div>
                                                <input type="text" value="${ticket.device}" name="device"
                                                       placeholder="Device" required/>
                                                <span class="input-clear-button"></span>
                                            </div>
                                        </div>
                                    </div>
                                </li>
                                <li>
                                    <div class="item-content item-input item-input-outline">
                                        <div class="item-inner">
                                            <div class="item-input-wrap">
                                                <div class="item-media">
                                                    <i class="icon material-icons">title</i>
                                                </div>
                                                <input type="text" name="problem_title" value="${ticket.problem_title}"
                                                       placeholder="Title" required/>
                                                <span class="input-clear-button"></span>
                                            </div>
                                        </div>
                                    </div>
                                </li>
                                <li>
                                    <div class="item-content item-input item-input-outline">
                                        <div class="item-inner">
                                            <div class="item-input-wrap">
                                                <div class="item-media align-self-flex-start">
                                                    <i class="icon material-icons">description</i>
                                                </div>
                                                <textarea name="problem_description" class="resizable"
                                                          placeholder="Description" required style="min-height: 128px;">${ticket.problem_description}</textarea>
                                                <span class="input-clear-button"></span>
                                            </div>
                                        </div>
                                    </div>
                                </li>
                                <li>
                                    <div class="item-content">
                                        <div class="item-inner">
                                            <button type="submit" class="button button-fill button-large">Confirm Ticket
                                            </button>
                                        </div>
                                    </div>
                                </li>
                            </ul>
                        </div>
                    </form>
                </div>

            </div>
        </div>
        <div id="actions-custom-layout" class="actions-modal">
            <div class="actions-group text-align-center">
                <a href="#" class="link shape-container shape-circle overflow-hidden ripple-color-gray"
                   style="background-color: var(--f7-list-bg-color);" @click="${() => actionsCustomLayout.close()}">
                    <i class="icon material-icons text-color-mono">close</i>
                </a>
            </div>
            <div class="actions-group">
                <div class="list media-list inset no-chevron no-hairlines-between no-margin">
                    <ul>

                        ${chat.instructions.map((option, index) => option.isSelection === 0 ? $h`
                        <li>
                            <a href="#" class="item-link" @click="${(e) => {
                e.preventDefault();

                if (option.code !== null && option.code !== undefined) {
                   eval(option.code);
                } else {
                 setPrompt(option.prompt);
                }
                actionsCustomLayout.close()
            }}">
                                <div class="item-content">
                                    <div class="item-media">
<span style="background-color:${option.color}"
      class="shape-container shape-auto size-40">
    <i class="fa ${option.icon} font-size-20 color-white"></i>
</span>
                                    </div>
                                    <div class="item-inner">
                                        <div class="item-title-row">
                                            <div class="item-title">${option.promptName}</div>
                                        </div>
                                        <div class="item-text tooltip-init" data-tooltip="${option.prompt}">${option.prompt.substring(0, 100)}</div>
                                    </div>
                                </div>
                            </a>
                        </li>
                        ` : '')}
                    </ul>
                </div>
            </div>
        </div>
        <div id="popover-selection" class="popover">
            <div class="popover-inner">
                <div class="list no-chevron no-hairlines-between">
                    <ul>
                        <li>
                            <div class="item-content item-input item-input-outline item-input-with-info">
                                <div class="item-inner no-padding-bottom">
                                    <div class="item-title item-floating-label">Ask to SIMBA</div>
                                    <div class="item-input-wrap no-border">
                                        <input type="text" @input="${handlePromptTextArea}" id="ask-simba" class=""/>
                                        <span class="input-clear-button"></span>
                                        <a href="#" class="link popover-close" @click="${() => setPrompt(prompt,1)}"><i
                                                class="icon f7-icons">arrow_up</i></a></div>
                                </div>
                            </div>
                        </li>

                        <li>
                            <a href="#" class="item-link" @click="${highlightForReporting}">
                                <div class="item-content" style="height:10px">
                                    <div class="item-media">
                                    <span style=""
                                          class="shape-container shape-auto size-40">
                <i class="fa fa-highlighter color-yellow"></i>
            </span>
                                    </div>
                                    <div class="item-inner">
                                        <div class="item-title">Highlight for reporting</div>
                                    </div>
                                </div>
                            </a>
                        </li>
                        ${chat.instructions.map((option, index) => option.isSelection === 1 ? $h`
                        <li>
                            <a href="#" class="item-link popover-close" @click="${() => setPrompt(option.prompt,1)}">
                                <div class="item-content" style="height:10px">
                                    <div class="item-media">
            <span style="background-color:${option.color}"
                  class="shape-container shape-auto size-40">
                <i class="fa ${option.icon} color-white"></i>
            </span>
                                    </div>
                                    <div class="item-inner">
                                        <div class="item-title-row">
                                            <div class="item-title">${option.promptName}</div>
                                        </div>
                                    </div>
                                </div>
                            </a>
                        </li>
                        ` : '')}
                        <li>
                            <a href="#" class="item-link popover-close" @click="${copyToClipboard}">
                                <div class="item-content" style="height:10px">
                                    <div class="item-media">
                                    <span style=""
                                          class="shape-container shape-auto size-40">
                <i class="fa fa-copy color-white"></i>
            </span>
                                    </div>
                                    <div class="item-inner">
                                        <div class="item-title">Copy to clipboard</div>
                                    </div>
                                </div>
                            </a>
                        </li>

                    </ul>
                </div>
            </div>
        </div>
        <div id="popover-assistants" class="popover" style="min-width: 192px;">
            <div class="popover-inner">
                <div class="list links-list no-chevron no-hairlines no-hairlines-between">
                    <ul>
                        ${assistants.map((item, index) => $h`
                        <li>
                            <a href="#" class="popover-close" @click="${() => switchAssistant(item.guid)}">
                                <div class="item-content">
                                    <div class="item-media">
                                        <img class="shape-circle" width="40" height="40" src="${item.avatar}"/>

                                    </div>
                                    <div data-tooltip="${item.name}" class="tooltip-init item-inner">
                                        <div class="item-title">${item.name}</div>
                                        ${item.guid == assistant.guid && $h`
                                        <i class="icon margin-left f7-icons color-primary">checkmark_alt_circle_fill</i>
                                        `}
                                    </div>
                                </div>
                            </a>
                        </li>
                        `)}
                    </ul>
                </div>
            </div>
        </div>
        <input type="file" id="document-upload" style="display: none;" multiple/>
        <div id="popup-config" class="popup">
            <div class="page">
                <div class="navbar">
                    <div class="navbar-bg"></div>
                    <div class="navbar-inner">
                        <div class="title">API Configuration</div>
                        <div class="right">
                            <a class="link icon-only" @click="${closePopupConfig}">
                                <i class="icon material-icons">cancel</i>
                            </a>
                        </div>
                    </div>
                </div>

                <div class="page-content">
                    <form name="config" action="#" method="POST" enctype="multipart/form-data">
                        <div class="list accordion-list inset margin-vertical">
                            <!-- API Configuration Section -->
                            <div class="accordion-item">
                                <div class="accordion-item-toggle">
                                    <div class="item-content">
                                        <div class="item-media">
                                            <i class="icon material-icons">api</i>
                                        </div>
                                        <div class="item-inner">
                                            <div class="item-title">API Configuration</div>
                                        </div>
                                    </div>
                                </div>
                                <div class="accordion-item-content">
                                    <div class="list">
                                        <ul>
                                            <li>
                                                <div class="item-content item-input item-input-outline">
                                                    <div class="item-inner">
                                                        <div class="item-title item-floating-label">mySim API URL</div>
                                                        <div class="item-input-wrap">
                                                            <div class="item-media">
                                                                <i class="icon material-icons">link</i>
                                                            </div>
                                                            <input type="text" value="${config.assistantApiUrl}" name="api_url"
                                                                   placeholder="API URL" required/>
                                                            <span class="input-clear-button"></span>
                                                        </div>
                                                    </div>
                                                </div>
                                            </li>
                                            <li>
                                                <div class="item-content item-input item-input-outline">
                                                    <div class="item-inner">
                                                        <div class="item-title item-floating-label">Api Key</div>
                                                        <div class="item-input-wrap">
                                                            <div class="item-media">
                                                                <i class="icon material-icons">vpn_key</i>
                                                            </div>
                                                            <input type="password" name="token" value="${config.assistantAuthToken}"
                                                                   placeholder="Authentication token" required/>
                                                            <span class="input-clear-button"></span>
                                                        </div>
                                                    </div>
                                                </div>
                                            </li>
                                            <li>
                                                <div class="item-content item-input item-input-outline">
                                                    <div class="item-inner">
                                                        <div class="item-title item-floating-label">Completion URL</div>
                                                        <div class="item-input-wrap">
                                                            <div class="item-media">
                                                                <i class="icon material-icons">cloud</i>
                                                            </div>
                                                            <input type="text" name="completion_url"
                                                                   value="${config.completionsApiUrl}"
                                                                   placeholder="Completion service URL" required/>
                                                            <span class="input-clear-button"></span>
                                                        </div>
                                                    </div>
                                                </div>
                                            </li>
                                            <li>
                                                <div class="item-content item-input item-input-outline">
                                                    <div class="item-inner">
                                                        <div class="item-title item-floating-label">API Key</div>
                                                        <div class="item-input-wrap">
                                                            <div class="item-media">
                                                                <i class="icon material-icons">security</i>
                                                            </div>
                                                            <input type="password" name="api_key"
                                                                   value="${config.completionsApiKey}"
                                                                   placeholder="API Key for the service" required/>
                                                            <span class="input-clear-button"></span>
                                                        </div>
                                                    </div>
                                                </div>
                                            </li>
                                        </ul>
                                    </div>
                                </div>
                            </div>


                            <!-- Model Parameters Section -->
                            <div class="accordion-item">
                                <div class="accordion-item-toggle">
                                    <div class="item-content">
                                        <div class="item-media">
                                            <i class="icon material-icons">tune</i>
                                        </div>
                                        <div class="item-inner">
                                            <div class="item-title">Model Parameters</div>
                                        </div>
                                    </div>
                                </div>
                                <div class="accordion-item-content">
                                    <div class="list">
                                        <ul>
                                            <!-- ✅ Contenedor dinámico para Model -->
                                            <li id="model-field-container">
                                                <!-- Se llenará dinámicamente -->
                                            </li>

                                            <!-- ✅ Contenedor dinámico para Summary Model -->
                                            <li id="summary-model-field-container">
                                                <!-- Se llenará dinámicamente -->
                                            </li>
                                            <li id="vision-model-field-container">
                                                <!-- Se llenará dinámicamente -->
                                            </li>
                                            <li>
                                                <div class="item-content item-input item-input-outline">
                                                    <div class="item-inner">
                                                        <div class="item-title item-floating-label">Temperature</div>
                                                        <div class="item-input-wrap">
                                                            <div class="item-media">
                                                                <i class="icon material-icons">thermostat</i>
                                                            </div>
                                                            <input type="number" name="temperature" value="${config.temperature || DEFAULT_TEMPERATURE}"
                                                                   placeholder="Temperature (0-2)" min="0" max="2" step="0.1" required/>
                                                            <span class="input-clear-button"></span>
                                                        </div>
                                                    </div>
                                                </div>
                                            </li>
                                            <li>
                                                <div class="item-content item-input item-input-outline">
                                                    <div class="item-inner">
                                                        <div class="item-title item-floating-label">Tool Temperature</div>
                                                        <div class="item-input-wrap">
                                                            <div class="item-media">
                                                                <i class="icon material-icons">build</i>
                                                            </div>
                                                            <input type="number" name="tool_temperature" value="${config.toolTemperature || 0.1}"
                                                                   placeholder="Temperature for tool calls (0-2)" min="0" max="2" step="0.1" required/>
                                                            <span class="input-clear-button"></span>
                                                        </div>
                                                    </div>
                                                </div>
                                            </li>
                                        </ul>
                                    </div>
                                </div>
                            </div>

                            <!-- Token Limits Section -->
                            <div class="accordion-item">
                                <div class="accordion-item-toggle">
                                    <div class="item-content">
                                        <div class="item-media">
                                            <i class="icon material-icons">format_list_numbered</i>
                                        </div>
                                        <div class="item-inner">
                                            <div class="item-title">Token Limits</div>
                                        </div>
                                    </div>
                                </div>
                                <div class="accordion-item-content">
                                    <div class="list">
                                        <ul>
                                            <li>
                                                <div class="item-content item-input item-input-outline">
                                                    <div class="item-inner">
                                                        <div class="item-title item-floating-label">Max Tokens</div>
                                                        <div class="item-input-wrap">
                                                            <div class="item-media">
                                                                <i class="icon material-icons">format_list_numbered</i>
                                                            </div>
                                                            <input type="number" name="max_tokens" value="${config.maxTokens || MAX_TOKENS}"
                                                                   placeholder="Maximum tokens" min="100" max="100000" required/>
                                                            <span class="input-clear-button"></span>
                                                        </div>
                                                    </div>
                                                </div>
                                            </li>
                                            <li>
                                                <div class="item-content item-input item-input-outline">
                                                    <div class="item-inner">
                                                        <div class="item-title item-floating-label">Token Limit</div>
                                                        <div class="item-input-wrap">
                                                            <div class="item-media">
                                                                <i class="icon material-icons">storage</i>
                                                            </div>
                                                            <input type="number" name="token_limit" value="${config.tokenLimit || TOKEN_LIMIT}"
                                                                   placeholder="Token limit for optimization" min="1000" max="20000" required/>
                                                            <span class="input-clear-button"></span>
                                                        </div>
                                                    </div>
                                                </div>
                                            </li>
                                        </ul>
                                    </div>
                                </div>
                            </div>
                            <div class="accordion-item">
                                <div class="accordion-item-toggle">
                                    <div class="item-content">
                                        <div class="item-media">
                                            <i class="icon material-icons">mic</i>
                                        </div>
                                        <div class="item-inner">
                                            <div class="item-title">Voice & Audio Settings</div>
                                        </div>
                                    </div>
                                </div>
                                <div class="accordion-item-content">
                                    <div class="list">
                                        <ul>
                                            <!-- Enable/Disable Voice Features -->
                                            <li>
                                                <div class="item-content">
                                                    <div class="item-media">
                                                        <i class="icon material-icons">record_voice_over</i>
                                                    </div>
                                                    <div class="item-inner">
                                                        <div class="item-title">Enable Voice Features</div>
                                                        <div class="item-after">
                                                            <label class="toggle toggle-init">
                                                                <input type="checkbox" name="voice_enabled"
                                                                       ${voiceConfig?.enabled ? 'checked' : ''}/>
                                                                <span class="toggle-icon"></span>
                                                            </label>
                                                        </div>
                                                    </div>
                                                </div>
                                            </li>

                                            <!-- Language Selection -->
                                            <li>
                                                <div class="item-content item-input item-input-outline">
                                                    <div class="item-inner">
                                                        <div class="item-title item-floating-label">Speech Language</div>
                                                        <div class="item-input-wrap">
                                                            <div class="item-media">
                                                                <i class="icon material-icons">language</i>
                                                            </div>
                                                            <select name="voice_language" required>
                                                                <option value="en-US" ${config.voiceLanguage === 'en-US' ? 'selected' : ''}>English (US)</option>
                                                                <option value="en-GB" ${config.voiceLanguage === 'en-GB' ? 'selected' : ''}>English (UK)</option>
                                                                <option value="es-ES" ${config.voiceLanguage === 'es-ES' ? 'selected' : ''}>Espa�ol (Espa�a)</option>
                                                                <option value="es-MX" ${config.voiceLanguage === 'es-MX' ? 'selected' : ''}>Espa�ol (M�xico)</option>
                                                                <option value="fr-FR" ${config.voiceLanguage === 'fr-FR' ? 'selected' : ''}>Fran�ais</option>
                                                                <option value="de-DE" ${config.voiceLanguage === 'de-DE' ? 'selected' : ''}>Deutsch</option>
                                                                <option value="it-IT" ${config.voiceLanguage === 'it-IT' ? 'selected' : ''}>Italiano</option>
                                                                <option value="pt-BR" ${config.voiceLanguage === 'pt-BR' ? 'selected' : ''}>Portugu�s (Brasil)</option>
                                                                <option value="ru-RU" ${config.voiceLanguage === 'ru-RU' ? 'selected' : ''}>???????</option>
                                                                <option value="ja-JP" ${config.voiceLanguage === 'ja-JP' ? 'selected' : ''}>???</option>
                                                                <option value="ko-KR" ${config.voiceLanguage === 'ko-KR' ? 'selected' : ''}>???</option>
                                                                <option value="zh-CN" ${config.voiceLanguage === 'zh-CN' ? 'selected' : ''}>?? (??)</option>
                                                            </select>
                                                            <span class="input-clear-button"></span>
                                                        </div>
                                                    </div>
                                                </div>
                                            </li>

                                            <!-- Max Recording Time -->
                                            <li>
                                                <div class="item-content item-input item-input-outline">
                                                    <div class="item-inner">
                                                        <div class="item-title item-floating-label">Max Recording Time (seconds)</div>
                                                        <div class="item-input-wrap">
                                                            <div class="item-media">
                                                                <i class="icon material-icons">timer</i>
                                                            </div>
                                                            <input type="number" name="max_recording_time"
                                                                   value="${config.maxRecordingTime || 30}"
                                                                   placeholder="Maximum recording duration"
                                                                   min="5" max="300" step="5" required/>
                                                            <span class="input-clear-button"></span>
                                                        </div>
                                                    </div>
                                                </div>
                                            </li>

                                            <!-- Auto Send After Voice -->
                                            <li>
                                                <div class="item-content">
                                                    <div class="item-media">
                                                        <i class="icon material-icons">send</i>
                                                    </div>
                                                    <div class="item-inner">
                                                        <div class="item-title">Auto-send after transcription</div>
                                                        <div class="item-text">Automatically send message after voice transcription</div>
                                                        <div class="item-after">
                                                            <label class="toggle toggle-init">
                                                                <input type="checkbox" name="voice_auto_send"
                                                                       ${config.voiceAutoSend ? 'checked' : ''}/>
                                                                <span class="toggle-icon"></span>
                                                            </label>
                                                        </div>
                                                    </div>
                                                </div>
                                            </li>

                                            <!-- Show Voice Button -->
                                            <li>
                                                <div class="item-content">
                                                    <div class="item-media">
                                                        <i class="icon material-icons">visibility</i>
                                                    </div>
                                                    <div class="item-inner">
                                                        <div class="item-title">Show voice button when disabled</div>
                                                        <div class="item-text">Display microphone button even if voice is disabled</div>
                                                        <div class="item-after">
                                                            <label class="toggle toggle-init">
                                                                <input type="checkbox" name="voice_show_button"
                                                                       ${config.voiceShowButton !== false ? 'checked' : ''}/>
                                                                <span class="toggle-icon"></span>
                                                            </label>
                                                        </div>
                                                    </div>
                                                </div>
                                            </li>

                                            <!-- Continuous Listening -->
                                            <li>
                                                <div class="item-content">
                                                    <div class="item-media">
                                                        <i class="icon material-icons">hearing</i>
                                                    </div>
                                                    <div class="item-inner">
                                                        <div class="item-title">Continuous listening</div>
                                                        <div class="item-text">Keep listening for multiple sentences</div>
                                                        <div class="item-after">
                                                            <label class="toggle toggle-init">
                                                                <input type="checkbox" name="voice_continuous"
                                                                       ${config.voiceContinuous ? 'checked' : ''}/>
                                                                <span class="toggle-icon"></span>
                                                            </label>
                                                        </div>
                                                    </div>
                                                </div>
                                            </li>

                                            <!-- Audio Quality Settings -->
                                            <li class="accordion-item-divider"></li>
                                            <li>
                                                <div class="item-content">
                                                    <div class="item-inner">
                                                        <div class="item-title text-color-gray">Audio Quality</div>
                                                    </div>
                                                </div>
                                            </li>

                                            <!-- Echo Cancellation -->
                                            <li>
                                                <div class="item-content">
                                                    <div class="item-media">
                                                        <i class="icon material-icons">volume_off</i>
                                                    </div>
                                                    <div class="item-inner">
                                                        <div class="item-title">Echo cancellation</div>
                                                        <div class="item-text">Remove echo from microphone input</div>
                                                        <div class="item-after">
                                                            <label class="toggle toggle-init">
                                                                <input type="checkbox" name="echo_cancellation"
                                                                       ${config.echoCancellation !== false ? 'checked' : ''}/>
                                                                <span class="toggle-icon"></span>
                                                            </label>
                                                        </div>
                                                    </div>
                                                </div>
                                            </li>

                                            <!-- Noise Suppression -->
                                            <li>
                                                <div class="item-content">
                                                    <div class="item-media">
                                                        <i class="icon material-icons">noise_control_off</i>
                                                    </div>
                                                    <div class="item-inner">
                                                        <div class="item-title">Noise suppression</div>
                                                        <div class="item-text">Reduce background noise</div>
                                                        <div class="item-after">
                                                            <label class="toggle toggle-init">
                                                                <input type="checkbox" name="noise_suppression"
                                                                       ${config.noiseSuppression !== false ? 'checked' : ''}/>
                                                                <span class="toggle-icon"></span>
                                                            </label>
                                                        </div>
                                                    </div>
                                                </div>
                                            </li>

                                            <!-- Auto Gain Control -->
                                            <li>
                                                <div class="item-content">
                                                    <div class="item-media">
                                                        <i class="icon material-icons">tune</i>
                                                    </div>
                                                    <div class="item-inner">
                                                        <div class="item-title">Auto gain control</div>
                                                        <div class="item-text">Automatically adjust microphone volume</div>
                                                        <div class="item-after">
                                                            <label class="toggle toggle-init">
                                                                <input type="checkbox" name="auto_gain_control"
                                                                       ${config.autoGainControl !== false ? 'checked' : ''}/>
                                                                <span class="toggle-icon"></span>
                                                            </label>
                                                        </div>
                                                    </div>
                                                </div>
                                            </li>
                                        </ul>
                                    </div>
                                </div>
                            </div>
                            <div class="accordion-item">
                            <a href="/screens/settings/" class="accordion-item-toggle item-link">
                                <div class="item-content">
                                    <div class="item-media">
                                        <i class="icon material-icons text-color-lightgreen">cloud_sync</i>
                                    </div>
                                    <div class="item-inner">
                                        <div class="item-title">Proxy Setup</div>

                                    </div>
                                </div>
                            </a>
                        </div>
                            <!-- Save Button -->
                            <div class="list inset margin-top">
                                <ul>
                                    <li>
                                        <div class="item-content">
                                            <div class="item-inner">
                                                <button type="submit" class="button button-fill button-large">Save Configuration</button>
                                            </div>
                                        </div>
                                    </li>
                                </ul>
                            </div>
                        </div>
                    </form>
                </div>
            </div>
        </div>
        <div class="popup popup-highlights" id="popup-highlights">
            <div class="view">
                <div class="page">
                    <div class="navbar">
                        <div class="navbar-bg"></div>
                        <div class="navbar-inner">
                            <div class="title">Highlighted Texts</div>
                            <div class="right">
                                <a href="#" class="link popup-close">Close</a>
                            </div>
                        </div>
                    </div>
                    <div class="page-content">
                        <div class="card margin-vertical no-shadow">
                            <div class="card-header">
                                <span>Highlights (${Object.keys(highlights).length})</span>
                                <a href="#" class="link icon-only" @click="${toggleSortableDisable}">
                                    <i class="icon material-icons">sort</i>
                                </a>
                            </div>
                            <div class="card-content">
                                <div id="sortable-highlights-list" class="list sortable no-safe-areas">
                                    <ul>
                                        ${Object.keys(highlights).length > 0 ? Object.keys(highlights).map((key, index) => $h`
                                        <li data-highlight-id="${key}">
                                            <div class="cursor-pointer item-content"
                                                 @click="${() => scrollToHighlight(key)}">
                                                <div class="item-inner">
                                                    <div class="item-title"
                                                         style="padding-right: 50px; word-wrap: break-word; overflow-wrap: break-word;">
                                                        ${highlights[key].text}
                                                    </div>
                                                    <div class="item-after"
                                                         style="position: absolute; right: 25px; top: 50%; transform: translateY(-50%); min-width: 30px;">
                                                        <a href="#" class="link margin-right" data-highlight-id="${key}"
                                                           @click="${(e) => removeHighlightFromPopup(e, key)}">
                                                            <i class="fa fa-trash color-red"></i>
                                                        </a>
                                                    </div>
                                                </div>
                                            </div>
                                            <div class="sortable-handler"></div>
                                        </li>
                                        `) : $h`
                                        <li class="no-sorting">
                                            <div class="item-content">
                                                <div class="item-inner">
                                                    <div class="item-title">No highlights found</div>
                                                </div>
                                            </div>
                                        </li>
                                        `}
                                    </ul>
                                </div>
                            </div>
                            <div class="card-footer">
                                <button class="button button-fill button-large" @click="${generalAction}">
                                    <i class="fa fa-pencil margin-right"></i>
                                    Create report
                                </button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div id="popover-tools" class="popover">
            <div class="popover-inner">
                <div class="list no-chevron no-hairlines-between">
                    <ul>
                        ${chat && chat.tools ? chat.tools.map((tool, index) => {
                        const toolName = tool.function?.name || `tool_${index}`;

                        // Inicializar si no existe
                        if (activeTools[toolName] === undefined) {
                        activeTools[toolName] = true;
                        }

                        const isActive = activeTools[toolName] === true;
                        return $h`
                        <li>
                            <div class="item-content tooltip-init"
                                 data-tooltip="${(tool.function?.description?.length > 100
        ? tool.function.description.substring(0, 100) + '...'
        : tool.function?.description || 'No description available')}">
                                <div class="item-media">
                                    <i style="color: ${isActive ? '#4CAF50' : '#757575'}" class="fa ${tool.function?.icon || 'fa-cog'} font-size-12 color-white"></i>
                                </div>
                                <div class="item-inner margin-left-half">
                                    <div class="item-title-row">
                                        <div class="item-text font-size-12" style="width:115px">${tool.function?.friendly_name || `Tool ${index + 1}`}</div>
                                        <div class="item-after"  style="display: flex; align-items: center; justify-content: flex-end; min-width: 60px;">
                                            <label class="toggle toggle-init" style="transform: scale(0.6);">
                                                <input type="checkbox"
                                                       checked="${isActive}"
                                                       @change="${(e) => toggleTool(toolName, e.target.checked)}"/>
                                                <span class="toggle-icon"></span>
                                            </label>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </li>
                        `;
                        }) : []}
                    </ul>
                </div>
            </div>
        </div>
        <div id="popover-proxy-services" class="popover">
            <div class="popover-inner">
                <div class="block-title margin-top-half margin-bottom-half">
                    <div class="row align-items-center">
                        <div class="col">
                            <span style="vertical-align: middle;">Corporate Services</span>
                        </div>
                    </div>
                </div>
                <div class="list no-chevron no-hairlines-between">
                    <ul>
                        ${window.proxyInfo && window.proxyInfo.services ? window.proxyInfo.services.map((service, index) => {
                        const serviceName = service.name;

                        // Inicializar si no existe
                        if (window.activeServices === undefined) {
                        window.activeServices = {};
                        }
                        if (window.activeServices[serviceName] === undefined) {
                        window.activeServices[serviceName] = true;
                        }

                        const isActive = window.activeServices[serviceName] === true;

                        // Icono según el tipo de servicio
                        let serviceIcon = service.icon;

                        return $h`
                        <li>
                            <div class="item-content tooltip-init"
                                 data-tooltip="${service.description}">
                                <div class="item-media">
                                    <i style="color: ${isActive ? '#4CAF50' : '#757575'}"
                                       class="fa ${serviceIcon} font-size-14"></i>
                                </div>
                                <div class="item-inner margin-left-half">
                                            <div class="item-text font-size-13">${serviceName}</div>
                                        <div class="item-after" style="display: flex; align-items: center; justify-content: flex-end; min-width: 60px;">
                                            <label class="toggle toggle-init" style="transform: scale(0.6);">
                                                <input type="checkbox"
                                                       checked="${isActive}"
                                                       @change="${(e) => toggleProxyService(serviceName, e.target.checked)}"/>
                                                <span class="toggle-icon"></span>
                                            </label>
                                        </div>
                                </div>
                            </div>
                        </li>
                        `;
                        }) : []}
                    </ul>
                </div>
                ${window.proxyInfo && window.proxyInfo.services && window.proxyInfo.services.length > 0 ? $h`
                <div class="block margin-top-half margin-bottom-half text-align-left" style="display: flex; justify-content: space-between; align-items: center;">
                    <p class="text-color-gray font-size-12" style="margin: 0;">
                        <i class="icon material-icons margin-right-half" style="font-size: 14px; vertical-align: middle;">info</i>
                        ${Object.values(window.activeServices || {}).filter(v => v).length} of ${window.proxyInfo.services.length} services enabled
                    </p>
                    <a href="/screens/settings/" class="margin-left link">
                        <i class="icon material-icons color-gray" style="font-size: 18px;">settings</i>
                    </a>
                </div>
                ` : ''}
            </div>
        </div>
        <div id="popover-text" class="popover">
            <div class="popover-inner" style="max-height:200px!important">
                ${myReference ? $h`
                <div class="block-title align-items-center margin-top">
                    ${currentReferenceGroup && currentReferenceGroup.length > 1 ? $h`
                    <div class="row align-items-center">
                        <div class="col">
                            <!-- Sin nombre cuando hay grupo -->
                        </div>
                        <div class="col-auto">
                            <div class="segmented segmented-mini">
                                <a href="#" id="prev-reference" class="button button-mini ${currentReferenceIndex === 0 ? 'disabled' : ''}">
                                    <i class="f7-icons">chevron_left</i>
                                </a>
                                <a href="#" id="next-reference" class="button button-mini ${currentReferenceIndex === currentReferenceGroup.length - 1 ? 'disabled' : ''}">
                                    <i class="f7-icons">chevron_right</i>
                                </a>
                            </div>
                        </div>
                    </div>
                    <span class="margin-left-half font-size-16 font-weight-normal text-color-gray">
                ${currentReferenceIndex + 1}/${currentReferenceGroup.length}
            </span>
                    ` : $h`
                    <span class="margin-left-half font-size-16 font-weight-normal text-color-gray">
                Page: ${myReference.page} Section: ${myReference.section}
            </span>
                    `}
                </div>
                <div class="block margin-bottom">
                    <strong>${myReference.name}</strong>
                    <p>${myReference.content}</p>
                </div>
                ` : $h`
                <div class="block text-align-center">
                    <span key="preloader" class="preloader"></span>
                </div>
                `}
            </div>
            <div class="popover-footer padding">
                <a href="#" id="view-source"
                   class="button float-left margin-bottom button-small button-round color-white bg-color-chrome link popover-close">
                    <i class="fa fa-file margin-right-half"></i>
                    <span>View source</span>
                </a>
                <a href="#" id="view-document"
                   class="margin-left-half float-left button margin-bottom button-small button-round color-white bg-color-chrome link popover-close">
                    <i class="fa fa-eye margin-right-half"></i>
                    <span>View document</span>
                </a>
            </div>
        </div>
        ${popupTask ? $h`
        <div data-tooltip="There is a guide started" style="top:-100px" class="tooltip-init fab thinking-icon fab-left-bottom color-gray">
            <a href="#" @click="${openTask}">
                <i class="icon material-icons">check</i>
            </a>
        </div>
        ` : $h``}

        <!-- Popover del men� de opciones -->
        <div class="popover" id="conversations-menu">
            <div class="popover-inner">
                <div class="list">
                    <ul>
                        <li>
                            <a href="#" class="item-link popover-close" @click="exportAllConversations">
                                <div class="item-content">
                                    <div class="item-media">
                                        <i class="icon material-icons">download</i>
                                    </div>
                                    <div class="item-inner">
                                        <div class="item-title">Export All</div>
                                    </div>
                                </div>
                            </a>
                        </li>
                        <li>
                            <a href="#" class="item-link popover-close" @click="showConversationStats">
                                <div class="item-content">
                                    <div class="item-media">
                                        <i class="icon material-icons">analytics</i>
                                    </div>
                                    <div class="item-inner">
                                        <div class="item-title">Statistics</div>
                                    </div>
                                </div>
                            </a>
                        </li>
                        <li>
                            <a href="#" class="item-link popover-close" @click="clearAllConversations">
                                <div class="item-content">
                                    <div class="item-media">
                                        <i class="icon material-icons color-red">delete_sweep</i>
                                    </div>
                                    <div class="item-inner">
                                        <div class="item-title color-red">Clear All</div>
                                    </div>
                                </div>
                            </a>
                        </li>
                    </ul>
                </div>
            </div>
        </div>

    </div>

</template>
<style>
    .orchestrator-variables-badges {
        margin-bottom: 15px;
        padding: 10px;
        background: rgba(102, 126, 234, 0.05);
        border-radius: 8px;
        border-left: 3px solid #667eea;
    }

    .variables-title {
        font-size: 11px;
        text-transform: uppercase;
        color: #667eea;
        font-weight: 600;
        margin-bottom: 8px;
        letter-spacing: 0.5px;
    }

    .variables-list {
        display: flex;
        flex-wrap: wrap;
        gap: 6px;
    }

    .variables-list .chip {
        cursor: help;
    }
    .resolved-value-badge {
        display: inline-block;
        background: rgba(33, 150, 243, 0.2);
        color: #2196F3;
        padding: 2px 6px;
        border-radius: 3px;
        font-size: 10px;
        margin-left: 5px;
        font-family: 'Courier New', monospace;
    }
    /* ═══════════════════════════════════════════════════════════
       EXECUTION PLAN PANEL - MINIMAL DESIGN
       ═══════════════════════════════════════════════════════════ */

    .execution-plan-panel-minimal {
        font-size: 13px;
    }

    .plan-header-minimal {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        padding: 12px 15px;
        display: flex;
        align-items: center;
        gap: 8px;
        color: white;
        font-weight: 600;
    }

    .plan-header-minimal i {
        font-size: 16px;
    }

    .plan-badge {
        margin-left: auto;
        background: rgba(255, 255, 255, 0.2);
        padding: 2px 8px;
        border-radius: 10px;
        font-size: 11px;
        font-weight: 600;
    }

    .plan-steps-minimal {
        padding: 10px;
    }

    .st-minimal {
        display: flex;
        align-items: flex-start;
        gap: 10px;
        padding: 10px;
        margin-bottom: 8px;
        background: rgba(255, 255, 255, 0.03);
        border-radius: 6px;
        border-left: 2px solid transparent;
        transition: all 0.3s ease;
    }

    .st-minimal.pending {
        border-left-color: #666;
    }

    .st-minimal.in-progress {
        border-left-color: #2196F3;
        background: rgba(33, 150, 243, 0.1);
        box-shadow: 0 0 10px rgba(33, 150, 243, 0.2);
    }

    .st-minimal.completed {
        border-left-color: #4CAF50;
    }

    .st-minimal.failed {
        border-left-color: #f44336;
        background: rgba(244, 67, 54, 0.1);
    }

    .st-minimal.skipped {
        opacity: 0.4;
        border-left-color: #666;
    }

    .st-status-icon {
        width: 20px;
        height: 20px;
        display: flex;
        align-items: center;
        justify-content: center;
        flex-shrink: 0;
    }

    .st-minimal.pending .st-status-icon i {
        color: #666;
        font-size: 8px;
    }

    .st-minimal.in-progress .st-status-icon i {
        color: #2196F3;
        font-size: 14px;
    }

    .st-minimal.completed .st-status-icon i {
        color: #4CAF50;
        font-size: 14px;
    }

    .st-minimal.failed .st-status-icon i {
        color: #f44336;
        font-size: 14px;
    }

    .st-minimal.skipped .st-status-icon i {
        color: #666;
        font-size: 14px;
    }

    .st-info {
        flex: 1;
        min-width: 0;
    }

    .st-title {
        font-weight: 500;
        margin-bottom: 3px;
        line-height: 1.3;
    }

    .st-tool {
        font-size: 11px;
        color: #999;
        font-family: 'Courier New', monospace;
    }

    .view-result-link {
        display: inline-flex;
        align-items: center;
        gap: 4px;
        margin-top: 5px;
        font-size: 11px;
        color: #2196F3;
        text-decoration: none;
    }

    .view-result-link:hover {
        color: #64B5F6;
    }

    .view-result-link i {
        font-size: 10px;
    }

    .plan-footer-minimal {
        padding: 10px 15px;
        background: rgba(244, 67, 54, 0.1);
        border-top: 2px solid #f44336;
        display: flex;
        align-items: center;
        gap: 8px;
        font-size: 12px;
    }

    .plan-footer-minimal i {
        color: #f44336;
    }

    .plan-abort-notice i {
        color: #f44336;
    }
    .final-response{
        font-size:1.1rem!important;
    }
    .thinking-container {
        margin: 10px 0;
        font-size:12px!important;
    }
    .collapsible-container{
        background-color:#3b3b3b;
        border-radius:8px!important;
    }

    .thinking-header {
        display: flex;
        align-items: center;
        padding: 10px;
        cursor: pointer;
        transition: background 0.2s ease;
    }

    .thinking-header:hover {
        background: rgba(66, 92, 141, 0.3);
    }

    .thinking-icon {
        font-size: 20px;
        margin-right: 8px;
    }

    .thinking-label {
        flex: 1;
    }

    .toggle-thinking-content {
        transition: transform 0.2s ease;
    }

    .thinking-content {
        max-height: 400px;
        overflow-y: auto;
        background-color: rgba(255, 255, 255, 0.05);
        line-height: 1.6;
        display:block;
        padding:10px;
        border-radius: 8px;

    }

    .thinking-content::-webkit-scrollbar {
        width: 6px;
    }

    .thinking-content::-webkit-scrollbar-track {
        background: rgba(255, 255, 255, 0.05);
        border-radius: 3px;
    }

    .thinking-content::-webkit-scrollbar-thumb {
        background: rgba(138, 180, 248, 0.3);
        border-radius: 3px;
    }

    .thinking-content::-webkit-scrollbar-thumb:hover {
        background: rgba(138, 180, 248, 0.5);
    }

    .final-response {
        margin-top: 15px;
        padding-top: 15px;
    }

    /* Animación suave para el chevron */
    .toggle-thinking-content i {
        transition: transform 0.3s ease;
    }
    /* Estilos para pasos del orquestador en el chat */
    .orchestrator-st-message {
        margin: 10px 0;
        border-left: 3px solid #667eea;
        background: rgba(102, 126, 234, 0.05);
        border-radius: 8px;
        overflow: hidden;
        transition: all 0.3s ease;
    }

    .orchestrator-st-message.st-in-progress {
        border-left-color: #2196F3;
        background: rgba(33, 150, 243, 0.1);
        box-shadow: 0 0 10px rgba(33, 150, 243, 0.2);
    }

    .orchestrator-st-message.st-completed {
        border-left-color: #4CAF50;
    }

    .orchestrator-st-message.st-failed {
        border-left-color: #f44336;
        background: rgba(244, 67, 54, 0.1);
    }

    .st-header {
        padding: 12px 15px;
        display: flex;
        align-items: center;
        gap: 10px;
        cursor: pointer;
        transition: background 0.2s ease;
        user-select: none;
    }

    .st-header:hover {
        background: rgba(255, 255, 255, 0.05);
    }

    .st-header .fa-chevron-right {
        font-size: 12px;
        color: #667eea;
        transition: transform 0.3s ease;
    }

    .st-header.expanded .fa-chevron-right {
        transform: rotate(90deg);
    }

    .st-header-title {
        flex: 1;
        font-weight: 500;
        font-size: 14px;
    }

    .st-status-badge {
        width: 20px;
        height: 20px;
        display: flex;
        align-items: center;
        justify-content: center;
        border-radius: 50%;
        font-size: 12px;
    }

    .st-status-badge.pending {
        color: #666;
    }

    .st-status-badge.in-progress i {
        color: #2196F3;
    }

    .st-status-badge.completed {
        color: #4CAF50;
    }

    .st-status-badge.failed {
        color: #f44336;
    }

    .st-content {
        padding: 0 15px 15px 15px;
        display: none;
        font-size: 13px;
    }

    .st-content.expanded {
        display: block;
    }

    .st-section {
        margin-bottom: 12px;
    }

    .st-section-title {
        font-weight: 600;
        color: #667eea;
        margin-bottom: 6px;
        font-size: 12px;
        text-transform: uppercase;
        letter-spacing: 0.5px;
    }

    .st-section-content {
        background: rgba(255, 255, 255, 0.03);
        padding: 10px;
        border-radius: 6px;
        line-height: 1.5;
        list-style: none;
    }

    .st-section-content * {
        list-style: none;
    }

    .st-tool-info {
        font-family: 'Courier New', monospace;
        font-size: 11px;
        color: #999;
        margin-bottom: 8px;
    }

    .st-extracted-value {
        background: rgba(76, 175, 80, 0.1);
        border-left: 3px solid #4CAF50;
        padding: 8px 10px;
        border-radius: 4px;
        margin-top: 8px;
        font-size: 12px;
    }

    .st-extracted-value .label {
        font-weight: 600;
        color: #4CAF50;
        margin-bottom: 4px;
    }

    .st-view-full-plan {
        display: inline-flex;
        align-items: center;
        gap: 5px;
        color: #667eea;
        font-size: 12px;
        text-decoration: none;
        margin-top: 10px;
        padding: 6px 10px;
        border-radius: 4px;
        border: 1px solid rgba(102, 126, 234, 0.3);
        transition: all 0.2s ease;
    }

    .st-view-full-plan:hover {
        background: rgba(102, 126, 234, 0.1);
        border-color: #667eea;
    }







    /* Toggle de razonamiento activo */
    .button-icon.color-blue {
        background-color: rgba(0, 122, 255, 0.1) !important;
    }

    .button-icon.color-blue:hover {
        background-color: rgba(0, 122, 255, 0.2) !important;
    }

    /* Animación suave al cambiar */
    .button-icon {
        transition: all 0.3s ease;
    }

    .button-icon i {
        transition: transform 0.2s ease;
    }

    .button-icon:active i {
        transform: scale(0.9);
    }
    .word-page {
        background: white;
        box-shadow: 0 4px 12px rgba(0,0,0,0.3);
        width: 21cm;
        min-height: 29.7cm;
        margin: 20px auto;
        padding: 2.5cm 2cm;
        border-radius: 6px;
        overflow: hidden;
        position: relative;
        page-break-after: always;
    }
    .simba-suggestion {
        display: block;
        width: fit-content;
        margin: 8px 0;
        padding: 10px 16px;
        border-radius: 8px;
        transition: all 0.2s ease;
        border: none;
        color:gray;
        margin-left:100px;
    }

    .simba-suggestion:hover {

        transform: translateX(4px);

    }

    .simba-suggestion:active {
        transform: translateX(2px);
    }

    .simba-suggestion i {
        transition: transform 0.2s ease;
    }

    .simba-suggestion:hover i {
        transform: translateX(4px);
    }
    /* Estilos para las tarjetas de imagen en el header del mensaje */
    .message-text-header .file-item.image-card {
        position: relative;
        width: 120px;
        height: 120px;
        display: inline-block;
        margin: 5px;
        border-radius: 8px;
        overflow: hidden;
        border: 2px solid #e0e0e0;
        transition: transform 0.2s ease, box-shadow 0.2s ease;
    }

    .message-text-header .file-item.image-card:hover {
        transform: translateY(-2px);
        box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        border-color: #007aff;
    }

    .message-text-header .image-card-thumbnail {
        width: 100% !important;
        height: 100% !important;
        object-fit: cover;
        border-radius: 6px;
    }

    .message-text-header .image-card-overlay {
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(0, 0, 0, 0.7);
        opacity: 0;
        transition: opacity 0.2s ease;
        display: flex;
        align-items: center;
        justify-content: center;
    }

    .message-text-header .file-item.image-card:hover .image-card-overlay {
        opacity: 1;
    }

    .message-text-header .image-card-actions {
        display: flex;
        gap: 8px;
    }

    .message-text-header .image-action-btn {
        width: 32px;
        height: 32px;
        background: rgba(255, 255, 255, 0.9);
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        transition: all 0.2s ease;
        color: #333;
    }

    .message-text-header .image-action-btn:hover {
        background: white;
        transform: scale(1.1);
    }
    .image-action-btn.view-image-btn:hover {
        background: #007aff;
        color: white;
    }

    /* Quitar esta regla ya que no hay bot�n de descarga:
    .image-action-btn.download-btn:hover {
        background: #28a745;
        color: white;
    }
    */
    /* Estilo para tarjetas de imagen */
    .file-item.image-card {
        position: relative;
        width: 120px;
        height: 120px;
        border-radius: 8px;
        overflow: hidden;
        border: 2px solid #312d2d;

        display: inline-block;
        margin: 5px;
        cursor: pointer;
        transition: transform 0.2s ease, box-shadow 0.2s ease;
    }

    .file-item.image-card:hover {
        transform: translateY(-2px);
        box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        border-color: #007aff;
    }

    .image-card-thumbnail {
        width: 100% !important;
        height: 100% !important;
        object-fit: cover;
        border-radius: 6px;
    }

    .image-card-overlay {
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(0, 0, 0, 0.7);
        opacity: 0;
        transition: opacity 0.2s ease;
        display: flex;
        align-items: center;
        justify-content: center;
    }

    .file-item.image-card:hover .image-card-overlay {
        opacity: 1;
    }

    .image-card-actions {
        display: flex;
        gap: 8px;
    }

    .image-action-btn {
        width: 32px;
        height: 32px;
        background: rgba(255, 255, 255, 0.9);
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        transition: all 0.2s ease;
        color: #333;
    }

    .image-action-btn:hover {
        background: white;
        transform: scale(1.1);
    }

    .image-action-btn.remove-btn:hover {
        background: #ff4444;
        color: white;
    }

    .image-action-btn.view-btn:hover {
        background: #007aff;
        color: white;
    }

    .image-action-btn.download-btn:hover {
        background: #28a745;
        color: white;
    }

    /* Mantener estilo original para archivos no-imagen */
    .file-item:not(.image-card) {
        /* Estilo horizontal original se mantiene */
    }
    .image-card-actions {
        display: flex;
        gap: 6px;
        flex-wrap: wrap;
        justify-content: center;
    }

    .image-action-btn {
        width: 28px;
        height: 28px;
        background: rgba(255, 255, 255, 0.9);
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        transition: all 0.2s ease;
        color: #333;
        font-size: 12px;
    }

    .image-action-btn.view-ocr-btn:hover {
        background: #17a2b8;
        color: white;
    }
    .image-card-actions {
        display: flex;
        gap: 8px;
        justify-content: center;
    }

    .image-action-btn {
        width: 32px;
        height: 32px;
        background: rgba(255, 255, 255, 0.9);
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        transition: all 0.2s ease;
        color: #333;
        font-size: 14px;
    }

    .image-action-btn:hover {
        background: white;
        transform: scale(1.1);
    }

    .image-action-btn.view-ocr-btn:hover {
        background: #007aff;
        color: white;
    }

    .image-action-btn.download-btn:hover {
        background: #28a745;
        color: white;
    }

    .image-action-btn.remove-btn:hover {
        background: #ff4444;
        color: white;
    }
    /* Resto del CSS igual... */
    .conversation-item {
        transition: background-color 0.3s ease;
    }

    .conversation-item.active {
        background-color: var(--f7-list-item-selected-bg-color, rgba(0, 122, 255, 0.15));
    }

    .conversation-item .item-media img {
        border: 2px solid var(--f7-bars-bg-color);
    }

    .conversation-item .item-after {
        display: flex;
        align-items: center;
        gap: 5px;
    }

    .conversation-item .time-badge {
        font-size: 11px;
        padding: 2px 6px;
        border-radius: 10px;
        background-color: var(--f7-bars-bg-color);
        color: var(--f7-bars-text-color);
    }

    .conversation-item .file-indicator {
        color: var(--f7-text-color);
        opacity: 0.6;
        font-size: 14px;
    }

    .conversation-item .swipeout-actions-right a {
        color: white;
        display: flex;
        align-items: center;
        justify-content: center;
        min-width: 80px;
    }

    .conversation-item .swipeout-delete {
        background-color: #ff3b30;
    }

    .conversation-item .swipeout-rename {
        background-color: #007aff;
    }

    .conversation-item .item-text {
        display: -webkit-box;
        -webkit-line-clamp: 2;
        -webkit-box-orient: vertical;
        overflow: hidden;
        text-overflow: ellipsis;
        max-height: 2.4em;
        line-height: 1.2em;
    }

    .list-group-title {
        font-weight: 600;
        text-transform: uppercase;
        letter-spacing: 0.5px;
        margin-top: 20px;
    }

    .list-group-title:first-child {
        margin-top: 0;
    }

    #conversations-panel .searchbar {
        margin-bottom: 0;
    }

    #conversations-panel .page-content {
        padding-top: 0;
    }

    .conversation-assistant-badge {
        font-size: 10px;
        padding: 1px 4px;
        border-radius: 6px;
        background-color: var(--f7-button-fill-bg-color);
        color: var(--f7-button-fill-text-color);
        margin-left: 4px;
    }
    reference {
        display: none !important;
    }
    .reference-group-main {
        position: relative;
    }

    .reference-group-main::after {
        content: attr(data-group-size);
        position: absolute;
        top: -8px;
        right: -8px;
        background: var(--f7-color-blue, #007aff);
        color: white;
        border-radius: 50%;
        width: 16px;
        height: 16px;
        font-size: 10px;
        display: flex;
        align-items: center;
        justify-content: center;
        font-weight: 600;
        z-index: 1;
    }

    .segmented-mini .button {
        min-width: 32px;
        height: 28px;
        padding: 0 !important;
    }

    .segmented-mini .button.disabled {
        opacity: 0.3;
        pointer-events: none;
    }

    .badge.margin-horizontal {
        margin: 0 8px;
        font-size: 11px;
        line-height: 1.2;
    }

    .segmented-mini {
        display: flex;
        align-items: center;
        gap: 4px;
    }

</style>
<script>


    export default function (props, {$, $el, $f7, $f7route, $f7router, $h, $on, $store, $theme, $update}) {

        // ===========================================
        // INITIALIZATION OF SIMBA MANAGERS
        // ===========================================

        const configManager = new window.SIMBA.ConfigManager();
        const messageManager = new window.SIMBA.MessageManager();
        const sourceManager = new window.SIMBA.SourceManager();
        const highlightManager = new window.SIMBA.HighlightManager();
        let toolManager = null; // Will be initialized after chat is loaded
        let mentionManager = null; // Will be initialized after assistants are loaded
        let voiceManager = null;
        let conversationManager = null;
        let isRecording = false;
        let isProcessingVoice = false;
        let voiceSupported = false;
        let autoScrollEnabled = true;
        let isUserScrolling = false;
        let scrollTimeout = null;
        let debouncedAutoScroll = null
        let autoScrolling = false;
        let originalAssistant = null;      // Asistente original/padre
        let showAssistantChip = false;     // Flag para mostrar/ocultar chip
        // ===========================================
        // ORIGINAL TEMPLATE VARIABLES (NO CHANGES)
        // ===========================================

        let response = '';
        let isResponding = null;
        let notFinishedMessage = '';
        let prompt = null;
        let messages = [];
        let messagebar = null;
        let processingToolResponse = false;
        let sources = [];
        let dialogChoiceChip = null;
        let actionsCustomLayout = null;
        let actionsToolsLayout = null;
        let usageData = null;
        let highlights = {};
        let popupHighlights = null;
        let popupTask = null;
        let popupApiKeys = null;
        let formApiKeysValidator = null;

        // Framework7 specific state
        let scrollToBottomBtn = null;
        let pageContent = null;
        let breakAutoScroll = false;
        let showCenteredBar = messageManager.getHistory().length === 1;
        let showBottomBar = messageManager.getHistory().length > 1;

        // User and Assistant data
        let user = {
            guid: '05F1A0C-54F6-5A83-25E0-13EB149B237'
        };
        let assistant = null;
        let assistants = [];
        let quick_actions = [];

        // Chat data
        let chat = {
            guid: $f7route.params.guid,
            title: 'New conversation',
            instructions: [],
            noSelectionInstructions: []
        };

        // Device and form data
        let devices = [
            "FFS CN235", "FFS C295 TS03", "FFS C295 EA03", "FFS A400M", "FTD A400M",
            "CHT-E", "CMOS A400M", "FFS A330 MRTT", "CPTT", "DT-MRTT", "FMS A400M",
            "LMWS", "MPRS", "GENERAL"
        ];
        let myDevice = null;
        let ticket = {
            device: '',
            problem_title: "",
            problem_description: ""
        };
        let voiceConfig = {
            enabled: false,
            showButton: false,
            autoInit: true
        };

// Luego ya puedes usar:
        const VOICE_FEATURES_ENABLED = true;
        const shouldEnableVoice = VOICE_FEATURES_ENABLED && voiceConfig.enabled;

        // UI Elements
        let activeTools = {}; // Para trackear qu� tools est�n activas
        window.activeTools = activeTools;
        let popupTicket = null;
        let formTicketValidator = null;
        let popupConfig = null;
        let formConfigValidator = null;
        let popoverSelection = null;
        let popoverTools = null;
        let popoverText = null;
        let myReference = null;
        let selectedText = "";
        let uploadedFiles = [];
        let loadedImages = {}; // Objeto donde la clave es el nombre de la imagen
        let loadedFiles = {};  //

        let isResponseInBackground = false;
        let streamingProgress = 0;
        let fullStreamingResponse = "";
        let currentStreamingRequest = null;

        // Configuration
        let config = configManager.getConfig();
        let extractedContents = "";
        // Constants
        let TOKEN_LIMIT = 45000;
        let MAX_TOKENS = 25000;
        let DEFAULT_TEMPERATURE = 0;
        let DEFAULT_MODEL = "magistral-2509";//mistral-small-24B-instruct-2506";//"mistral-small-24B-instruct-2506";//"mistral-small-24B-instruct-2506";//"phi-4";"magistral-2509"
        let SUMMARY_MODEL = "mistral-small-24B-instruct-2506";
        let VISION_MODEL = "mistral-small-24B-instruct-2506-vision"; // ✅ NUEVO
        const footerTemplate = '<div class="message-footer-content"><div class="sources margin-bottom float-left"></div><div class="actions margin-top-half width-100 text-align-right float-right"></div></div>';
        let availableModels = [];
        let modelsLoadError = false;

        let reasoningEnabled = false; // Por defecto activado
        let currentModelCategory = null; // Para trackear la categoría del modelo actual
        let fullThinkingContent = "";
        let fullResponse = "";
        let iterativeReasoningEnabled = false;
        let maxIterations = 5;
        let currentIteration = 0;
        let iterationContext = [];
        class IterativeReasoner {
            constructor(config) {
                this.maxIterations = config.maxIterations || 10;
                this.orchestratorModel = config.orchestratorModel || 'gpt-4o-mini';
                this.conversationHistory = config.conversationHistory || [];
                this.maxRecursionDepth = config.maxRecursionDepth || 2;
                this.currentRecursionDepth = config.currentRecursionDepth || 0;
                this.executionPlan = null;
                this.resolvedValues = {};
                this.collectedInfo = [];
                this.executionLog = [];
                this.assistantMessageId = null;
                this.currentStepIndex = 0;
                this.planId = Date.now()
            }

            /**
             * 🎯 MÉTODO PRINCIPAL: Orquestar toda la ejecución
             */
            async orchestrate(userQuery, assistantMsgId) {
                this.assistantMessageId = assistantMsgId;

                // FASE 1: Crear plan con orquestador
                const plan = await this.createExecutionPlan(userQuery);
                this.executionPlan = plan;

                // FASE 2: Ejecutar plan
                await this.executePlan();

                // FASE 3: Construir contexto enriquecido
                const enrichedContext = this.buildEnrichedContext();

                return enrichedContext;
            }

            async createExecutionPlan(userQuery) {
                console.log('📋 Creating execution plan...');

                // Construir historial como texto
                const historyText = this.conversationHistory
                    .slice(-6)
                    .map(msg => `${msg.role}: ${msg.content}`)
                    .join('\n');

                const planningPrompt = `You are an execution planner. Analyze the user's query and create a detailed execution plan.

CONVERSATION HISTORY:
${historyText}

CURRENT USER QUERY: "${userQuery}"

AVAILABLE TOOLS:
${this.getAvailableToolsDescription()}

CRITICAL RULES FOR OUTDATED/CONTRADICTORY QUERIES:
- If the query assumes something has changed (e.g., "who succeeded X?", "who replaced Y?", "what happened to Z?")
- If the query contradicts your knowledge (e.g., asking about someone's successor when they're still in position)
- If the query is about current positions, status, or recent events
→ YOU MUST create a search/web tool step FIRST to verify current information
→ DO NOT assume your knowledge is current
→ Examples: "who succeeded Pope Francis?" → SEARCH FIRST, don't assume he's still Pope

CRITICAL JSON FORMAT RULES:
✅ CORRECT: "dependencies": [1, 2]
❌ WRONG: "dependencies": ["step_id": 1]
✅ CORRECT: "params": {"text": "query here"}
❌ WRONG: "params": {"q": "query"}

CRITICAL PLACEHOLDER RULES:
- Placeholders MUST use {{variable_name}} format, NOT [variable_name]
- Placeholders MUST match outputs_produced names EXACTLY
- Each step can ONLY reference variables from previous steps
- NEVER invent variable names - only use what's in outputs_produced

EXAMPLE CORRECT PLAN:
{
  "steps": [
    {
      "step_id": 1,
      "outputs_produced": ["successor_name"],
      "tool": "WebGoogle",
      "params": {"text": "who succeeded Pope Francis"}
    },
    {
      "step_id": 2,
      "inputs_required": ["successor_name"],
      "outputs_produced": ["birthplace"],
      "dependencies": [1],
      "tool": "WebGoogle",
      "params": {"text": "birthplace of {{successor_name}}"}
    },
    {
      "step_id": 3,
      "step_type": "ask_user",
      "purpose": "Get user's age for comparison",
      "prompt": "What is your age?",
      "outputs_produced": ["user_age"],
      "dependencies": []
    },
    {
      "step_id": 4,
      "inputs_required": ["birthplace"],
      "dependencies": [2],
      "tool": "WebGoogle",
      "params": {"text": "weather forecast for weekend in {{birthplace}}"}
    }
  ]
}

EXAMPLE WRONG PLAN:
{
  "steps": [
    {
      "step_id": 1,
      "outputs_produced": ["successor_info"],
      "params": {"text": "who succeeded Pope Francis"}
    },
    {
      "step_id": 2,
      "params": {"text": "birthplace of [successor_name]"}
    },
    {
      "step_id": 3,
      "step_type": "ask_user",
      "prompt": "Request user age"
    }
  ]
}

Create a JSON plan with this EXACT structure:
{
  "analysis": "brief analysis - NOTE if query contradicts knowledge and requires verification",
  "steps": [
    {
      "step_id": 1,
      "step_type": "reasoning" | "tool" | "ask_user" | "orchestrate",
      "purpose": "DESCRIPTIVE purpose of this step",
      "inputs_required": [],
      "outputs_produced": ["result_var"],
      "dependencies": [],
      "skip_if_filled": false,
      "validate_if_filled": false,
      "condition": {
        "type": "if" | "unless" | "branch",
        "variable": "varName",
        "equals": "value",
        "expression": "boolean expression",
        "action": "execute" | "skip" | "jump",
        "jump_to_step": 5
      },
      "prompt": "What is your age? (clear question for ask_user) OR Sub-query for orchestrate",
      "tool": "WebGoogle",
      "params": {"text": "search query with {{placeholders}}"}
    }
  ],
  "execution_type": "sequential"
}

STEP TYPES:
- "reasoning": Use LLM to analyze/think
- "tool": Call external tool (WebGoogle, etc.)
- "ask_user": Ask user for information
- "orchestrate": Create sub-plan for complex sub-task (use sparingly, max depth: ${this.maxRecursionDepth})

WHEN TO USE "orchestrate":
- Only for complex sub-tasks that themselves need multiple steps
- Example: "Find CEO's birthplace and weather" could be one orchestrate step
- DO NOT use for simple queries - use tool/reasoning instead
- Current recursion depth: ${this.currentRecursionDepth}/${this.maxRecursionDepth}

MANDATORY RULES:
1. dependencies MUST be array of numbers: [1, 2, 3]
2. purpose MUST be descriptive
3. For ask_user steps, prompt MUST be a SPECIFIC CLEAR question in natural language
   ❌ WRONG: "Request the user's age"
   ❌ WRONG: "Get user age"
   ✅ CORRECT: "What is your age?"
   ✅ CORRECT: "What is your age so I can compare it with Elsa Pataky's?"
4. For WebGoogle tool, use "text" parameter (not "q")
5. Placeholders use {{variable}} format, never [variable]
6. Placeholders MUST match outputs_produced from previous steps EXACTLY
7. Declare ALL variables explicitly in outputs_produced
8. Use conditions when logic depends on data
9. Use skip_if_filled for redundant checks
10. ALWAYS search/verify if query contradicts your knowledge

CRITICAL OUTPUT FORMAT:
- Return ONLY the JSON object
- NO markdown (no \`\`\`json or \`\`\`)
- NO explanations before or after
- NO text like "Here is the plan:" or "**User Query:**"
- Start directly with { and end with }
- Example: {"analysis":"...","steps":[...]}

WRONG outputs:
❌ **User Query:** ... {json}
❌ \`\`\`json {json} \`\`\`
❌ Here is the plan: {json}

Return ONLY valid JSON starting with { and ending with }. No markdown, no explanations, no text before or after.`;
                const response = await this.callOrchestratorLLM(planningPrompt, true);

                let plan;
                const cleaned = response.replace(/```json\n?/g, '').replace(/```\n?/g, '').trim();

                try {
                   plan = JSON.parse(cleaned);
                } catch (e) {
                    console.error('❌ Failed to parse plan:', e);
                    console.error('Raw response:', response); // 🆕 AÑADIR ESTO
                    console.error('Cleaned response:', cleaned); // 🆕 AÑADIR ESTO
                    throw new Error('Invalid execution plan format');
                }

                console.log('✅ Plan created:', plan);
                return plan;
            }


            async executePlan() {
                if (!this.executionPlan || !this.executionPlan.steps) return;

                const steps = this.executionPlan.steps;
                console.log('📋 Starting plan execution:', steps.length, 'steps');

                // 🆕 Crear badges de variables
                createVariablesBadges(this.executionPlan, this.assistantMessageId, this.planId);

                // Crear contenedores visuales para cada paso
                for (const step of steps) {
                    createStepMessageInChat(step, this.assistantMessageId, this.planId);
                }

                this.currentStepIndex = 0;

                while (this.currentStepIndex < steps.length) {
                    const step = steps[this.currentStepIndex];
                    console.log(`\n🎯 STEP ${step.step_id}: ${step.purpose}`);

                    const uniqueId = `${this.planId}-${step.step_id}`;

                    // 1️⃣ EVALUAR CONDICIÓN
                    if (step.condition) {
                        const shouldExecute = this.evaluateCondition(step.condition);

                        if (step.condition.action === 'skip' && shouldExecute) {
                            console.log('⏭️ Skipping step due to condition');
                            updateChatStepStatus(uniqueId, 'skipped');
                            updateStepStatus(uniqueId, 'skipped');
                            this.currentStepIndex++;
                            continue;
                        }

                        if (step.condition.action === 'jump' && shouldExecute) {
                            console.log(`⤴️ Jumping to step ${step.condition.jump_to_step}`);
                            this.currentStepIndex = steps.findIndex(s => s.step_id === step.condition.jump_to_step);
                            continue;
                        }
                    }

                    // 2️⃣ VERIFICAR SKIP_IF_FILLED
                    if (step.skip_if_filled && this.allOutputsFilled(step.outputs_produced)) {
                        console.log('⏭️ Skipping - outputs already filled');
                        updateChatStepStatus(uniqueId, 'skipped');
                        updateStepStatus(uniqueId, 'skipped');
                        this.currentStepIndex++;
                        continue;
                    }

                    // 3️⃣ VALIDAR INPUTS_REQUIRED
                    if (step.inputs_required && step.inputs_required.length > 0) {
                        const missingInputs = step.inputs_required.filter(v => !this.resolvedValues[v]);

                        if (missingInputs.length > 0) {
                            console.warn(`⚠️ Missing required inputs: ${missingInputs.join(', ')}`);

                            // 🆕 INTENTAR RE-ORQUESTAR PARA OBTENER VARIABLES FALTANTES
                            if (this.currentRecursionDepth < this.maxRecursionDepth) {
                                console.log('🔄 Attempting to re-orchestrate to obtain missing inputs...');

                                try {
                                    const recoveryQuery = `I need to obtain the following information: ${missingInputs.join(', ')}. Please create a plan to gather this data.`;

                                    const recoveryReasoner = new IterativeReasoner({
                                        maxIterations: this.maxIterations,
                                        orchestratorModel: this.orchestratorModel,
                                        conversationHistory: this.conversationHistory,
                                        maxRecursionDepth: this.maxRecursionDepth,
                                        currentRecursionDepth: this.currentRecursionDepth + 1
                                    });

                                    recoveryReasoner.assistantMessageId = this.assistantMessageId;

                                    // Ejecutar plan de recuperación
                                    await recoveryReasoner.orchestrate(recoveryQuery, this.assistantMessageId);

                                    // Copiar variables resueltas del plan de recuperación
                                    Object.assign(this.resolvedValues, recoveryReasoner.resolvedValues);

                                    console.log('✅ Recovery plan completed, obtained:', recoveryReasoner.resolvedValues);

                                    // Verificar si ahora tenemos las variables
                                    const stillMissing = missingInputs.filter(v => !this.resolvedValues[v]);
                                    if (stillMissing.length > 0) {
                                        console.error('❌ Recovery failed, still missing:', stillMissing);
                                        updateChatStepStatus(uniqueId, 'failed', `Missing: ${stillMissing.join(', ')}`);
                                        updateStepStatus(uniqueId, 'failed', `Missing: ${stillMissing.join(', ')}`);
                                        break;
                                    }

                                    console.log('✅ All missing inputs obtained, continuing execution');

                                } catch (error) {
                                    console.error('❌ Recovery orchestration failed:', error);
                                    updateChatStepStatus(uniqueId, 'failed', `Missing: ${missingInputs.join(', ')}`);
                                    updateStepStatus(uniqueId, 'failed', `Missing: ${missingInputs.join(', ')}`);
                                    break;
                                }
                            } else {
                                console.error('❌ Max recursion depth reached, cannot recover');
                                updateChatStepStatus(uniqueId, 'failed', `Missing: ${missingInputs.join(', ')}`);
                                updateStepStatus(uniqueId, 'failed', `Missing: ${missingInputs.join(', ')}`);
                                break;
                            }
                        }
                    }

                    // 4️⃣ EJECUTAR STEP
                    updateChatStepStatus(uniqueId, 'in-progress');
                    updateStepStatus(uniqueId, 'in-progress');

                    try {
                        let result;

                        if (step.step_type === 'reasoning') {
                            result = await this.executeReasoningStep(step);
                        } else if (step.step_type === 'tool') {
                            result = await this.executeToolStep(step);
                        } else if (step.step_type === 'ask_user') {
                            result = await this.executeAskUserStep(step, uniqueId);
                        } else if (step.step_type === 'orchestrate') {
                            result = await this.executeOrchestrateStep(step, uniqueId);
                        }

                        // 5️⃣ EXTRAER OUTPUTS
                        if (step.outputs_produced && step.outputs_produced.length > 0) {
                            const extracted = await this.extractOutputs(result, step.outputs_produced);
                            Object.assign(this.resolvedValues, extracted);
                            console.log('💾 Stored outputs:', extracted);

                            // 🆕 Actualizar badges
                            for (const [varName, value] of Object.entries(extracted)) {
                                updateVariableBadge(this.planId, varName, value);
                            }
                        }

                        // Guardar info
                        this.collectedInfo.push({
                            step_id: step.step_id,
                            step_type: step.step_type,
                            purpose: step.purpose,
                            result: result,
                            outputs: step.outputs_produced
                        });

                        updateChatStepStatus(uniqueId, 'completed', result, JSON.stringify(this.resolvedValues));
                        updateStepStatus(uniqueId, 'completed', result);

                    } catch (error) {
                        console.error(`❌ Step ${step.step_id} failed:`, error);
                        updateChatStepStatus(uniqueId, 'failed', error.message);
                        updateStepStatus(uniqueId, 'failed', error.message);

                        this.executionLog.push({
                            step_id: step.step_id,
                            status: 'failed',
                            error: error.message
                        });

                        if (step.critical !== false) {
                            // Marcar pasos restantes como saltados
                            for (let j = this.currentStepIndex + 1; j < steps.length; j++) {
                                const skipId = `${this.planId}-${steps[j].step_id}`;
                                updateStepStatus(skipId, 'skipped');
                                updateChatStepStatus(skipId, 'skipped');
                            }
                            break;
                        }
                    }

                    await new Promise(resolve => setTimeout(resolve, 200));
                    this.currentStepIndex++;
                }

                console.log('✅ Plan execution completed');
            }

            /**
             * 🧠 EVALUAR CONDICIÓN
             */
            evaluateCondition(condition) {
                if (!condition) return true;

                const { type, variable, equals, not_equals, expression } = condition;

                if (type === 'if' || type === 'unless') {
                    const value = this.resolvedValues[variable];

                    if (equals !== undefined) {
                        const matches = value == equals;
                        return type === 'if' ? matches : !matches;
                    }

                    if (not_equals !== undefined) {
                        const matches = value != not_equals;
                        return type === 'if' ? matches : !matches;
                    }
                }

                if (type === 'branch' && expression) {
                    try {
                        // Evaluar expresión (ej: "pope_color === 'black'")
                        const func = new Function('resolvedValues', `with(resolvedValues) { return ${expression}; }`);
                        return func(this.resolvedValues);
                    } catch (e) {
                        console.error('❌ Failed to evaluate condition:', e);
                        return false;
                    }
                }

                return true;
            }

            /**
             * ✅ VERIFICAR SI TODOS LOS OUTPUTS ESTÁN LLENOS
             */
            allOutputsFilled(outputs) {
                if (!outputs || outputs.length === 0) return false;
                return outputs.every(varName => this.resolvedValues[varName] !== undefined);
            }

            async executeReasoningStep(step) {
                const prompt = this.resolvePlaceholders(step.prompt || step.purpose);
                console.log('🧠 Reasoning prompt:', prompt);

                // Construir mensajes con contexto conversacional
                const messages = [
                    { role: 'system', content: 'You are a helpful assistant.' },
                    // Añadir últimos mensajes del historial (solo user/assistant, no system)
                    ...this.conversationHistory.filter(m => m.role !== 'system').slice(-4),
                    { role: 'user', content: prompt }
                ];

                return new Promise((resolve, reject) => {
                    $f7.request({
                        url: window.config.completion.url,
                        method: 'POST',
                        dataType: 'json',
                        contentType: 'application/json',
                        headers: {
                            'Authorization': `Bearer ${window.config.completion.apiKey}`
                        },
                        data: {
                            model: this.orchestratorModel,
                            messages: messages,  // ← Pasar array de mensajes
                            max_tokens: 500
                        },
                        success: (response) => {
                            const content = response.choices[0].message.content;
                            console.log('💡 Reasoning result:', content);
                            resolve(content);
                        },
                        error: (xhr, status, error) => {
                            console.error('❌ Reasoning failed:', error);
                            reject(new Error(error));
                        }
                    });
                });
            }

            /**
             * 🔧 EJECUTAR TOOL STEP
             */
            async executeToolStep(step) {
                const params = this.resolveParamsPlaceholders(step.params);
                console.log('🔧 Calling tool:', step.tool, params);

                const result = await callTool(step.tool, params);
                return typeof result === 'object' ? JSON.stringify(result) : String(result);
            }
            async executeOrchestrateStep(step, uniqueId) {
                console.log(`🔄 Executing nested orchestration (depth: ${this.currentRecursionDepth + 1})`);

                // Verificar límite de recursión
                if (this.currentRecursionDepth >= this.maxRecursionDepth) {
                    console.warn('⚠️ Max recursion depth reached, executing as reasoning instead');
                    return await this.executeReasoningStep(step);
                }

                // Resolver el sub-query con placeholders
                const subQuery = this.resolvePlaceholders(step.prompt || step.purpose);
                console.log(`📋 Sub-query: ${subQuery}`);

                // Crear nuevo IterativeReasoner con depth + 1
                const subReasoner = new IterativeReasoner({
                    maxIterations: this.maxIterations,
                    orchestratorModel: this.orchestratorModel,
                    conversationHistory: this.conversationHistory,
                    maxRecursionDepth: this.maxRecursionDepth,
                    currentRecursionDepth: this.currentRecursionDepth + 1
                });

                // Usar el mismo assistantMessageId para que los pasos aparezcan en el mismo mensaje
                subReasoner.assistantMessageId = this.assistantMessageId;

                // Ejecutar sub-orquestación
                try {
                    const subContext = await subReasoner.orchestrate(subQuery, this.assistantMessageId);

                    // El resultado es el contexto enriquecido de la sub-orquestación
                    console.log(`✅ Sub-orchestration complete (depth: ${this.currentRecursionDepth + 1})`);
                    return subContext;

                } catch (error) {
                    console.error(`❌ Sub-orchestration failed at depth ${this.currentRecursionDepth + 1}:`, error);
                    throw error;
                }
            }
            async executeAskUserStep(step, uniqueId) {
                return new Promise((resolve) => {
                    let question = step.prompt || step.purpose;

                    // Mejorar pregunta basándose en outputs_produced
                    if (step.outputs_produced && step.outputs_produced.length > 0) {
                        const varName = step.outputs_produced[0];

                        // Convertir snake_case a texto legible
                        const readable = varName.replace(/_/g, ' ');

                        // Si la pregunta no es clara, construir una mejor
                        if (!question || question.length < 10 || question.startsWith('Request') || question.startsWith('Get')) {
                            question = `What is the ${readable}?`;
                        }
                    }

                    question = this.resolvePlaceholders(question);

                    $f7.dialog.prompt(question, 'Input Required', (answer) => {
                        console.log('💬 User answered:', answer);

                        if (step.outputs_produced && step.outputs_produced.length > 0) {
                            const extracted = {};
                            step.outputs_produced.forEach(varName => {
                                extracted[varName] = answer;
                            });
                            Object.assign(this.resolvedValues, extracted);
                        }

                        updateChatStepStatus(uniqueId, 'completed', `User input: ${answer}`, answer);
                        updateStepStatus(uniqueId, 'completed', `User input: ${answer}`);

                        resolve(answer);
                    }, () => {
                        updateChatStepStatus(uniqueId, 'skipped', 'User cancelled');
                        updateStepStatus(uniqueId, 'skipped', 'User cancelled');
                        resolve('[User cancelled]');
                    });
                });
            }

            /**
             * 📤 EXTRAER OUTPUTS usando LLM
             */
            async extractOutputs(result, outputVars) {
                const prompt = `Extract ONLY these variables from the result as SIMPLE STRING VALUES.

VARIABLES TO EXTRACT: ${outputVars.join(', ')}

RESULT:
${result.substring(0, 2000)}

CRITICAL RULES:
- Return SIMPLE string values, NOT nested objects
- If multiple pieces of info, extract the most relevant name/identifier
- ❌ WRONG: {"pope_info": {"name": "X", "date": "Y"}}
- ✅ CORRECT: {"pope_name": "Pope Leo XIV"}

Return ONLY this JSON structure:
{
  "${outputVars[0]}": "simple string value here"
}

No explanations, no markdown, no nested objects.`;

                return new Promise((resolve) => {
                    $f7.request({
                        url: window.config.completion.url,
                        method: 'POST',
                        dataType: 'json',
                        contentType: 'application/json',
                        headers: {
                            'Authorization': `Bearer ${window.config.completion.apiKey}`
                        },
                        data: {
                            model: this.orchestratorModel,
                            messages: [
                                { role: 'system', content: 'Extract data as SIMPLE string values. Never return nested JSON objects.' },
                                ...this.conversationHistory.filter(m => m.role !== 'system').slice(-2),
                                { role: 'user', content: prompt }
                            ],
                            max_tokens: 20000,
                            temperature: 0
                        },
                        success: (response) => {
                            try {
                                const content = response.choices[0].message.content;
                                const cleaned = content.replace(/```json\n?/g, '').replace(/```/g, '').trim();
                                const extracted = JSON.parse(cleaned);

                                // Validar que NO hay objetos anidados
                                for (const [key, value] of Object.entries(extracted)) {
                                    if (typeof value === 'object' && value !== null) {
                                        console.warn('⚠️ Nested object detected, converting to string');
                                        extracted[key] = JSON.stringify(value);
                                    }
                                }

                                console.log('✅ Extracted:', extracted);
                                resolve(extracted);
                            } catch (e) {
                                console.error('❌ Failed to extract:', e);
                                const fallback = {};
                                fallback[outputVars[0]] = result;
                                resolve(fallback);
                            }
                        },
                        error: () => {
                            const fallback = {};
                            fallback[outputVars[0]] = result;
                            resolve(fallback);
                        }
                    });
                });
            }

            /**
             * 🔄 RESOLVER PLACEHOLDERS EN TEXTO
             */
            resolvePlaceholders(text) {
                if (!text) return text;

                let resolved = text;
                const regex = /\{\{(\w+)\}\}/g;
                let match;

                while ((match = regex.exec(text)) !== null) {
                    const varName = match[1];
                    const value = this.resolvedValues[varName] || `[${varName} not found]`;
                    resolved = resolved.replace(match[0], value);
                }

                return resolved;
            }

            /**
             * 🔄 RESOLVER PLACEHOLDERS EN PARAMS
             */
            resolveParamsPlaceholders(params) {
                if (!params || typeof params !== 'object') return params;

                const resolved = {};
                for (const [key, value] of Object.entries(params)) {
                    if (typeof value === 'string') {
                        resolved[key] = this.resolvePlaceholders(value);
                    } else if (typeof value === 'object') {
                        resolved[key] = this.resolveParamsPlaceholders(value);
                    } else {
                        resolved[key] = value;
                    }
                }
                return resolved;
            }

            /**
             * 🤖 LLAMAR AL LLM ORQUESTADOR
             */
            async callOrchestratorLLM(prompt, includeTools = false) {
                return new Promise((resolve, reject) => {
                    const requestData = {
                        model: this.orchestratorModel,
                        messages: [
                            { role: 'system', content: 'You are an execution planner that creates structured JSON plans.' },
                            { role: 'user', content: prompt }
                        ],
                        max_tokens: 2000
                    };

                    if (includeTools) {
                        requestData.tools = this.getAvailableTools();
                    }

                    $f7.request({
                        url: window.config.completion.url,
                        method: 'POST',
                        dataType: 'json',
                        contentType: 'application/json',
                        headers: {
                            'Authorization': `Bearer ${window.config.completion.apiKey}`
                        },
                        data: requestData,
                        success: (response) => {
                            const content = response.choices[0].message.content || '';
                            resolve(content.trim());
                        },
                        error: (xhr, status, error) => {
                            console.error('❌ Orchestrator LLM error:', error);
                            reject(new Error(error));
                        }
                    });
                });
            }

            /**
             * 🛠️ OBTENER TOOLS DISPONIBLES
             */
            getAvailableTools() {
                if (!chat || !chat.activeTools) return [];

                return chat.activeTools.map(tool => {
                    // Limpiar propiedades que no deben ir al LLM
                    const cleanTool = {
                        type: tool.type,
                        function: {
                            name: tool.function.name,
                            description: tool.function.description,
                            parameters: tool.function.parameters
                        }
                    };
                    return cleanTool;
                });
            }

            /**
             * 📝 DESCRIPCIÓN DE TOOLS PARA EL ORQUESTADOR
             */
            getAvailableToolsDescription() {
                const tools = this.getAvailableTools();
                if (!tools || tools.length === 0) return 'No tools available';

                return tools.map(tool => {
                    return `- ${tool.function.name}: ${tool.function.description}`;
                }).join('\n');
            }

            /**
             * 📦 CONSTRUIR CONTEXTO ENRIQUECIDO FINAL
             */
            buildEnrichedContext() {
                let context = '=== COLLECTED INFORMATION ===\n\n';

                this.collectedInfo.forEach((info, idx) => {
                    context += `[Step ${info.step_id}] ${info.purpose}\n`;
                    context += `Result: ${info.result}\n\n`;
                });

                context += '\n=== RESOLVED VARIABLES ===\n';
                for (const [key, value] of Object.entries(this.resolvedValues)) {
                    context += `${key}: ${value}\n`;
                }

                return context;
            }
        }

        let createVariablesBadges = function(executionPlan, assistantMsgId, planId) {
            const assistantMsg = document.getElementById(assistantMsgId);
            if (!assistantMsg) return;

            const messageBubble = assistantMsg.querySelector('.message-bubble');
            const messageText = assistantMsg.querySelector('.message-text');
            if (!messageBubble || !messageText) return;

            // Recopilar todas las variables del plan
            const allVariables = new Set();
            executionPlan.steps.forEach(step => {
                if (step.outputs_produced) {
                    step.outputs_produced.forEach(v => allVariables.add(v));
                }
            });

            if (allVariables.size === 0) return;

            // Crear contenedor de chips
            const badgesContainer = document.createElement('div');
            badgesContainer.className = 'orchestrator-variables-badges';
            badgesContainer.id = `variables-badges-${planId}`;
            badgesContainer.innerHTML = `
        <div class="variables-title">Variables to resolve:</div>
        <div class="variables-list">
            ${Array.from(allVariables).map(varName => `
                <div class="chip"
                     id="var-badge-${planId}-${varName}"
                     data-var-name="${varName}"
                     title="${varName}">
                    <div class="chip-label">${varName}</div>
                </div>
            `).join('')}
        </div>
    `;

            messageBubble.insertBefore(badgesContainer, messageText);
        };

        let updateVariableBadge = function(planId, varName, value) {
            const badge = document.getElementById(`var-badge-${planId}-${varName}`);
            if (!badge) return;

            badge.classList.add('color-green');

            // Truncar valor si es muy largo
            let displayValue = String(value);
            const fullValue = displayValue;

            if (displayValue.length > 30) {
                displayValue = displayValue.substring(0, 30) + '...';
            }

            const label = badge.querySelector('.chip-label');
            if (label) {
                label.textContent = displayValue;
            }

            badge.title = fullValue; // Tooltip con valor completo
        };

        // Después de las constantes como DEFAULT_MODEL, etc.
        const REASONING_INSTRUCTION = `

CRITICAL REASONING PROTOCOL:
When reasoning mode is active, you MUST structure your response in two parts:

1. THINKING SECTION (hidden from user):
   - Wrap your reasoning process in [THINK]...[/THINK] tags
   - Think step by step about the problem
   - Consider multiple approaches
   - Evaluate pros and cons
   - Plan your response strategy
   - This section will NOT be shown to the user

2. FINAL RESPONSE (visible to user):
   - After [/THINK] tag, provide your clear, polished answer
   - Base it on your thinking but make it concise and user-friendly
   - Do not reference or mention your thinking process
   - Respond naturally as if the thinking never happened

Example structure:
[THINK]
Let me break down this problem...
Step 1: Understanding the question...
Step 2: Consider the options...
Step 3: Best approach would be...
Therefore, I should respond with...
[/THINK]

Here is my clear answer to your question: [your response]

MANDATORY: You MUST always start with [THINK] when reasoning mode is active. Never skip the thinking phase.
`;
        /**
         * Verifica si el modelo actual es de razonamiento
         * @param {string} modelName - Nombre del modelo
         * @returns {boolean}
         */
        let isReasoningModel = function(modelName) {
            if (!modelName || !availableModels || availableModels.length === 0) {
                return false;
            }

            const model = availableModels.find(m => m.name === modelName);
            if (!model || !model.category) {
                return false;
            }

            const category = model.category.replace('iaModels_category_', '');
            return category === 'reasoning';
        };

        /**
         * Actualiza la categoría del modelo actual
         */
        let updateCurrentModelCategory = function() {
            const currentConfig = configManager.getConfig();
            const modelName = currentConfig.model || DEFAULT_MODEL;

            if (!availableModels || availableModels.length === 0) {
                currentModelCategory = null;
                return;
            }

            const model = availableModels.find(m => m.name === modelName);
            if (model && model.category) {
                currentModelCategory = model.category.replace('iaModels_category_', '');
                console.log('📊 Current model category:', currentModelCategory);
            } else {
                currentModelCategory = null;
            }
        };
        // ==========================================
        // FUNCIONES PARA PROXY SERVICES
        // ==========================================

        let toggleProxyService = function(serviceName, isActive) {
            if (!window.activeServices) {
                window.activeServices = {};
            }

            window.activeServices[serviceName] = isActive;
            console.log(`📡 Proxy service ${serviceName} ${isActive ? 'enabled' : 'disabled'}`);

            // Actualizar el tool de retrieve_data_from_corporate_services
            updateProxyTool();
            updateTemplate();
        };

        let updateProxyTool = function() {
            if (!window.proxyInfo || !chat || !chat.tools) return;

            // Obtener servicios activos
            const activeServicesList = window.proxyInfo.services
                .filter(service => window.activeServices[service.name] === true)
                .map(service => service.name);

            if (activeServicesList.length === 0) {
                console.log('⚠️ No active services - tool will be disabled');
                // Opcional: podrías deshabilitar el tool aquí
                return;
            }

            console.log('🔄 Updating proxy tool with active services:', activeServicesList);

            // Recrear el tool con solo los servicios activos
            const activeServicesInfo = window.proxyInfo.services.filter(
                service => window.activeServices[service.name] === true
            );

            const serviceDescriptions = activeServicesInfo.map(service => {
                return `- **${service.name}**: ${service.host} (auth: ${service.auth_type})`;
            }).join('\n');

            const serviceNames = activeServicesInfo.map(s => s.name).join(', ');

            const updatedTool = {
                type: "function",
                function: {
                    name: "retrieve_data_from_corporate_services",
                    friendly_name: "Retrieve Corporate Data",
                    description: `Search and retrieve data from corporate services through the proxy.

**Available services:**
${serviceDescriptions}

Use this tool when the user asks for information that might be stored in corporate systems like Confluence, Jira, or other integrated services.

**Usage guidelines:**
- Select only the relevant services for the query (don't use all services for every query)
- The 'term' parameter should be a clear search query
- Multiple services can be specified as a comma-separated list
- Available service names: ${serviceNames}`,
                    parameters: {
                        type: "object",
                        properties: {
                            term: {
                                type: "string",
                                description: "The search term or query to look up in the corporate services"
                            },
                            services: {
                                type: "string",
                                description: `Comma-separated list of services to search. Available: ${serviceNames}. Example: "${activeServicesList[0]}" or "${activeServicesList.slice(0, 2).join(',')}"`
                            }
                        },
                        required: ["term", "services"]
                    }
                }
            };

            // Actualizar el tool en chat.tools
            const toolIndex = chat.tools.findIndex(
                t => t.function?.name === 'retrieve_data_from_corporate_services'
            );

            if (toolIndex >= 0) {
                chat.tools[toolIndex] = updatedTool;
                console.log('✅ Proxy tool updated');
            }

            // Actualizar también en activeTools
            if (chat.activeTools) {
                const activeIndex = chat.activeTools.findIndex(
                    t => t.function?.name === 'retrieve_data_from_corporate_services'
                );

                if (activeIndex >= 0) {
                    chat.activeTools[activeIndex] = updatedTool;
                }
            }
        };

        // FIN FUNCIONES PARA PROXY SERVICES


        /**
         * Toggle para activar/desactivar razonamiento
         */
        let toggleReasoning = function() {
            const currentConfig = configManager.getConfig();
            const currentState = isReasoningEnabled();
            const newState = !currentState;

            // Guardar nuevo estado
            currentConfig.reasoningEnabled = newState;
            configManager.updateConfig(currentConfig);

            console.log('🔄 Reasoning toggled:', currentState, '→', newState);

            $f7.toast.show({
                text: `Reasoning ${newState ? 'enabled' : 'disabled'}`,
                position: 'center',
                closeTimeout: 1500,
                cssClass: newState ? 'color-blue' : 'color-orange'
            });

            updateTemplate();
        };
        /**
         * Carga la lista de modelos disponibles desde el endpoint
         */
        let loadAvailableModels = async function() {
            const modelsEndpoint = window.config?.models;

            if (!modelsEndpoint) {
                console.warn('⚠️ Models endpoint not configured');
                modelsLoadError = true;
                return [];
            }

            try {
                console.log('📡 Loading available models from:', modelsEndpoint);

                const response = await fetch(modelsEndpoint, {
                    method: 'GET',
                    headers: {
                        'x-auth-token': `${window.config.token}`,
                        'Content-Type': 'application/json'
                    }
                });

                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }

                const responseData = await response.json();

                // ✅ DEBUGGING: Ver la estructura completa
                console.log('📦 Full response:', responseData);
                console.log('📦 Response.data:', responseData.data);
                console.log('📦 Is array?:', Array.isArray(responseData.data));

                // ✅ CORRECCIÓN: Acceder directamente a responseData.data
                if (responseData && responseData.data && Array.isArray(responseData.data)) {
                    // Los modelos están en responseData.data, NO en responseData.data.data
                    availableModels = responseData.data
                        .filter(model => model.name) // Filtrar los que tienen nombre
                        .sort((a, b) => a.name.localeCompare(b.name)); // Ordenar alfabéticamente

                    console.log(`✅ Loaded ${availableModels.length} models:`, availableModels);

                    // ✅ DEBUGGING: Mostrar modelos por categoría
                    const byCategory = availableModels.reduce((acc, model) => {
                        const cat = model.category?.replace('iaModels_category_', '') || 'unknown';
                        acc[cat] = (acc[cat] || 0) + 1;
                        return acc;
                    }, {});
                    console.log('📊 Models by category:', byCategory);
                    updateCurrentModelCategory()
                    modelsLoadError = false;
                    return availableModels;
                } else {
                    console.error('❌ Invalid response structure:', {
                        hasResponseData: !!responseData,
                        hasData: !!responseData?.data,
                        isArray: Array.isArray(responseData?.data),
                        dataType: typeof responseData?.data
                    });
                    throw new Error('Invalid response format');
                }

            } catch (error) {
                console.error('❌ Error loading models:', error);
                console.error('❌ Error stack:', error.stack);
                modelsLoadError = true;
                availableModels = [];
                return [];
            }
        };

        /**
         * Renderiza el campo de modelo (select o input según disponibilidad)
         * @param {string} fieldName - Nombre del campo (model, summary_model, vision_model)
         * @param {string} labelText - Texto del label
         * @param {string} currentValue - Valor actual seleccionado
         * @param {string} containerSelector - Selector del contenedor
         * @param {Array<string>} allowedCategories - Array de categorías permitidas (ej: ['chat', 'reasoning'])
         */
        let renderModelField = function(fieldName, labelText, currentValue, containerSelector, allowedCategories = []) {
            const container = document.querySelector(containerSelector);
            if (!container) {
                console.error(`Container ${containerSelector} not found`);
                return;
            }

            let html = '';

            if (modelsLoadError || availableModels.length === 0) {
                // Fallback: input text
                html = `
            <div class="item-content item-input item-input-outline">
                <div class="item-inner">
                    <div class="item-title item-floating-label">${labelText}</div>
                    <div class="item-input-wrap">
                        <div class="item-media">
                            <i class="icon material-icons">memory</i>
                        </div>
                        <input type="text" name="${fieldName}" value="${currentValue || ''}"
                               placeholder="Model name" required/>
                        <span class="input-clear-button"></span>
                    </div>
                </div>
            </div>
        `;
            } else {
                // ✅ Filtrar modelos por categorías permitidas
                let filteredModels = availableModels;

                if (allowedCategories.length > 0) {
                    filteredModels = availableModels.filter(model => {
                        if (!model.category) return false;
                        // Extraer la categoría del formato "iaModels_category_chat"
                        const categoryName = model.category.replace('iaModels_category_', '');
                        return allowedCategories.includes(categoryName);
                    });
                }

                console.log(`📋 ${fieldName}: ${filteredModels.length} models (categories: ${allowedCategories.join(', ')})`);

                if (filteredModels.length === 0) {
                    // Si no hay modelos después del filtro, mostrar input text
                    html = `
                <div class="item-content item-input item-input-outline">
                    <div class="item-inner">
                        <div class="item-title item-floating-label">${labelText}</div>
                        <div class="item-input-wrap">
                            <div class="item-media">
                                <i class="icon material-icons">memory</i>
                            </div>
                            <input type="text" name="${fieldName}" value="${currentValue || ''}"
                                   placeholder="No models available for this category" required/>
                            <span class="input-clear-button"></span>
                        </div>
                    </div>
                </div>
            `;
                } else {
                    // ✅ Select con modelos filtrados
                    const options = filteredModels.map(model => {
                        const selected = model.name === currentValue ? 'selected' : '';
                        const providerName = model.provider?.name || 'Unknown';
                        const displayName = `${model.name} (${providerName})`;
                        return `<option value="${model.name}" ${selected}>${displayName}</option>`;
                    }).join('');

                    html = `
                <div class="item-content item-input item-input-outline">
                    <div class="item-inner">
                        <div class="item-title item-floating-label">${labelText}</div>
                        <div class="item-input-wrap">
                            <div class="item-media">
                                <i class="icon material-icons">memory</i>
                            </div>
                            <select name="${fieldName}" required>
                                ${options}
                            </select>
                            <span class="input-clear-button"></span>
                        </div>
                    </div>
                </div>
            `;
                }
            }

            container.innerHTML = html;
        };
        // Dislike reasons
        const unlikeReasons = [
            {
                value: "no_solution",
                reason: "Doesn't solve the issue",
                description: "I followed the steps but the problem persists."
            },
            {value: "incorrect", reason: "Contains errors", description: "The information or steps are wrong."},
            {value: "incomplete", reason: "Missing information", description: "Key steps or details are omitted."},
            {
                value: "unclear",
                reason: "Hard to understand",
                description: "The instructions are confusing or too technical."
            },
            {
                value: "not_applicable",
                reason: "Not applicable to my setup",
                description: "The steps don't fit my hardware or configuration."
            },
            {value: "other", reason: "Other (please specify)", description: "The issue doesn't match any of the above."}
        ];

        let activateAssistantChip = function() {
            // Si no hay asistente original, guardar el actual como original
            if (!originalAssistant && assistant) {
                originalAssistant = { ...assistant };
                console.log('?? Original assistant set:', originalAssistant.name);
            }

            // Verificar si debemos mostrar el chip
            const shouldShow = assistant && originalAssistant && assistant.guid !== originalAssistant.guid;

            if (shouldShow !== showAssistantChip) {
                showAssistantChip = shouldShow;
                console.log(shouldShow ? '? Showing assistant chip' : '? Hiding assistant chip');
                $update(); // ? USAR $update() en lugar de manipular DOM
            }
        };
        let returnToOriginalAssistant = function() {
            if (originalAssistant) {
                console.log('?? Returning to original assistant:', originalAssistant.name);

                // Cambiar al asistente original usando tu funci�n existente
                switchAssistant(originalAssistant.guid);

                // El chip se ocultar� autom�ticamente por la l�gica de activateAssistantChip
                // que se ejecuta en switchAssistant ? updateTemplate

                // Toast de confirmaci�n
                $f7.toast.show({
                    text: `Going back to ${originalAssistant.name}`,
                    position: 'center',
                    closeTimeout: 20000,
                    cssClass: 'color-blue'
                });

                // Enfocar textarea
                textAreaFocus(prompt)
            }
        };
        // ===========================================
        // TEMPLATE DATA SYNC FUNCTION
        // ===========================================

        /**
         * Syncs SIMBA managers data to template variables
         * Call this before every $update()
         */
        function syncTemplateData() {
            highlights = highlightManager.getAll();
            sources = sourceManager.getTempSources();
            showCenteredBar = messageManager.getHistory().length === 1;
            showBottomBar = messageManager.getHistory().length > 1;
            config = configManager.getConfig();
        }

        /**
         * Enhanced update function that syncs data before updating template
         */
        function updateTemplate() {
            syncTemplateData();
            activateAssistantChip();
            $update();
        }

        // ===========================================
        // MARKDOWN SETUP
        // ===========================================

        hljs.registerLanguage('stask', function (hljs) {
            return hljs.getLanguage('json');
        });

        let md = window.markdownit({
            html: true,
            linkify: true,
            typographer: true,
            highlight: function (str, lang) {
                if (lang && hljs.getLanguage(lang)) {
                    try {
                        return '<pre class="no-margin-top hljs" data-lang="' + lang + '"><code class="cod-with-auto">' +
                            hljs.highlight(str.replace('<span class="thinking-icon">' + (assistant?.thinkIcon || '') + '</span>', '').replace('```', ""), {
                                language: lang,
                                ignoreIllegals: true
                            }).value +
                            '</code></pre>';
                    } catch (__) {
                    }
                }
                return '<pre class="no-margin-top hljs"><code>' + md.utils.escapeHtml(str.replace('<span class="thinking-icon">' + (assistant?.thinkIcon || '') + '</span>', '').replace('```', "")) + '</code></pre>';
            }
        }).use(window.texmath, {engine: window.katex, delimiters: 'brackets'});

        var defaultRender = md.renderer.rules.link_open || function(tokens, idx, options, env, self) {
            return self.renderToken(tokens, idx, options);
        };

        md.renderer.rules.link_open = function (tokens, idx, options, env, self) {
            // Agregar target="_blank" para abrir en nueva pestaña
            var aIndex = tokens[idx].attrIndex('target');
            if (aIndex < 0) {
                tokens[idx].attrPush(['target', '_blank']);
            } else {
                tokens[idx].attrs[aIndex][1] = '_blank';
            }

            // Agregar rel="noopener noreferrer" para seguridad
            // Esto previene vulnerabilidades de tipo "tabnabbing"
            var relIndex = tokens[idx].attrIndex('rel');
            var relClass = tokens[idx].attrIndex('class');
            if (relIndex < 0) {
                tokens[idx].attrPush(['rel', 'noopener noreferrer']);
                tokens[idx].attrPush(['class', 'external']);
            } else {
                tokens[idx].attrs[relIndex][1] = 'noopener noreferrer';
                tokens[idx].attrs[relClass][1] = 'external';
            }

            return defaultRender(tokens, idx, options, env, self);
        };
        let chartGenerator = null;

// En la funci�n de inicializaci�n, agregar:
        let initializeChartGenerator = function() {
            if (typeof ChartGenerator !== 'undefined') {
                chartGenerator = new ChartGenerator();
                console.log('? ChartGenerator initialized');
            } else {
                console.warn('? ChartGenerator not available. Make sure Chart.js and ChartGenerator.js are loaded.');
            }
        };

// 2. FUNCI�N PARA CREAR GR�FICA DESDE TABLA
// ----------------------------------------------------------------------------

        let createChartFromTable = function(tableId, chartType = 'auto') {
            if (!chartGenerator) {
                $f7.toast.show({
                    text: 'Chart generator not available',
                    position: 'center',
                    closeTimeout: 3000,
                    cssClass: 'color-red'
                });
                return;
            }

            try {
                // Encontrar la tabla y su contenedor padre
                const table = document.getElementById(tableId);
                if (!table) {
                    throw new Error(`Table with ID '${tableId}' not found`);
                }

                const parentContainer = table.closest('.table-container') || table.parentElement;
                const parentId = parentContainer.id || `chart_container_${Date.now()}`;

                // Asignar ID al contenedor si no lo tiene
                if (!parentContainer.id) {
                    parentContainer.id = parentId;
                }

                // Crear la gr�fica en modo append (agregar despu�s de la tabla)
                const chart = chartGenerator.createChart(tableId, parentId, chartType, 'append', 'auto');

                console.log('? Chart created successfully from table:', tableId);

                $f7.toast.show({
                    text: 'Chart created successfully!',
                    position: 'center',
                    closeTimeout: 2000,
                    cssClass: 'color-green'
                });

                return chart;

            } catch (error) {
                console.error('? Error creating chart:', error);

                $f7.toast.show({
                    text: `Error creating chart: ${error.message}`,
                    position: 'center',
                    closeTimeout: 4000,
                    cssClass: 'color-red'
                });
            }
        };

// 3. FUNCI�N PARA MOSTRAR SELECTOR DE TIPO DE GR�FICA
// ----------------------------------------------------------------------------

        let showChartTypeSelector = function(tableId) {
            const chartTypes = [
                { value: 'auto', label: '?? Auto (Recommended)', description: 'Let the system choose the best chart type' },
                { value: 'bar', label: '?? Bar Chart', description: 'Vertical bars for comparing categories' },
                { value: 'horizontalBar', label: '?? Horizontal Bar', description: 'Horizontal bars for long category names' },
                { value: 'line', label: '?? Line Chart', description: 'Line chart for trends over time' },
                { value: 'pie', label: '?? Pie Chart', description: 'Circular chart for parts of a whole' },
                { value: 'doughnut', label: '?? Doughnut Chart', description: 'Doughnut chart with center space' }
            ];

            const buttons = chartTypes.map(type => ({
                text: `<div style="text-align: left;">
                 <div style="font-weight: bold; margin-bottom: 4px;">${type.label}</div>
                 <div style="font-size: 12px; color: #666;">${type.description}</div>
               </div>`,
                onClick: () => createChartFromTable(tableId, type.value)
            }));

            buttons.push({
                text: 'Cancel',
                color: 'red'
            });

            $f7.actions.create({
                buttons: [buttons]
            }).open();
        };
        // ===========================================
        // CORE FUNCTIONS USING SIMBA MANAGERS
        // ===========================================

        // Funci�n para guardar mensaje
        let saveMessageToConversation = function(role, content, messageId, metadata = {}) {
            // Solo crear conversaci�n si no existe Y si es un mensaje real (no sistema)
            if (!conversationManager.currentConversationId && (role === 'user' || role === 'assistant')) {
                // Crear conversaci�n en este momento
                conversationManager.createConversation(assistant, chat.title, myDevice).then(() => {
                    console.log('Conversation created with first real message');

                    // Guardar el mensaje simple
                    const messageData = {
                        role,
                        content,
                        id: messageId
                    };

                    return conversationManager.saveMessage(messageData, {
                        sources: sourceManager.getTempSources(),
                        device: myDevice,
                        files: window.myFileDropzone ? window.myFileDropzone.getFiles() : [],
                        ...metadata
                    });
                }).catch(error => {
                    console.error('Error creating conversation and saving message:', error);
                });
            } else if (conversationManager.currentConversationId && (role === 'user' || role === 'assistant')) {
                // Ya existe conversaci�n, guardar mensaje simple
                const messageData = {
                    role,
                    content,
                    id: messageId
                };

                conversationManager.saveMessage(messageData, {
                    sources: sourceManager.getTempSources(),
                    device: myDevice,
                    files: window.myFileDropzone ? window.myFileDropzone.getFiles() : [],
                    ...metadata
                }).catch(error => {
                    console.error('Error saving message:', error);
                });
            }
        };
        /**
         * Creates a new conversation using the chat API
         */
        let createConversation = function (guid) {
            /*if (conversationManager && conversationManager.currentConversationId && chat.guid) {
                console.log('Using existing loaded conversation:', conversationManager.currentConversationId);
                return Promise.resolve({ data: chat });
            }*/
            return new Promise((resolve, reject) => {
                $f7.request({
                    url: `${window.config.api_methods.create_chat}?assistant=` + guid,
                    method: 'GET',
                    headers: {
                        'x-auth-token': window.config.token,
                        'Content-Type': 'application/json'
                    },
                    dataType: 'json'
                }).then((response) => {
                    chat = response.data.data;
                    chat.noSelectionInstructions = chat.instructions ? chat.instructions.filter(instruction => !instruction.isSelection) : [];

                    // NO crear la conversaci�n aqu� autom�ticamente
                    // conversationManager.createConversation(assistant, chat.title, myDevice)

                    // Update message manager with system message
                    messageManager.updateSystemMessage(chat.mainAssistant.system);

                    // Initialize tool manager now that we have chat
                    toolManager = new window.SIMBA.ToolManager(chat, configManager.getConfig());

                    assistant.name = chat.mainAssistant.name;
                    assistant.avatar = window.config.domain + chat.mainAssistant._myMedias.avatars[0].realPath;
                    assistant.mainImage = window.config.domain + chat.mainAssistant._myMedias.mainImage[0].realPath;
                    assistant.greeting = chat.mainAssistant.greeting;
                    assistant.placeholder = chat.mainAssistant.placeholder;
                    assistant.thinkIcon = chat.mainAssistant.thinkIcon || '??';
                    //assistant.analyzeImage = chat.mainAssistant.analizeImages.command

                    updateTemplate();
                    updateDropzoneState();
                    initializeActiveTools();
                    updateChatTools();
                    console.log('Conversation created:', response.data);
                    resolve(response.data);
                }).catch((error) => {
                    console.error('Error creating conversation:', error);
                    reject(error);
                });
            });
        };
        let startNewConversation = function() {
            console.log('🆕 Starting new conversation with current assistant');

            if (!assistant || !assistant.guid) {
                console.error('No active assistant');
                $f7.toast.show({
                    text: 'No assistant selected',
                    cssClass: 'color-red'
                });
                return;
            }

            // Guardar el GUID del asistente actual
            const currentAssistantGuid = assistant.guid;

            // Navegar a nueva conversación pasando el asistente actual
            $f7router.navigate(`/screens/conversation/new?assistant=${currentAssistantGuid}`, {
                reloadCurrent: true,
                clearPreviousHistory: false
            });
        };
        let openTask = function(){
            popupTask.open();
        }
        //FUNCIONES PARA TOOLS
        let initializeActiveTools = function() {
            console.log('Initializing active tools...');

            if (chat && chat.tools && Array.isArray(chat.tools)) {
                activeTools = {};
                chat.tools.forEach((tool, index) => {
                    const toolName = tool.function?.name || `tool_${index}`;
                    activeTools[toolName] = true;
                });
                console.log('Tools initialized as active:', activeTools);

                // Forzar re-render despu�s de un tick
                setTimeout(() => {
                    updateTemplate();
                }, 100);
            } else {
                activeTools = {};
            }
        };

        let isImageUploadAllowed = function() {
            return chat &&
                chat.mainAssistant &&
                chat.mainAssistant.analizeImages.command !== 'iaAssistant_analizeImages_No_allowed';
        };

        let getImageAnalysisType = function() {
            if (!chat || !chat.mainAssistant) return null;

            switch(chat.mainAssistant.analizeImages.command) {
                case 'iaAssistant_analizeImages_OCR':
                    return 'OCR';
                case 'iaAssistant_analizeImages_Vision':
                    return 'Vision';
                case 'iaAssistant_analizeImages_No_allowed':
                    return null;
                default:
                    return 'Vision'; // valor por defecto
            }
        };
        let toggleTool = function(toolKey, isActive) {
            activeTools[toolKey] = isActive;
            console.log(`Tool ${toolKey} ${isActive ? 'activated' : 'deactivated'}`);

            // Actualizar el chat.tools para reflejar los cambios
            updateChatTools();
            updateTemplate();
        };
        let updateChatTools = function() {
            if (!chat || !chat.tools) return;

            // Crear nueva array solo con tools activas
            const activeToolsArray = [];
            chat.tools.forEach((tool, index) => {
                const toolName = tool.function?.name || `tool_${index}`;
                if (activeTools[toolName] === true) {
                    activeToolsArray.push(tool);
                }
            });

            chat.activeTools = activeToolsArray;
            console.log('Active tools updated:', activeToolsArray);
        };
        //FIN FUNCIONES PARA TOOLS
        /**
         * Loads available assistants
         */
        let loadAssistants = function () {
            return new Promise((resolve, reject) => {
                $f7.request({
                    url: window.config.api_methods.load_assistants,
                    method: 'GET',
                    headers: {
                        'X-AUTH-TOKEN': window.config.token
                    },
                    success: function (responseText) {
                        var data = JSON.parse(responseText);
                        assistants = data.data.assistants;
                        quick_actions = data.data.quick_actions;

                        // Initialize mention manager with assistants
                        mentionManager = new window.SIMBA.AssistantMentionManager(assistants, switchAssistant);

                        if (assistants.length > 0) {
                            if ('assistant' in $f7route.query) {
                                assistant = assistants.find(assistant => assistant.guid === $f7route.query.assistant);
                            } else {
                                assistant = assistants[0];
                                switchAssistant(assistant.guid);
                            }
                            if (!originalAssistant && assistant) {
                                originalAssistant = { ...assistant };
                                console.log('?? Initial original assistant:', originalAssistant.name);
                            }
                            updateTemplate();
                            resolve({assistant: assistant, quick_actions: quick_actions});
                        } else {
                            console.error("The 'assistants' array is empty.");
                            resolve({assistant: null, quick_actions: quick_actions});
                        }
                    },
                    error: function (xhr, status, error) {
                        $f7.toast.show({
                            text: 'An error occurred: ' + error,
                            cssClass: 'color-red'
                        });
                        reject(error);
                    }
                });
            });
        };

        let switchAssistant = async function (guid) {
            let foundAssistant = assistants.find(item => item.guid === guid);

            if (!foundAssistant) {
                console.error("No assistant found with the specified GUID.");
                return;
            }

            console.log('🔄 Switching assistant to:', foundAssistant.name);

            // 1. Guardar asistente anterior
            assistant = foundAssistant;

            // 2. Activar chip para volver al original (si aplica)
            activateAssistantChip();

            // 3. Cargar configuración completa del nuevo asistente
            try {
                const assistantData = await loadAssistantData(guid);

                if (assistantData) {
                    // Actualizar chat con la configuración del nuevo asistente
                    chat.mainAssistant = assistantData.mainAssistant;
                    chat.tools = assistantData.tools || [];
                    chat.tools_setup = assistantData.tools_setup || {};
                    chat.activeTools = assistantData.tools || [];
                    initializeProxyTool(chat,assistant).catch(error => {
                        console.error('Error initializing proxy tool:', error);
                    });
                    chat.instructions = assistantData.instructions || [];
                    chat.noSelectionInstructions = (assistantData.instructions || []).filter(
                        instruction => !instruction.isSelection
                    );

                    // Actualizar información del asistente en la UI
                    assistant.name = assistantData.mainAssistant.name;
                    assistant.avatar = window.config.domain + assistantData.mainAssistant._myMedias.avatars[0].realPath;
                    assistant.mainImage = window.config.domain + assistantData.mainAssistant._myMedias.mainImage[0].realPath;
                    assistant.greeting = assistantData.mainAssistant.greeting;
                    assistant.placeholder = assistantData.mainAssistant.placeholder;
                    assistant.thinkIcon = assistantData.mainAssistant.thinkIcon || '🤔';

                    // Actualizar system prompt AGREGANDO el del nuevo asistente (no reemplazando)
                    if (assistantData.mainAssistant.system) {
                        const currentSystem = messageManager.messagesHistory[0]?.content || '';

                        // Si ya hay historial, agregar contexto del nuevo asistente
                        if (messageManager.getHistory().length > 1) {
                            const additionalContext = `\n\n--- ASSISTANT SWITCH ---\nYou are now ${assistantData.mainAssistant.name}. ${assistantData.mainAssistant.system}\nPlease continue the conversation maintaining context of previous messages.`;
                            messageManager.updateSystemMessage(currentSystem + additionalContext);
                        } else {
                            // Si no hay historial, usar el system prompt del nuevo asistente
                            messageManager.updateSystemMessage(assistantData.mainAssistant.system);
                        }
                    }

                    // Reinicializar tool manager con la nueva configuración
                    toolManager = new window.SIMBA.ToolManager(chat, configManager.getConfig());
                    initializeActiveTools();
                    updateChatTools();

                    // Actualizar dropzone según capacidades del nuevo asistente
                    updateDropzoneState();

                    console.log('✅ Assistant switched successfully, conversation maintained');
                }
            } catch (error) {
                console.error('Error loading assistant data:', error);
                $f7.toast.show({
                    text: 'Error switching assistant',
                    cssClass: 'color-red'
                });
                return;
            }

            // 4. Actualizar UI
            updateTemplate();
            textAreaFocus();

            // 5. Mostrar confirmación
            $f7.toast.show({
                text: `Switched to ${foundAssistant.name}`,
                position: 'center',
                closeTimeout: 2000,
                cssClass: 'color-blue'
            });
        };
        /**
         * Calls a tool using the tool manager
         */
        let callTool = async function (name, params) {
            console.log(`Calling tool: ${name} with params:`, params);
            if (params.title) {
                // Actualizar t�tulo local
                chat.title = params.title;

                // Actualizar en ConversationManager
                if (conversationManager && conversationManager.currentConversationId) {
                    conversationManager.updateConversationTitle(conversationManager.currentConversationId, chat.title)
                        .then(() => {
                            updateTemplate();
                        })
                        .catch(error => {
                            console.error('Error updating conversation title:', error);
                            updateTemplate();
                        });
                } else {
                    updateTemplate();
                }
            }
            if (!toolManager) {
                console.error('Tool manager not initialized');
                return Promise.reject(new Error('Tool manager not initialized'));
            }

            const toolSetup = chat.tools_setup?.[name] || {};
            const inProgressMessage = toolSetup.in_progress_message || 'Calling tool';
            const toolIcon = toolSetup.icon || "fa-database";
            const humanReadableMessage = `<p><div class="call-execution shimmer-text-fast"><i class="fa ${toolIcon} margin-right-half"></i>${inProgressMessage} <strong>${params.text || ''}</strong></div></p>`;

            $el.value.find('.message:last-child .message-text').html(humanReadableMessage);

            if (toolSetup.ask_for_execution && name === "action_open_support_ticket") {
                ticket = params;
                updateTemplate();
                openPopupTicket();
                return Promise.resolve({status: 'awaiting_user_confirmation'});
            }
            if (toolSetup.ask_for_execution && name === 'action_simba_agent_switcher') {
                const agentGuid = params.guid;
                const userPrompt = params.user_prompt || '';

                // Buscar el agente para obtener su informaci�n
                const targetAgent = assistants.find(a => a.guid === agentGuid);

                // CAMBIO: Usar el nombre del agente encontrado, no params.name
                const agentName = targetAgent ? targetAgent.name : (params.name || 'this agent');
                const agentAvatar = targetAgent ? targetAgent.avatar : '';

                // Crear di�logo personalizado con Framework7
                const dialog = $f7.dialog.create({
                    title: 'Switch Assistant',
                    content: `
            <div style="text-align: center; padding: 20px;">
                ${agentAvatar ? `<img src="${agentAvatar}" style="width: 80px; height: 80px; border-radius: 50%; margin-bottom: 15px; " />` : ''}
                <p style="font-size: 16px; margin-bottom: 10px;">
                    Your question can be better answered by <strong>${agentName}</strong>.
                </p>
                <p style="font-size: 14px; color: #666;">
                    Do you want to switch to this assistant?
                </p>
                ${userPrompt ? `
                    <div style="padding: 10px; border-radius: 5px; margin-top: 15px; text-align: left;">
                        <small style="color: #999;">Your question:</small>
                        <p style="margin: 5px 0 0 0; font-size: 13px;">"${userPrompt}"</p>
                    </div>
                ` : ''}
            </div>
        `,
                    buttons: [
                        {
                            text: 'Cancel',
                            onClick: () => {
                                $f7.toast.create({
                                    text: 'Switch canceled',
                                    closeTimeout: 2000,
                                    cssClass: 'color-orange'
                                }).open();
                            }
                        },
                        {
                            text: 'Switch',
                            bold: true,
                            onClick: () => {
                                // Cambiar al nuevo asistente
                                switchAssistant(agentGuid);

                                // Si hay prompt del usuario, ponerlo en el textarea
                                if (userPrompt) {
                                    const textarea = document.getElementById('prompt');
                                    if (textarea) {
                                        textarea.value = userPrompt;
                                        prompt = userPrompt;

                                        updateTemplate();

                                        setTimeout(() => {
                                            textarea.focus();
                                            textarea.setSelectionRange(userPrompt.length, userPrompt.length);
                                        }, 100);
                                    }
                                }

                                $f7.toast.create({
                                    text: `Switched to ${agentName}`,
                                    closeTimeout: 2000,
                                    cssClass: 'color-green'
                                }).open();
                            }
                        }
                    ],
                    verticalButtons: false
                });

                dialog.open();

                return Promise.resolve({
                    status: 'awaiting_user_confirmation',
                    agent: agentName,
                    userPrompt: userPrompt
                });
            }


            if (toolSetup.ask_for_execution && name === "action_vision_request") {
                // Extraer par�metros
                const imageName = params.image_name;
                const visionPrompt = params.prompt || params.text || "Describe detalladamente la siguiente imagen";

                console.log("Vision request for image:", imageName, "with prompt:", visionPrompt);

                // Buscar la imagen en sentImages
                if (loadedImages[imageName]) {
                    const imageData = loadedImages[imageName];
                    // Mostrar indicador de procesamiento
                    const humanReadableMessage = `<p><div class="call-execution shimmer-text-fast"><i class="fa fa-eye margin-right-half"></i>Analyzing image</div></p>`;
                    $el.value.find('.message:last-child .message-text').html(humanReadableMessage);
                    // Llamar a la funci�n de an�lisis de imagen del FileDropzone
                    if (window.myFileDropzone) {
                        return window.myFileDropzone._analyzeImageWithVision(imageData.file, visionPrompt, false)
                            .then(function(analysisResult) {
                                console.log("Vision re-analysis completed:", analysisResult);
                                // Actualizar en sentImages
                                loadedImages[imageName].extractedText = analysisResult;
                                loadedImages[imageName].lastAnalysis = {
                                    prompt: visionPrompt,
                                    result: analysisResult,
                                    timestamp: Date.now()
                                };

                                // Quitar indicador de procesamiento
                                $(".shimmer-text-fast").removeClass("shimmer-text-fast");

                                // NUEVO: Crear el contenido con formato simba_image
                                const visionAnalysisContent = `<simba_image data-filename="${imageName}">\n${analysisResult}\n</simba_image>`;

                                // NUEVO: Agregar como mensaje de usuario al historial
                                messageManager.addMessage('user', visionAnalysisContent);

                                // NUEVO: Crear un nuevo mensaje del asistente para la respuesta final
                                const finalResponseMsgId = window.SIMBA.Utils.generateUniqueId("assistant-vision-response");

                                messages.addMessage({
                                    attrs: {"data-id": finalResponseMsgId, "id": finalResponseMsgId},
                                    isTitle: false,
                                    text: '<p><span class="thinking-icon">' + (assistant?.thinkIcon || '??') + '</span></p>',
                                    name: assistant.name,
                                    cssClass: 'card no-margin-top padding-half',
                                    textFooter: footerTemplate,
                                    avatar: assistant.avatar,
                                    type: 'received',
                                }, 'append', true);

                                onMessageAdded($('#' + finalResponseMsgId));

                                // NUEVO: Llamar a callCompletion para que el LLM genere una respuesta final
                                return callCompletion(false, finalResponseMsgId)
                                    .then(() => {
                                        console.log("LLM response generated after vision analysis");

                                        return {
                                            status: 'completed',
                                            result: analysisResult,
                                            imageName: imageName,
                                            prompt: visionPrompt,
                                            llmResponseGenerated: true
                                        };
                                    })
                                    .catch(error => {
                                        console.error("Error generating LLM response:", error);

                                        // En caso de error, mostrar al menos el an�lisis de visi�n
                                        const fallbackMessage = `<p><strong>An�lisis de imagen completado:</strong></p><p><em>Imagen:</em> ${imageName}</p><p><em>Prompt:</em> ${visionPrompt}</p><hr><p>${analysisResult}</p><p><em>Error generando respuesta adicional: ${error.message}</em></p>`;
                                        $('#' + finalResponseMsgId).find('.message-text').html(fallbackMessage);

                                        return {
                                            status: 'completed_with_errors',
                                            result: analysisResult,
                                            imageName: imageName,
                                            prompt: visionPrompt,
                                            error: error.message
                                        };
                                    });
                            })
                            .catch(function(error) {
                                console.error("Error in vision re-analysis:", error);

                                $(".shimmer-text-fast").removeClass("shimmer-text-fast");
                                const errorMessage = `<p><strong>Error analizando imagen:</strong> ${error.message}</p>`;
                                $el.value.find('.message:last-child .message-text').html(errorMessage);

                                return {
                                    status: 'error',
                                    error: error.message,
                                    imageName: imageName
                                };
                            });
                    } else {
                        console.error("FileDropzone not available");
                        return Promise.resolve({
                            status: 'error',
                            error: 'FileDropzone no disponible'
                        });
                    }
                } else {
                    console.error("Image not found:", imageName);
                    const errorMessage = `Imagen "${imageName}" no encontrada en las im�genes cargadas`;
                    $el.value.find('.message:last-child .message-text').html(errorMessage);

                    return Promise.resolve({
                        status: 'error',
                        error: 'Imagen no encontrada'
                    });
                }
            }

            if (toolSetup.ask_for_execution && name === "action_confluence_context") {
                const searchTerm = params.term || params.text || '';

                // Limpiar sources temporales anteriores
                sourceManager.setTempSources([]);

                // Mostrar indicador de búsqueda
                const humanReadableMessage = `<p><div class="call-execution shimmer-text-fast"><i class="fa-brands fa-confluence margin-right-half"></i>Searching in Confluence: <strong>${searchTerm}</strong></div></p>`;
                $el.value.find('.message:last-child .message-text').html(humanReadableMessage);

                // Inicializar ContextManager si no existe
                if (!window.contextManager) {
                    window.contextManager = new SIMBA.ContextManager({
                        baseUrl: 'http://localhost:8000',   // 🔹 ahora claro que es el proxy
                        serviceName: 'confluence1',          // 🔹 servicio por defecto
                        defaultLimit: 5,

                        // Estos ahora son más “contracto” con el backend, pero los seguimos respetando
                        processAttachments: true,
                        maxPagesPerDocument: 50,
                        useSimbaDocumentTags: true,
                        viewerStrategy: {
                            pages: 'new_tab',
                            attachments: 'iframe',
                            pdfs: 'iframe',
                            pdf: 'iframe',
                            docx: 'iframe',
                            doc: 'iframe',
                            default: 'new_tab'
                        }
                    });

                }

                // Llamar a la función de búsqueda
                return window.contextManager.search(searchTerm)
                    .then(sourcesData => {
                        console.log("Confluence search completed:", sourcesData);

                        // ✅ Actualizar sources temporales
                        sourceManager.setTempSources(sourcesData);

                        if (sourcesData.length > 0 && sourcesData.some(source => source.text || source.references)) {
                            // ✅ Construir prompt con las sources
                            const simbaPrompt = sourceManager.buildSimbaPrompt(sourcesData);

                            // ✅ Actualizar system message con el contexto
                            messageManager.updateSystemMessage(
                                messageManager.getHistory()[0].content +
                                '\n\n\n\nPLEASE USE THIS RETRIEVED CONFLUENCE CONTEXT FOR ANSWERING:\n\n' +
                                simbaPrompt
                            );

                            // Quitar indicador de procesamiento
                            $(".shimmer-text-fast").removeClass("shimmer-text-fast");

                            // ✅ Mostrar stats si hay attachments procesados
                            const stats = window.contextManager.getLastStats();
                            if (stats.totalProcessed > 0) {
                                $f7.toast.show({
                                    text: `📄 Processed ${stats.totalProcessed} documents (${stats.totalPages} pages, ${Math.round(stats.totalChars / 1000)}K chars)`,
                                    position: 'center',
                                    closeTimeout: 3000,
                                    cssClass: 'color-blue'
                                });
                            }

                            // Crear mensaje del asistente
                            const finalResponseMsgId = window.SIMBA.Utils.generateUniqueId("assistant-confluence-response");

                            messages.addMessage({
                                attrs: {"data-id": finalResponseMsgId, "id": finalResponseMsgId},
                                isTitle: false,
                                text: '<p><span class="thinking-icon">' + (assistant?.thinkIcon || '🤔') + '</span></p>',
                                name: assistant.name,
                                cssClass: 'card no-margin-top padding-half',
                                textFooter: footerTemplate,
                                avatar: assistant.avatar,
                                type: 'received',
                            }, 'append', true);

                            onMessageAdded($('#' + finalResponseMsgId));

                            // Llamar a completion
                            return callCompletion(false, finalResponseMsgId)
                                .then(() => {
                                    console.log("LLM response generated after Confluence search");
                                    saveSourcesForMessage(finalResponseMsgId);
                                    addSourcesToMessage($('#' + finalResponseMsgId));
                                    addActionsToMessage($('#' + finalResponseMsgId));

                                    return {
                                        status: 'completed',
                                        sourcesCount: sourcesData.length,
                                        searchTerm: searchTerm,
                                        stats: stats,
                                        llmResponseGenerated: true
                                    };
                                })
                                .catch(error => {
                                    console.error("Error generating LLM response:", error);

                                    const fallbackMessage = `<p><strong>Confluence search completed:</strong></p>
                            <p><em>Search term:</em> ${searchTerm}</p>
                            <p><em>Found ${sourcesData.length} results</em></p>
                            <hr>
                            <p><em>Error generating response: ${error.message}</em></p>`;
                                    $('#' + finalResponseMsgId).find('.message-text').html(fallbackMessage);

                                    return {
                                        status: 'completed_with_errors',
                                        sourcesCount: sourcesData.length,
                                        searchTerm: searchTerm,
                                        error: error.message
                                    };
                                });

                        } else {
                            // No se encontraron sources
                            $(".shimmer-text-fast").removeClass("shimmer-text-fast");

                            const noResultsMessage = `<p><strong>No results found in Confluence for:</strong> "${searchTerm}"</p>`;
                            $el.value.find('.message:last-child .message-text').html(noResultsMessage);

                            return {
                                status: 'completed',
                                sourcesCount: 0,
                                searchTerm: searchTerm,
                                message: 'No results found'
                            };
                        }
                    })
                    .catch(error => {
                        console.error("Error searching in Confluence:", error);

                        $(".shimmer-text-fast").removeClass("shimmer-text-fast");

                        const errorMessage = `<p><strong>Error searching in Confluence:</strong> ${error.message}</p>`;
                        $el.value.find('.message:last-child .message-text').html(errorMessage);

                        return {
                            status: 'error',
                            error: error.message
                        };
                    });
            }
            if (name === "retrieve_data_from_corporate_services") {
                const searchTerm = params.term || '';
                const servicesParam = params.services || '';

                if (!searchTerm) {
                    return Promise.reject(new Error('Search term is required'));
                }

                if (!window.proxyInfo || !window.proxyInfo.baseUrl) {
                    return Promise.reject(new Error('Proxy not available'));
                }

                console.log(`🔍 Retrieving data: "${searchTerm}" from services: ${servicesParam}`);

                // Limpiar sources temporales anteriores
                sourceManager.setTempSources([]);

                // Mostrar indicador de búsqueda
                const servicesDisplay = servicesParam.split(',').map(s => s.trim()).join(', ');
                const humanReadableMessage = `<p><div class="call-execution shimmer-text-fast"><i class="fa fa-database margin-right-half"></i>Searching in ${servicesDisplay}: <strong>${searchTerm}</strong></div></p>`;
                $el.value.find('.message:last-child .message-text').html(humanReadableMessage);

                // Construir la URL de búsqueda
                const queryParams = new URLSearchParams({
                    q: searchTerm,
                    services: servicesParam,
                    limit: '3',
                    include: 'content',
                    normalize: 'simba_v1'
                });

                const searchUrl = `${window.proxyInfo.baseUrl}/_search?${queryParams.toString()}`;

                console.log('🌐 Search URL:', searchUrl);

                // Ejecutar búsqueda
                return fetch(searchUrl, {
                    method: 'GET',
                    headers: { 'Accept': 'application/json' }
                })
                    .then(response => {
                        if (!response.ok) {
                            throw new Error(`Search failed: ${response.status} ${response.statusText}`);
                        }
                        return response.json();
                    })
                    .then(data => {
                        const results = data.results || [];
                        const stats = data.stats || {};

                        console.log(`✅ Found ${results.length} results`);
                        console.log('📊 Stats:', stats);

                        // Convertir resultados al formato sourcesData
                        const sourcesData = results.map(result => ({
                            id: result.id || result.name,
                            name: result.name || result.id || 'Untitled',
                            guid: result.guid || `${result.site}_${result.id}`,
                            icon: result.icon || 'fa-file',
                            text: result.text || '',
                            references: result.references || null,
                            url: result.url || '',
                            source: result.source || '',
                            summary: result.summary || '',
                            site: result.site || 'Corporate',
                            device: result.device || 'N/A',
                            extra: result.extra || {}
                        }));

                        console.log('📋 Sources data prepared:', sourcesData.length, 'items');

                        // ✅ Actualizar sources temporales
                        sourceManager.setTempSources(sourcesData);

                        if (sourcesData.length > 0 && sourcesData.some(source => source.text || source.references)) {
                            // ✅ Construir prompt con las sources
                            const simbaPrompt = sourceManager.buildSimbaPrompt(sourcesData);

                            console.log('📝 SIMBA prompt built, length:', simbaPrompt.length);

                            // ✅ Actualizar system message con el contexto
                            messageManager.updateSystemMessage(
                                messageManager.getHistory()[0].content +
                                '\n\n\n\nPLEASE USE THIS RETRIEVED CORPORATE DATA FOR ANSWERING:\n\n' +
                                simbaPrompt
                            );

                            // Quitar indicador de procesamiento
                            $(".shimmer-text-fast").removeClass("shimmer-text-fast");

                            // ✅ Mostrar stats
                            const servicesProcessed = Object.keys(stats.services || {}).join(', ');
                            if (servicesProcessed) {
                                $f7.toast.show({
                                    text: `📋 Found ${results.length} results from ${servicesProcessed}`,
                                    position: 'center',
                                    closeTimeout: 3000,
                                    cssClass: 'color-blue'
                                });
                            }

                            // Crear mensaje del asistente
                            const finalResponseMsgId = window.SIMBA.Utils.generateUniqueId("assistant-corporate-response");

                            console.log('💬 Creating assistant message with id:', finalResponseMsgId);

                            messages.addMessage({
                                attrs: {"data-id": finalResponseMsgId, "id": finalResponseMsgId},
                                isTitle: false,
                                text: '<p><span class="thinking-icon">' + (assistant?.thinkIcon || '🤔') + '</span></p>',
                                name: assistant.name,
                                cssClass: 'card no-margin-top padding-half',
                                textFooter: footerTemplate,
                                avatar: assistant.avatar,
                                type: 'received',
                            }, 'append', true);

                            onMessageAdded($('#' + finalResponseMsgId));

                            // ✅ Llamar a completion para generar la respuesta del LLM
                            console.log('🤖 Calling LLM completion with corporate data context...');

                            return callCompletion(false, finalResponseMsgId)
                                .then(() => {
                                    console.log("✅ LLM response generated after corporate data retrieval");

                                    // ✅ Guardar sources para el mensaje
                                    saveSourcesForMessage(finalResponseMsgId);

                                    // ✅ Agregar sources visuales al mensaje
                                    addSourcesToMessage($('#' + finalResponseMsgId));

                                    // ✅ Agregar acciones al mensaje
                                    addActionsToMessage($('#' + finalResponseMsgId));

                                    return {
                                        status: 'completed',
                                        sourcesCount: sourcesData.length,
                                        searchTerm: searchTerm,
                                        services: servicesParam,
                                        stats: stats
                                    };
                                })
                                .catch(error => {
                                    console.error("❌ Error generating LLM response:", error);
                                    $('#' + finalResponseMsgId).find('.message-text').html(
                                        `<p>Error generating response: ${error.message}</p>`
                                    );
                                    return Promise.reject(error);
                                });
                        } else {
                            // No hay resultados con contenido útil
                            $(".shimmer-text-fast").removeClass("shimmer-text-fast");

                            const noResultsMsg = `No relevant results found for "${searchTerm}" in ${servicesDisplay}`;
                            console.log('⚠️', noResultsMsg);
                            $el.value.find('.message:last-child .message-text').html(`<p>${noResultsMsg}</p>`);

                            return {
                                status: 'no_results',
                                searchTerm: searchTerm,
                                services: servicesParam
                            };
                        }
                    })
                    .catch(error => {
                        console.error('❌ Error retrieving data:', error);
                        $(".shimmer-text-fast").removeClass("shimmer-text-fast");
                        $el.value.find('.message:last-child .message-text').html(
                            `<p>Error: ${error.message}</p>`
                        );
                        return Promise.reject(error);
                    });
            }

            sourceManager.setTempSources([]);

            return toolManager.callTool(name, params, myDevice)
                .then(toolResponse => {
                    console.log("Tool call completed successfully:", toolResponse);

                    if (toolResponse.data?.data?.tool_domain === 'action') {
                        console.log("Action tool processed", toolResponse.data);
                        return toolResponse;
                    }

                    if (toolResponse.data?.data?.sources) {
                        const sourcesData = toolResponse.data.data.sources;
                        sourceManager.setTempSources(sourcesData);

                        if (sourcesData.some(source => source.text)) {
                            const simbaPrompt = sourceManager.buildSimbaPrompt(sourcesData);
                            messageManager.updateSystemMessage(
                                messageManager.getHistory()[0].content +
                                '\n\n\n\nPLEASE USE THIS RETRIEVED CONTEXT FOR ANSWERING:\n\n' +
                                simbaPrompt
                            );

                            $(".shimmer-text-fast").removeClass("shimmer-text-fast");
                            return {...toolResponse, sourcesAdded: true};
                        } else {
                            return handleNoSourcesFound();
                        }
                    } else {
                        return handleUnexpectedResponse(toolResponse);
                    }
                })
                .catch(error => {
                    console.error("Tool call failed:", error);
                    return handleToolError(error);
                });
        };

        /**
         * Handles the case when no sources are found
         */
        let handleNoSourcesFound = function () {
            console.log("No relevant sources found");
            const noInfoMsgId = window.SIMBA.Utils.generateUniqueId("assistant-no-info");

            messages.addMessage({
                attrs: {"data-id": noInfoMsgId, "id": noInfoMsgId},
                isTitle: false,
                text: '<p>Sorry, no records were found. Please rephrase your question.</p>',
                name: assistant.name,
                cssClass: 'card no-margin-top padding-half',
                textFooter: footerTemplate,
                avatar: assistant.avatar,
                type: 'received',
            }, 'append', true);

            onMessageAdded($('#' + noInfoMsgId));
            saveSourcesForMessage(noInfoMsgId);

            messageManager.addMessage('assistant', "Sorry, no records were found. Please rephrase your question.", null, noInfoMsgId);
            saveMessageToConversation('assistant', "Sorry, no records were found. Please rephrase your question.", noInfoMsgId);
            return callCompletion(false, noInfoMsgId)
                .then(() => ({sourcesAdded: false, messageId: noInfoMsgId}));
        };

        /**
         * Handles unexpected tool responses
         */
        let handleUnexpectedResponse = function (response) {
            console.log("Unexpected response structure");
            const structureErrorMsgId = window.SIMBA.Utils.generateUniqueId("assistant-structure-error");

            messages.addMessage({
                attrs: {"data-id": structureErrorMsgId, "id": structureErrorMsgId},
                isTitle: false,
                text: '<p>Processing your query...</p>',
                name: assistant.name,
                cssClass: 'card no-margin-top padding-half',
                textFooter: footerTemplate,
                avatar: assistant.avatar,
                type: 'received',
            }, 'append', true);

            onMessageAdded($('#' + structureErrorMsgId));
            saveSourcesForMessage(structureErrorMsgId);

            const lastUserQuestion = getLastUserQuestion();
            messageManager.addMessage('user',
                `Regarding my question: "${lastUserQuestion}", there was a problem trying to find additional information. Please respond based on your general knowledge and mention any limitations in your response.`
            );

            return callCompletion(false, structureErrorMsgId)
                .then(() => ({sourcesAdded: true, messageId: structureErrorMsgId}));
        };

        /**
         * Handles tool execution errors
         */
        let handleToolError = function (error) {
            console.error("Tool execution error:", error);
            const apiErrorMsgId = window.SIMBA.Utils.generateUniqueId("assistant-api-error");

            messages.addMessage({
                attrs: {"data-id": apiErrorMsgId, "id": apiErrorMsgId},
                isTitle: false,
                text: '<p>Processing your query...</p>',
                name: assistant.name,
                cssClass: 'card no-margin-top padding-half',
                textFooter: footerTemplate,
                avatar: assistant.avatar,
                type: 'received',
            }, 'append', true);

            onMessageAdded($('#' + apiErrorMsgId));
            saveSourcesForMessage(apiErrorMsgId);

            const lastUserQuestion = getLastUserQuestion();
            messageManager.addMessage('user',
                `Regarding my question: "${lastUserQuestion}", there was an error trying to connect to the information source. Please respond based on your general knowledge and mention any limitations in your response.`
            );

            return callCompletion(false, apiErrorMsgId)
                .then(() => ({sourcesAdded: true, messageId: apiErrorMsgId}));
        };

        /**
         * Gets the last user question from message history
         */
        let getLastUserQuestion = function () {
            const history = messageManager.getHistory();
            for (let i = history.length - 1; i >= 0; i--) {
                if (history[i].role === 'user') {
                    return history[i].content;
                }
            }
            return "";
        };

        /**
         * Saves sources for a specific message
         */
        let saveSourcesForMessage = function (messageId, params = {}) {
            const tempSources = sourceManager.getTempSources();
            if (tempSources.length > 0) {
                sourceManager.saveToStorage(messageId, tempSources, params);
                console.log('Sources saved for message:', messageId);
            }
        };
        let makeClickableReferences = function () {
            // Primero agrupamos las referencias consecutivas
            groupConsecutiveReferences();

            $(".reference").each(function () {
                $(this).off('click');
                $(this).on("click", function (e) {
                    openPopoverText(e);
                });

                const $parentLi = $(this).closest('li');
                if ($parentLi.length) {
                    $parentLi.css('list-style-type', 'none');
                }
            });
        }
        let makeClickableSuggestions = function () {
            $(".simba-suggestion").each(function () {
                $(this).off('click'); // Remover listeners anteriores
                $(this).on("click", function (e) {
                    e.preventDefault();
                    e.stopPropagation();

                    const suggestionText = $(this).attr('data-content');
                    const suggestionId = $(this).attr('data-id');

                    console.log('Suggestion clicked:', suggestionId, suggestionText);

                    // Poner el texto en el textarea
                    const textarea = document.getElementById('prompt');
                    if (textarea) {
                        textarea.value = suggestionText;
                        prompt = suggestionText;

                        // Actualizar template
                        updateTemplate();

                        // Hacer focus y enviar autom�ticamente
                        setTimeout(() => {
                            textarea.focus();

                            // Opcional: enviar autom�ticamente
                            sendPrompt();

                            // O simplemente posicionar el cursor al final para que el usuario revise
                            //textarea.setSelectionRange(suggestionText.length, suggestionText.length);
                        }, 100);
                    }

                    // Toast de confirmaci�n
                    if ($f7) {
                        $f7.toast.show({
                            text: 'Suggestion loaded. Click send to submit.',
                            position: 'center',
                            closeTimeout: 2000,
                            cssClass: 'color-blue'
                        });
                    }
                });
            });
        };

// Variable global para manejar el grupo actual
        let currentReferenceGroup = null;
        let currentReferenceIndex = 0;

        function groupConsecutiveReferences() {
            const referenceGroups = [];
            let currentGroup = [];

            $(".reference").each(function (index) {
                const $current = $(this);
                const $next = $current.next('.reference');

                // Si es la primera referencia o la anterior no era una referencia, inicia nuevo grupo
                if (currentGroup.length === 0) {
                    currentGroup.push($current);
                } else {
                    currentGroup.push($current);
                }

                // Si no hay siguiente referencia o la siguiente no es consecutiva, cierra el grupo
                if ($next.length === 0 || $current.next()[0] !== $next[0]) {
                    if (currentGroup.length > 1) {
                        referenceGroups.push([...currentGroup]);
                        processReferenceGroup(currentGroup);
                    }
                    currentGroup = [];
                }
            });
        }

        function processReferenceGroup(group) {
            // Ocultar todas las referencias del grupo excepto la primera
            for (let i = 1; i < group.length; i++) {
                group[i].hide();
            }

            // A�adir indicador de grupo a la primera referencia
            const $firstRef = group[0];
            $firstRef.addClass('reference-group-main');
            $firstRef.attr('data-group-size', group.length);

            // Modificar el texto para mostrar el n�mero anexado
            const $spans = $firstRef.find('span');
            let originalText, $targetElement;

            if ($spans.length > 0) {
                $targetElement = $spans.last();
                originalText = $targetElement.text();
            } else {
                $targetElement = $firstRef;
                originalText = $firstRef.text();
            }

            const cleanText = originalText.replace(/\s*\+\d+$/, ''); // Remover +n�mero si ya existe
            const newText = `${cleanText} +${group.length}`;

            // Guardar el texto original para poder restaurarlo
            $firstRef.attr('data-original-text', cleanText);

            // Actualizar el texto mostrado
            $targetElement.text(newText);

            // Guardar todas las referencias del grupo en data
            $firstRef.data('referenceGroup', group);
        }

// 1. MANTENER openPopoverText ORIGINAL (sin cambios)
        let openPopoverText = function (event) {
            const targetElement = event.target;
            const $target = $(targetElement);

            // Verificar si es parte de un grupo
            const referenceGroup = $target.data('referenceGroup');

            if (referenceGroup && referenceGroup.length > 1) {
                currentReferenceGroup = referenceGroup;
                currentReferenceIndex = 0;
                openPopoverForGroupedReference();
            } else {
                openPopoverForSingleReference(targetElement);
            }
        };

        function openPopoverForSingleReference(targetElement) {
            const guid = $(targetElement).attr('data-guid');
            const messageElement = $(targetElement).closest('.message');
            const messageId = messageElement.attr('id');

            const page = parseInt($(targetElement).attr('data-page'), 10) || undefined;
            const section = parseInt($(targetElement).attr('data-section'), 10) || undefined;
            const name = $(targetElement).attr('data-filename') || 'Reference not found';
            const content = $(targetElement).attr('data-content') || 'Could not find reference information.';

            const sources = JSON.parse(localStorage.getItem('sources') || '{}');
            const result = getObjectAndTextByGuid(sources, guid, page, section);

            if (!result) {
                myReference = {
                    name,
                    guid:guid,
                    page: page || "",
                    section: section || "",
                    content: "..." + content + "...",
                    searchText: content,
                    fileName: name
                };
            } else {
                // ✅ HACER DEFENSIVO: Verificar que source existe
                const sourceUrl = result.sourceObject.source || result.sourceObject.url || '';
                const finalSource = (sourceUrl && (sourceUrl.startsWith('http://') || sourceUrl.startsWith('https://')))
                    ? sourceUrl
                    : (sourceUrl ? 'https://itc.simeng.es/' + sourceUrl : '#');

                myReference = {
                    guid: result.sourceObject.guid || "No guid",
                    name: result.sourceObject.id || result.sourceObject.name || "No name",
                    page: page || (result.sourceObject.extra && result.sourceObject.extra.page) || "",
                    section: section || (result.sourceObject.extra && result.sourceObject.extra.section) || "",
                    content: result.extractedText || "No content",
                    source: finalSource,
                    searchText: content,
                    fileName: result.sourceObject.id || result.sourceObject.name || "No name",
                };
            }

            popoverText.open(targetElement);
            updateTemplate();
            bindPopoverEvents(messageId, guid);
        }

// 2. openPopoverForGroupedReference - SIN isDropzoneFile
        function openPopoverForGroupedReference() {
            const currentRef = currentReferenceGroup[currentReferenceIndex];
            const targetElement = currentRef[0];

            const guid = currentRef.attr('data-guid');
            const messageElement = currentRef.closest('.message');
            const messageId = messageElement.attr('id');

            const page = parseInt(currentRef.attr('data-page'), 10) || undefined;
            const section = parseInt(currentRef.attr('data-section'), 10) || undefined;
            const name = currentRef.attr('data-filename') || 'Reference not found';
            const content = currentRef.attr('data-content') || 'Could not find reference information.';

            const sources = JSON.parse(localStorage.getItem('sources') || '{}');
            const result = getObjectAndTextByGuid(sources, guid, page, section);

            if (!result) {
                myReference = {
                    name,
                    guid:guid,
                    page: page || "",
                    section: section || "",
                    content: "..." + content + "...",
                    searchText: content,
                    fileName: name
                };
            } else {
                const sourceUrl = result.sourceObject.source;
                const finalSource = (sourceUrl.startsWith('http://') || sourceUrl.startsWith('https://'))
                    ? sourceUrl
                    : 'https://itc.simeng.es/' + sourceUrl;

                myReference = {
                    guid:result.sourceObject.guid || "No guid",
                    name: result.sourceObject.id || result.sourceObject.name || "No name",
                    page: page || (result.sourceObject.extra && result.sourceObject.extra.page) || "",
                    section: section || (result.sourceObject.extra && result.sourceObject.extra.section) || "",
                    content: result.extractedText || "No content",
                    source: finalSource + '#phrase=true&page=' + page + '&search=' + result.extractedText,
                    searchText: content,
                    fileName: result.sourceObject.id || result.sourceObject.name || "No name",
                };
            }

            popoverText.open(targetElement);
            updateTemplate();
            bindPopoverEvents(messageId, guid);
        }

// 3. bindPopoverEvents - SIMPLIFICADO, solo chequea loadedFiles
        function bindPopoverEvents(messageId, guid) {
            $update(function () {
                $("#view-source").on('click', function () {
                    openSourcePanel(messageId);
                    $(".source").parent().removeClass('bg-color-chrome');
                    $(".source[id='" + guid + "']").parent().addClass('bg-color-chrome');
                });
                $("#view-document").off('click');
                $("#view-document").off('click');
                $("#view-document").on('click', function () {
                    const fileName = myReference.fileName;
                    const fileData = loadedFiles[fileName];

                    if (fileData) {
                        const fileExtension = fileName.split('.').pop().toLowerCase();

                        const searchQuery = myReference.searchText || myReference.content;
                        const pageNumber = myReference.page ? parseInt(myReference.page) : 1;

                        if (fileExtension === 'pdf' || fileData.fileType === 'pdf') {
                            // 📄 ABRIR PDF
                            console.log('📄 Opening PDF from loadedFiles:', {
                                fileName,
                                searchQuery,
                                pageNumber,
                                hasFile: !!fileData.file
                            });

                            if (window.myFileDropzone) {
                                window.myFileDropzone.showPdfInSplitViewFromFile(
                                    fileData.file,
                                    fileName,
                                    searchQuery,
                                    pageNumber
                                );
                            }

                            popoverText.close();
                            return;
                        }

                        if (fileExtension === 'docx' || fileExtension === 'doc') {
                            // 📝 ABRIR WORD
                            if (window.myFileDropzone) {
                                window.myFileDropzone.showWordInSplitViewFromFile(fileData.file, fileName, searchQuery, pageNumber);
                            }
                            popoverText.close();
                            return;
                        }

                        if (fileExtension === 'pptx' || fileExtension === 'ppt') {
                            // 📊 ABRIR POWERPOINT
                            if (window.myFileDropzone) {
                                window.myFileDropzone.showPowerPointInSplitViewFromFile(fileData.file, fileName, searchQuery, pageNumber);
                            }
                            popoverText.close();
                            return;
                        }

                        // Tipo no soportado
                        $f7.toast.show({
                            text: 'Preview not available for this file type',
                            position: 'center',
                            closeTimeout: 3000,
                            cssClass: 'color-orange'
                        });

                    } else {
                        console.log('🌐 Opening external source:', myReference.source);

                        let sourceUrl = myReference.source || '';
                        const urlLower = sourceUrl.toLowerCase();

                        if (sourceUrl.includes(' ')) {
                            sourceUrl = sourceUrl.replace(/ /g, '%20');
                        }

                        const searchQuery = myReference.searchText || myReference.content || '';
                        const pageNumber = myReference.page ? parseInt(myReference.page) : 1;
                        const displayName = myReference.fileName || myReference.name || 'Document';
                        const guid = myReference.guid || 'No guid';

                        // ✅ OBTENER ESTRATEGIA DE VISUALIZACIÓN
                        // Buscar la fuente en sourceManager para obtener metadata
                        const sources = JSON.parse(localStorage.getItem('sources') || '{}');
                       // const messageId = $(this).closest('.message').attr('id');
                        const sourceData = sources[guid] || [];
                       // const sourceData = messageSources.find(s => s.guid === displayName || s.id === displayName);
                        console.log(displayName, sourceData)
                        const viewerStrategy = sourceData?.extra?.viewerStrategy || 'auto';

                        console.log('📋 Viewer strategy:', viewerStrategy, 'for', displayName);

                        // ✅ APLICAR ESTRATEGIA
                        if (viewerStrategy === 'new_tab') {
                            console.log('🌐 Opening in new tab (strategy: new_tab)');
                            window.open(sourceUrl, '_blank');
                            popoverText.close();
                            return;
                        }

                        // Para 'iframe' o 'auto', intentar abrir en split view
                        if ( myReference.fileName.includes('.pdf') || myReference.fileName.includes('pdf')) { //@todo usar el mime
                            console.log('📄 Opening PDF in split view');
                            if (window.myFileDropzone) {
                                window.myFileDropzone.showPdfInSplitViewFromFile(
                                    sourceUrl,
                                    displayName,
                                    searchQuery,
                                    pageNumber
                                );
                            }
                            popoverText.close();
                            return;
                        }

                        if (myReference.fileName.includes('.docx') || myReference.fileName.includes('.doc') || myReference.fileName.includes('word')) {
                            console.log('📝 Opening Word in split view');
                            if (window.myFileDropzone) {
                                window.myFileDropzone.showWordInSplitViewFromFile(
                                    sourceUrl,
                                    displayName,
                                    searchQuery,
                                    pageNumber
                                );
                            }
                            popoverText.close();
                            return;
                        }

                        // Fallback: usar viewDocument con auto-detect
                        console.log('📄 Opening with viewDocument (auto-detect)');
                        viewDocument(sourceUrl, myReference.name, true);
                    }
                });

                // 🔄 Navegación de grupos
                $("#prev-reference").on('click', function () {
                    if (currentReferenceGroup && currentReferenceIndex > 0) {
                        currentReferenceIndex--;
                        openPopoverForGroupedReference();
                    }
                });

                $("#next-reference").on('click', function () {
                    if (currentReferenceGroup && currentReferenceIndex < currentReferenceGroup.length - 1) {
                        currentReferenceIndex++;
                        openPopoverForGroupedReference();
                    }
                });
            });
        }


        let callCompletion = function (withTool = true, messageId, stream = true, noInBackground = false) {
            messageId = messageId || window.SIMBA.Utils.generateUniqueId("assistant-thinking");
            isResponseInBackground = noInBackground ? false : (assistant && chat.mainAssistant.responseOnBackground === true);
            fullStreamingResponse = "";

            const currentConfig = configManager.getConfig();

            // ✅ PRIMERO: Optimización de tokens CON mensajes originales
            let currentMessages = messageManager.getHistory();
            let totalTokens = currentMessages.reduce((total, msg) => total + messageManager.estimateTokens(msg), 0);
            const tokenThreshold = messageManager.TOKEN_LIMIT * 0.8;
            const tokensToRemove = 2000;

            while (totalTokens > tokenThreshold) {
                const result = messageManager.optimizeSystemPrompt(tokensToRemove);
                if (!result.optimized || result.tokensRemoved === 0) {
                    break;
                }
                currentMessages = messageManager.getHistory();
                totalTokens = currentMessages.reduce((total, msg) => total + messageManager.estimateTokens(msg), 0);
            }

            // ✅ SEGUNDO: AHORA añadir reasoning instruction (después de optimización)
            if (isReasoningEnabled() && currentModelCategory === 'reasoning') {
                console.log('🧠 Reasoning mode active - Adding reasoning instruction');

                // Clonar los mensajes OPTIMIZADOS
                currentMessages = JSON.parse(JSON.stringify(currentMessages));

                // Añadir la instrucción al system prompt
                /*if (currentMessages.length > 0 && currentMessages[0].role === 'system') {
                    const originalLength = currentMessages[0].content.length;
                    currentMessages[0].content += REASONING_INSTRUCTION;
                    const newLength = currentMessages[0].content.length;

                    console.log('✅ Reasoning instruction added to system prompt');
                    console.log(`📏 System prompt: ${originalLength} → ${newLength} chars`);
                    console.log('📋 First 100 chars of instruction:', REASONING_INSTRUCTION.substring(0, 100));
                }*/
            } else if (!isReasoningEnabled() && currentModelCategory === 'reasoning') {
                console.log('🚫 Reasoning mode disabled - Normal response mode');
            }

            // ✅ TERCERO: Construir payload con los mensajes ya modificados
            let payload = {
                stream: stream,
                model: currentConfig.model || DEFAULT_MODEL,
                messages: currentMessages, // ✅ Estos ya tienen la instrucción si aplica
                max_tokens: currentConfig.maxTokens || MAX_TOKENS
            };

            if (stream) {
                payload['stream_options'] = {'include_usage': true};
            }

            if (chat.tools && withTool) {
                payload['tool_choice'] = "auto";

                const toolsForApi = (chat.activeTools || chat.tools).map(tool => {
                    const cleanTool = {
                        type: tool.type,
                        function: {
                            name: tool.function.name,
                            description: tool.function.description,
                            parameters: tool.function.parameters
                        }
                    };
                    return cleanTool;
                });

                payload['tools'] = toolsForApi;
                payload['temperature'] = currentConfig.toolTemperature || 0.1;
            } else {
                payload['temperature'] = currentConfig.temperature || DEFAULT_TEMPERATURE;
            }

            // ✅ Debug: Ver el payload completo antes de enviar
            console.log('📤 Payload to send:');
            console.log('- Model:', payload.model);
            console.log('- Messages count:', payload.messages.length);
            console.log('- System prompt length:', payload.messages[0]?.content.length);
            console.log('- Has THINK in system:', payload.messages[0]?.content.includes('[THINK]'));

            isResponding = true;
            updateTemplate();

            return new Promise((resolve, reject) => {
                let responseData = [];
                let acumulatedText = "";
                let fullResponse = "";
                let isNoTool = false;
                let extractingContent = false;
                let isFunctionCall = false;
                let newMessageId = "";

                // Variables para el nuevo formato de tool_calls
                let isToolCallsFormat = false;
                let accumulatedToolCalls = [];
                let currentToolCall = null;
                let isThinkingMode = false;
                let thinkingContent = "";
                let thinkingStarted = false;
                // Function to get the message element using the ID
                const getMessageElement = function () {
                    return $('#' + messageId);
                };

                if (isResponseInBackground && !isToolCallsFormat) {
                    const progressHTML = `
        <div class="background-response-container margin-top padding-top">
            <div class="progressbar" id="response-progress">
                <span></span>
            </div>
            <div class="progress-percentage"></div>
        </div>
        <div class="collapsible-container">
            <div class="toggle-button">
                <a href="#" class="toggle-content">
                    <i class="fa fa-chevron-down"></i>
                </a>
            </div>
            <div class="response-content" style="display:none">
                <p>Processing response...</p>
            </div>
        </div>
    `;

                    getMessageElement().find('.message-text').html(progressHTML);

                    // Inicializar la barra de progreso
                    const progressBarEl = getMessageElement().find('.progressbar')[0];
                    if (progressBarEl) {
                        app.progressbar.set(progressBarEl, 0);
                    }

                    // Event listener para el bot�n de colapsar
                    getMessageElement().find('.toggle-content').on('click', function (e) {
                        e.preventDefault();
                        const container = this.closest('.collapsible-container');
                        const content = container.querySelector('.response-content');
                        const icon = this.querySelector('i');

                        const isVisible = window.getComputedStyle(content).display !== 'none';

                        if (isVisible) {
                            content.style.display = 'none';
                            icon.classList.remove('fa-chevron-up');
                            icon.classList.add('fa-chevron-down');
                        } else {
                            content.style.display = 'block';
                            icon.classList.remove('fa-chevron-down');
                            icon.classList.add('fa-chevron-up');
                        }
                    });
                }

                function updateProgress(value) {
                    if (isResponseInBackground && !isToolCallsFormat) {
                        const progressBarEl = getMessageElement().find('.progressbar')[0];
                        if (progressBarEl) {
                            app.progressbar.set(progressBarEl, value);
                            progressBarEl.setAttribute('data-label', 'Creating step by step guide ' + value + '%');
                        }
                    }
                }

                // Variables al inicio de callCompletion
                let toolCallReady = false;  // ✅ Nueva flag

                const processToolCalls = function (delta) {
                    if (delta.tool_calls && delta.tool_calls.length > 0) {
                        isToolCallsFormat = true;

                        delta.tool_calls.forEach(toolCallDelta => {
                            const index = toolCallDelta.index;

                            if (!accumulatedToolCalls[index]) {
                                accumulatedToolCalls[index] = {
                                    index: index,
                                    id: toolCallDelta.id || "",
                                    type: toolCallDelta.type || "function",
                                    function: {
                                        name: "",
                                        arguments: ""
                                    }
                                };
                            }

                            if (toolCallDelta.id) {
                                accumulatedToolCalls[index].id = toolCallDelta.id;
                            }

                            if (toolCallDelta.type) {
                                accumulatedToolCalls[index].type = toolCallDelta.type;
                            }

                            if (toolCallDelta.function) {
                                if (toolCallDelta.function.name !== null && toolCallDelta.function.name !== undefined) {
                                    accumulatedToolCalls[index].function.name = toolCallDelta.function.name;
                                }

                                if (toolCallDelta.function.arguments !== null && toolCallDelta.function.arguments !== undefined) {
                                    accumulatedToolCalls[index].function.arguments =
                                        (accumulatedToolCalls[index].function.arguments || "") +
                                        (toolCallDelta.function.arguments || "");
                                }
                            }

                            currentToolCall = accumulatedToolCalls[index];
                            isFunctionCall = true;
                        });

                        // ✅ SOLO MARCAR COMO LISTO, NO PROCESAR AÚN
                        if (currentToolCall &&
                            currentToolCall.function &&
                            currentToolCall.function.name &&
                            currentToolCall.function.arguments) {

                            const args = currentToolCall.function.arguments.trim();

                            if (args.endsWith('}') && !toolCallReady) {
                                try {
                                    JSON.parse(args);
                                    console.log("✅ Tool call JSON complete and valid");
                                    toolCallReady = true;  // ✅ Solo marcar como listo
                                } catch (e) {
                                    console.log("⏳ Still accumulating arguments...");
                                }
                            }
                        }

                        return true;
                    }
                    return false;
                };
                // Funci�n para procesar un tool call completo
                const processCompleteToolCall = function () {
                    if (!currentToolCall || !currentToolCall.function) {
                        console.warn("Incomplete or invalid tool call:", currentToolCall);
                        return false;
                    }

                    if (processingToolResponse) {
                        console.log("Already processing a tool call, ignoring duplicate");
                        return false;
                    }

                    try {
                        const toolName = currentToolCall.function.name || "";
                        if (!toolName) {
                            console.warn("Tool call without function name:", currentToolCall);
                            return false;
                        }

                        let toolParams;

                        try {
                            toolParams = JSON.parse(currentToolCall.function.arguments);
                        } catch (e) {
                            console.warn("Error parsing function arguments, trying to clean:", e);
                            const cleanedArgs = currentToolCall.function.arguments.trim()
                                .replace(/^['"]+|['"]+$/g, '')
                                .replace(/\\"/g, '"');

                            try {
                                if (cleanedArgs.startsWith('{')) {
                                    toolParams = JSON.parse(cleanedArgs);
                                } else {
                                    toolParams = {text: cleanedArgs};
                                }
                            } catch (e2) {
                                console.error("Could not parse arguments after cleaning:", e2);
                                toolParams = {text: currentToolCall.function.arguments};

                                newMessageId = "assistant-thinking-" + Date.now();
                                callCompletion(true, newMessageId, false)
                                    .then(() => {
                                        processingToolResponse = false;
                                        addSourcesToMessage($('#' + newMessageId));
                                        addActionsToMessage($('#' + newMessageId));
                                    })
                                    .catch(error => {
                                        processingToolResponse = false;
                                        console.error("Error in continuation:", error);
                                    });
                                return;
                            }
                        }

                        callTool(toolName, toolParams)
                            .then(toolResponse => {
                                console.log("Tool response processed:", toolResponse);
                                $(".shimmer-text-fast").removeClass("shimmer-text-fast");

                                if (toolResponse.sourcesAdded) {
                                    console.log("Continuing conversation with added sources");

                                    newMessageId = "assistant-thinking-" + Date.now();

                                    messages.addMessage({
                                        attrs: {
                                            "data-id": newMessageId,
                                            "id": newMessageId
                                        },
                                        isTitle: false,
                                        text: '<p>Processing retrieved information...</p>',
                                        textFooter: footerTemplate,
                                        name: assistant.name,
                                        cssClass: 'card no-margin-top padding-half',
                                        avatar: assistant.avatar,
                                        type: 'received',
                                    }, 'append', true);

                                    saveSourcesForMessage(newMessageId, toolParams);
                                    onMessageAdded($('#' + newMessageId));

                                    callCompletion(false, newMessageId)
                                        .then(() => {
                                            processingToolResponse = false;
                                            addSourcesToMessage($('#' + newMessageId));
                                            addActionsToMessage($('#' + newMessageId));
                                        })
                                        .catch(error => {
                                            processingToolResponse = false;
                                            console.error("Error in continuation:", error);
                                        });
                                } else {
                                    processingToolResponse = false;
                                }
                            })
                            .catch(error => {
                                processingToolResponse = false;
                                console.error("Error calling tool:", error);
                            });

                        return true;
                    } catch (error) {
                        console.error("Error processing complete tool call:", error);
                        processingToolResponse = false;
                        return false;
                    }
                };

                try {
                    const requestConfig = {
                        url: window.config.completion.url,
                        method: 'POST',
                        data: payload,
                        contentType: 'application/json',
                        dataType: 'text',
                        headers: {
                            'Authorization': `Bearer ${window.config.completion.apiKey}`,
                            'Accept': 'text/event-stream'
                        },
                        xhrFields: {
                            onprogress: function (e) {
                                /* if (!isResponding) {
                                     if (currentStreamingRequest &&
                                         currentStreamingRequest.xhr &&
                                         typeof currentStreamingRequest.xhr.abort === 'function') {
                                         currentStreamingRequest.xhr.abort();
                                     }
                                     return;
                                 }*/

                                const newText = e.target.responseText.substring(acumulatedText.length);
                                acumulatedText = e.target.responseText;

                                const lines = newText.split('\n');
                                for (const line of lines) {
                                    if (line.startsWith('data: ')) {
                                        try {
                                            const jsonData = line.substring(6);
                                            if (jsonData.trim() === '') continue;

                                            const parsedData = JSON.parse(jsonData);
                                            responseData.push(parsedData);

                                            if (parsedData.choices &&
                                                parsedData.choices.length > 0 &&
                                                parsedData.choices[0].delta) {

                                                const delta = parsedData.choices[0].delta;

                                                if (processToolCalls(delta)) {
                                                    continue;
                                                }

                                                const hasReasoningField = delta.hasOwnProperty('reasoning') || delta.hasOwnProperty('reasoning_content');
                                                const reasoningContent = delta.reasoning || delta.reasoning_content || '';
                                                const isReasoningEnding = hasReasoningField && (delta.reasoning === null || delta.reasoning_content === null || reasoningContent === '');

//---------------------------------------------
//  BLOQUE UNIVERSAL DE REASONING STREAMING
//---------------------------------------------

// Detectar si este chunk contiene razonamiento real
                                                const hasReasoningChunk =
                                                    (typeof delta.reasoning === "string" && delta.reasoning.length > 0) ||
                                                    (typeof delta.reasoning_content === "string" && delta.reasoning_content.length > 0);

//-----------------------------------------------------
// A) INICIO DEL REASONING
//-----------------------------------------------------
                                                if (!thinkingStarted && hasReasoningChunk && isReasoningEnabled() && currentModelCategory === 'reasoning') {

                                                    thinkingStarted = true;
                                                    isThinkingMode = true;

                                                    console.log("🧠 THINKING MODE ACTIVATED");

                                                    const thinkingHTML = `
        <div class="thinking-container">
            <div class="collapsible-container">
                <div class="thinking-header">
                    <span class="thinking-icon"><i class="fa fa-lightbulb"></i></span>
                    <span class="thinking-label">Thinking process...</span>
                    <a href="#" class="toggle-thinking-content float-right">
                        <i class="fa fa-chevron-down"></i>
                    </a>
                </div>
                <div class="thinking-content" style="display:none;">
                    <div class="thinking-text"></div>
                </div>
            </div>
            <div class="final-response" style="display:none;">
                <p>Processing final response...</p>
            </div>
        </div>`;

                                                    getMessageElement().find('.message-text').html(thinkingHTML);

                                                    // Botón de despliegue
                                                    getMessageElement().find('.toggle-thinking-content').on('click', function (e) {
                                                        e.preventDefault();
                                                        const container = this.closest('.collapsible-container');
                                                        const content = container.querySelector('.thinking-content');
                                                        const icon = this.querySelector('i');
                                                        const visible = window.getComputedStyle(content).display !== 'none';

                                                        content.style.display = visible ? 'none' : 'block';
                                                        icon.classList.toggle('fa-chevron-up', !visible);
                                                        icon.classList.toggle('fa-chevron-down', visible);
                                                    });
                                                }

//-----------------------------------------------------
// B) ACUMULAR RAZONAMIENTO
//-----------------------------------------------------
                                                if (isThinkingMode && hasReasoningChunk) {

                                                    const fragment = delta.reasoning || delta.reasoning_content || "";
                                                    fullThinkingContent += fragment;

                                                    const thinkingTextEl = getMessageElement().find('.thinking-text');
                                                    if (thinkingTextEl.length) {
                                                        thinkingTextEl.html(md.render(processAndRenderMarkdown(fullThinkingContent)));
                                                    }

                                                    if (debouncedAutoScroll) debouncedAutoScroll();
                                                    continue;
                                                }

//-----------------------------------------------------
// C) DETECTAR FINAL DEL REASONING
//-----------------------------------------------------

// 1) FIN por inicio de contenido normal
                                                const reasoningEndsByNormalContent = isThinkingMode && delta.content && delta.content.trim() !== "";

// 2) FIN por tool_call
                                                const reasoningEndsByToolCall = isThinkingMode && delta.tool_calls;

// 3) FIN por finish_reason explicita
                                                let finishReason = null;
                                                if (parsedData.choices && parsedData.choices.length > 0) {
                                                    finishReason = parsedData.choices[0].finish_reason || parsedData.choices[0].stop_reason;
                                                }
                                                const reasoningEndsByFinish = isThinkingMode && finishReason !== null;

// Procesar cualquiera de las señales de cierre
                                                if (thinkingStarted && isThinkingMode && (reasoningEndsByNormalContent || reasoningEndsByToolCall || reasoningEndsByFinish)) {

                                                    console.log("🟢 REASONING COMPLETED");

                                                    isThinkingMode = false;

                                                    // Colapsar UI reasoning
                                                    const thinkingContent = getMessageElement().find('.thinking-content');
                                                    const toggleIcon = getMessageElement().find('.toggle-thinking-content i');

                                                    if (thinkingContent.length) {
                                                        thinkingContent.hide();
                                                        toggleIcon.removeClass('fa-chevron-up').addClass('fa-chevron-down');
                                                    }

                                                    getMessageElement().find('.thinking-label').text('Thought process');

                                                    const finalResponseEl = getMessageElement().find('.final-response');
                                                    finalResponseEl.show();

                                                    // Si el cierre es por contenido, permitimos que el contenido se procese más abajo
                                                    if (!reasoningEndsByNormalContent) continue;
                                                }

//-----------------------------------------------------
// D) CONTENIDO FINAL POST-RAZONAMIENTO
//-----------------------------------------------------
                                                if (!isThinkingMode && thinkingStarted && delta.content) {

                                                    fullResponse += delta.content;

                                                    const finalResponseEl = getMessageElement().find('.final-response');
                                                    if (finalResponseEl.length) {
                                                        finalResponseEl.html(
                                                            md.render(processAndRenderMarkdown(fullResponse)) +
                                                            '<span class="thinking-icon">' + (assistant?.thinkIcon || '🤔') + '</span>'
                                                        );
                                                    }

                                                    if (debouncedAutoScroll) debouncedAutoScroll();
                                                    continue;
                                                }

                                                if (delta.content) {
                                                    const content = delta.content;

                                                    // ✅ ACUMULAR TODO primero en un buffer temporal
                                                    fullStreamingResponse += content;

                                                    const THINK_TAG = '[THINK]';
                                                    const isTruncatedThink = fullStreamingResponse.endsWith(']') &&
                                                        THINK_TAG.endsWith(fullStreamingResponse) &&
                                                        !thinkingStarted &&
                                                        isReasoningEnabled() &&
                                                        currentModelCategory === 'reasoning';

                                                    if (isTruncatedThink) {
                                                        console.warn(`⚠️ DETECTED TRUNCATED [THINK] - Chunk is '${fullStreamingResponse}'`);
                                                        console.log("🔧 Activating thinking mode proactively");

                                                        // Forzar inicio de thinking mode
                                                        isThinkingMode = true;
                                                        thinkingStarted = true;

                                                        // 🎨 CREAR UI COLAPSIBLE inmediatamente
                                                        const thinkingHTML = `
            <div class="thinking-container">
                <div class="collapsible-container">
                    <div class="thinking-header">
                        <span class="thinking-icon"><i class="fa fa fa-lightbulb"></i></span>
                        <span class="thinking-label">Thinking process...</span>
                        <a href="#" class="toggle-thinking-content float-right">
                            <i class="fa fa-chevron-down"></i>
                        </a>
                    </div>
                    <div class="thinking-content" style="display:none;">
                        <div class="thinking-text"></div>
                    </div>
                </div>
            </div>
            <div class="final-response" style="display:none;">
                <p>Processing final response...</p>
            </div>
        `;

                                                        getMessageElement().find('.message-text').html(thinkingHTML);

                                                        // 🎯 Event listener para el botón de toggle
                                                        getMessageElement().find('.toggle-thinking-content').on('click', function (e) {
                                                            e.preventDefault();
                                                            const container = this.closest('.collapsible-container');
                                                            const content = container.querySelector('.thinking-content');
                                                            const icon = this.querySelector('i');

                                                            const isVisible = window.getComputedStyle(content).display !== 'none';

                                                            if (isVisible) {
                                                                content.style.display = 'none';
                                                                icon.classList.remove('fa-chevron-up');
                                                                icon.classList.add('fa-chevron-down');
                                                            } else {
                                                                content.style.display = 'block';
                                                                icon.classList.remove('fa-chevron-down');
                                                                icon.classList.add('fa-chevron-up');
                                                            }
                                                        });

                                                        // Limpiar el "]" inicial del buffer para que no se muestre
                                                        fullStreamingResponse = '';

                                                        // Salir para esperar más contenido
                                                        if (debouncedAutoScroll) {
                                                            debouncedAutoScroll();
                                                        }
                                                        return;
                                                    }

                                                    // ⚡ PRIORIDAD 1: Detectar [TOOL_CAL PRIMERO
                                                    if (fullStreamingResponse.includes("[TOOL_CAL")) {
                                                        console.log("Detected [TOOL_CAL format, switching to non-streaming mode");
                                                        if (currentStreamingRequest && currentStreamingRequest.xhr) {
                                                            currentStreamingRequest.xhr.abort();
                                                        }
                                                        callCompletion(true, messageId, false)
                                                            .then(() => {
                                                                console.log("Non-streaming completion finished");
                                                            })
                                                            .catch(error => {
                                                                console.error("Error in non-streaming completion:", error);
                                                            });
                                                        return;
                                                    }

                                                    // 🔍 DETECCIÓN EXPLÍCITA: Solo activar thinking si vemos [THINK] o ya está iniciado
                                                    const hasExplicitThinkTag = fullStreamingResponse.includes('[THINK]');
                                                    const shouldActivateThinking = hasExplicitThinkTag || isThinkingMode;

                                                    // 🧠 MODO PROACTIVO: Solo si detectamos [THINK] explícitamente
                                                    if (isReasoningEnabled() &&
                                                        currentModelCategory === 'reasoning' &&
                                                        !thinkingStarted &&
                                                        hasExplicitThinkTag &&
                                                        !fullStreamingResponse.includes('[/THINK]')) {

                                                        // Iniciar thinking mode solo si hay [THINK] explícito
                                                        isThinkingMode = true;
                                                        thinkingStarted = true;
                                                        console.log("🧠 THINKING MODE ACTIVATED - Detected [THINK] tag");

                                                        // 🎨 CREAR UI COLAPSIBLE para el thinking
                                                        const thinkingHTML = `
            <div class="thinking-container">
                <div class="collapsible-container">
                    <div class="thinking-header">
                        <span class="thinking-icon"><i class="fa fa-brain"></i></span>
                        <span class="thinking-label">Thinking process...</span>
                        <a href="#" class="toggle-thinking-content float-right">
                            <i class="fa fa-chevron-down"></i>
                        </a>
                    </div>
                    <div class="thinking-content" style="display:none;">
                        <div class="thinking-text"></div>
                    </div>
                </div>
            </div>
            <div class="final-response" style="display:none;">
                <p>Processing final response...</p>
            </div>
        `;

                                                        getMessageElement().find('.message-text').html(thinkingHTML);

                                                        // 🎯 Event listener para el botón de toggle
                                                        getMessageElement().find('.toggle-thinking-content').on('click', function (e) {
                                                            e.preventDefault();
                                                            const container = this.closest('.collapsible-container');
                                                            const content = container.querySelector('.thinking-content');
                                                            const icon = this.querySelector('i');

                                                            const isVisible = window.getComputedStyle(content).display !== 'none';

                                                            if (isVisible) {
                                                                content.style.display = 'none';
                                                                icon.classList.remove('fa-chevron-up');
                                                                icon.classList.add('fa-chevron-down');
                                                            } else {
                                                                content.style.display = 'block';
                                                                icon.classList.remove('fa-chevron-down');
                                                                icon.classList.add('fa-chevron-up');
                                                            }
                                                        });
                                                    }

                                                    // ✅ ACTUALIZAR THINKING CONTENT EN TIEMPO REAL
                                                    // ✅ ACTUALIZAR THINKING CONTENT EN TIEMPO REAL
                                                    if (isThinkingMode && !fullStreamingResponse.includes('[/THINK]')) {
                                                        // TODO el contenido acumulado hasta ahora es thinking
                                                        thinkingContent = fullStreamingResponse.replace('[THINK]', '').trim(); // ✅ Limpiar [THINK] y trim

                                                        const thinkingTextEl = getMessageElement().find('.thinking-text');
                                                        if (thinkingTextEl.length) {
                                                            // ✅ IMPORTANTE: Renderizar dentro del contenedor correcto
                                                            thinkingTextEl.html(md.render(processAndRenderMarkdown(thinkingContent)));
                                                        }

                                                        // ✅ Auto-scroll si está habilitado
                                                        if (debouncedAutoScroll) {
                                                            debouncedAutoScroll();
                                                        }

                                                        // ✅ IMPORTANTE: continuar para no procesar este contenido como respuesta final
                                                        continue;
                                                    }

                                                    // ✅ DETECTAR FIN DE [/THINK]
                                                    if (thinkingStarted && fullStreamingResponse.includes('[/THINK]')) {
                                                        isThinkingMode = false;
                                                        console.log("✅ THINKING COMPLETE - Switching to final response");

                                                        // Extraer contenido de thinking completo (todo antes de [/THINK])
                                                        const parts = fullStreamingResponse.split('[/THINK]');
                                                        thinkingContent = parts[0].replace('[THINK]', '').trim(); // ✅ Limpiar [THINK]

                                                        // 📝 Actualizar thinking final EN SU CONTENEDOR
                                                        const thinkingTextEl = getMessageElement().find('.thinking-text');
                                                        if (thinkingTextEl.length) {
                                                            thinkingTextEl.html(md.render(processAndRenderMarkdown(thinkingContent)));
                                                        }

                                                        // 🎨 Cambiar label a "Thought process"
                                                        getMessageElement().find('.thinking-label').text('Thought process');

                                                        // ✅ Extraer solo el contenido DESPUÉS de [/THINK]
                                                        fullResponse = parts[1] ? parts[1].trim() : '';

                                                        // 👁️ Mostrar el área de respuesta final
                                                        const finalResponseEl = getMessageElement().find('.final-response');
                                                        finalResponseEl.show();

                                                        // ✅ Solo mostrar si hay contenido
                                                        if (fullResponse.trim()) {
                                                            finalResponseEl.html(md.render(processAndRenderMarkdown(fullResponse)));
                                                        }

                                                        if (debouncedAutoScroll) {
                                                            debouncedAutoScroll();
                                                        }

                                                        // ✅ IMPORTANTE: continuar para no procesar más
                                                        continue;
                                                    }

                                                    // ✅ ACTUALIZAR RESPUESTA FINAL (después del thinking)
                                                    if (!isThinkingMode && thinkingStarted && fullStreamingResponse.includes('[/THINK]')) {
                                                        const parts = fullStreamingResponse.split('[/THINK]');
                                                        fullResponse = parts[1] || '';

                                                        const finalResponseEl = getMessageElement().find('.final-response');
                                                        if (finalResponseEl.length && fullResponse.trim()) {
                                                            finalResponseEl.html(md.render(processAndRenderMarkdown(fullResponse) + '<span class="thinking-icon">' + (assistant?.thinkIcon || '🤔') + '</span>'));
                                                        }
                                                    }

                                                    // ✅ CASO NORMAL (sin thinking activo)
                                                    if (!isThinkingMode && !thinkingStarted) {
                                                        fullResponse += content;

                                                        if (isResponseInBackground && !isToolCallsFormat) {
                                                            streamingProgress += 1;
                                                            const percentage = Math.min(Math.round((streamingProgress / 10)), 99);
                                                            updateProgress(percentage);
                                                            getMessageElement().find('.response-content').html(md.render(processAndRenderMarkdown(fullResponse) + '<span class="thinking-icon">' + (assistant?.thinkIcon || '🤔') + '</span>'));
                                                        } else {
                                                            getMessageElement().find('.message-text').html(md.render(processAndRenderMarkdown(fullResponse) + '<span class="thinking-icon">' + (assistant?.thinkIcon || '🤔') + '</span>'));
                                                        }
                                                    }

                                                    if (debouncedAutoScroll) {
                                                        debouncedAutoScroll();
                                                    }
                                                }
                                            }

                                            checkScrollPosition();

                                            if (parsedData.choices &&
                                                parsedData.choices.length > 0 &&
                                                parsedData.choices[0].finish_reason !== null) {

                                                if (isResponseInBackground && !isToolCallsFormat) {
                                                    updateProgress(100);
                                                }

                                                if (isToolCallsFormat && currentToolCall) {
                                                    processCompleteToolCall();
                                                } else if (!isToolCallsFormat && !withTool) {
                                                    if (fullResponse && fullResponse.trim()) {
                                                        messageManager.addMessage('assistant', fullResponse, null, messageId);
                                                        console.log("Adding ASSISTANT with tool");
                                                        saveMessageToConversation('assistant', fullResponse, messageId);
                                                    } else {
                                                        console.log("Skipping empty assistant message in streaming");
                                                    }
                                                }

                                                if (isResponseInBackground && !isToolCallsFormat) {
                                                    const progressBarEl = getMessageElement().find('.progressbar')[0];
                                                    if (progressBarEl) {
                                                        $f7.progressbar.set(progressBarEl, 100);
                                                    }

                                                    getMessageElement().find('.response-content').html(md.render(processAndRenderMarkdown(fullResponse)));

                                                    if (chat.mainAssistant.onResponseComplete !== null && chat.mainAssistant.onResponseComplete !== undefined) {
                                                        try {
                                                            eval(chat.mainAssistant.onResponseComplete);
                                                        } catch (error) {
                                                            console.error("Error executing onResponseComplete:", error);
                                                        }
                                                    }
                                                }

                                                if (chat.tools && withTool && !isToolCallsFormat) {
                                                    if (!processingToolResponse && !isToolCallsFormat && (isFunctionCall || (!isNoTool && !extractingContent))) {
                                                        // ✅ SOLO agregar si fullResponse tiene contenido real
                                                        if (fullResponse && fullResponse.trim()) {
                                                            console.log("Showing tool JSON on finish");
                                                            messageManager.addMessage('assistant', fullResponse, null, messageId);
                                                        } else {
                                                            console.log("Skipping empty assistant message (tool call)");
                                                        }
                                                    }
                                                }

                                                const completedId = "message-completed-" + Date.now();

                                                if (isNoTool && !isToolCallsFormat) {
                                                    getMessageElement().attr("id", completedId).attr('data-id', completedId);
                                                }

                                                addActionsToMessage($('#' + completedId));
                                                console.log("SSE streaming completed");
                                            }

                                        } catch (error) {
                                            console.error("Error processing SSE line:", error, line);
                                        }
                                    }
                                }
                            }
                        },
                        success: function (data) {
                            console.log("Request completed successfully");
                            $(".thinking-icon").remove();
                            currentStreamingRequest = null;
                            isResponding = false;
                            updateTemplate();
                            makeClickableReferences();
                            makeClickableSuggestions();

                            let parsedData;
                            if (typeof data === 'string') {
                                try {
                                    parsedData = JSON.parse(data);
                                } catch (e) {
                                    console.log("Data is not JSON or is already parsed");
                                    parsedData = data;
                                }
                            } else {
                                parsedData = data;
                            }

                            // ✅ PROCESAR TOOL CALL SI ESTÁ LISTA (streaming mode)
                            if (isToolCallsFormat && toolCallReady && currentToolCall && !processingToolResponse) {
                                console.log("✅ Processing tool call after streaming completed");

                                processingToolResponse = true;

                                try {
                                    const toolName = currentToolCall.function.name;
                                    let toolParams;

                                    try {
                                        toolParams = JSON.parse(currentToolCall.function.arguments);
                                    } catch (e) {
                                        console.warn("Error parsing function arguments:", e);
                                        const cleanedArgs = currentToolCall.function.arguments.trim()
                                            .replace(/^['"]+|['"]+$/g, '')
                                            .replace(/\\"/g, '"');

                                        try {
                                            toolParams = cleanedArgs.startsWith('{')
                                                ? JSON.parse(cleanedArgs)
                                                : {text: cleanedArgs};
                                        } catch (e2) {
                                            console.error("Could not parse arguments after cleaning:", e2);
                                            toolParams = {text: currentToolCall.function.arguments};
                                        }
                                    }

                                    console.log("Calling tool:", toolName, "with params:", toolParams);

                                    // Extract token usage antes de llamar a la tool
                                    if (typeof data === 'string') {
                                        const lines = data.split('\n');
                                        for (const line of lines) {
                                            if (line.startsWith('data: ')) {
                                                try {
                                                    const jsonData = line.substring(6).trim();
                                                    if (!jsonData || jsonData === '') continue;
                                                    const chunkData = JSON.parse(jsonData);
                                                    if (chunkData.usage) {
                                                        usageData = chunkData.usage;
                                                    }
                                                } catch (e) {
                                                    // Ignorar errores
                                                }
                                            }
                                        }
                                    } else if (data && data.usage) {
                                        usageData = data.usage;
                                    }

                                    if (usageData) {
                                        console.log("%c === TOKEN USAGE INFORMATION ===", "color: blue; font-weight: bold");
                                        console.log(`Prompt tokens: ${usageData.prompt_tokens}`);
                                        console.log(`Completion tokens: ${usageData.completion_tokens}`);
                                        console.log(`Total tokens: ${usageData.total_tokens}`);
                                    }

                                    callTool(toolName, toolParams)
                                        .then(toolResponse => {
                                            console.log("Tool response processed:", toolResponse);
                                            $(".shimmer-text-fast").removeClass("shimmer-text-fast");

                                            if (toolResponse.sourcesAdded) {
                                                console.log("Continuing conversation with added sources");

                                                newMessageId = "assistant-thinking-" + Date.now();

                                                messages.addMessage({
                                                    attrs: {
                                                        "data-id": newMessageId,
                                                        "id": newMessageId
                                                    },
                                                    isTitle: false,
                                                    text: '<p>Processing retrieved information...</p>',
                                                    textFooter: footerTemplate,
                                                    name: assistant.name,
                                                    cssClass: 'card no-margin-top padding-half',
                                                    avatar: assistant.avatar,
                                                    type: 'received',
                                                }, 'append', true);

                                                saveSourcesForMessage(newMessageId, toolParams);
                                                onMessageAdded($('#' + newMessageId));

                                                callCompletion(false, newMessageId)
                                                    .then(() => {
                                                        processingToolResponse = false;
                                                        addSourcesToMessage($('#' + newMessageId));
                                                        addActionsToMessage($('#' + newMessageId));
                                                    })
                                                    .catch(error => {
                                                        processingToolResponse = false;
                                                        console.error("Error in continuation:", error);
                                                    });
                                            } else {
                                                processingToolResponse = false;
                                            }
                                        })
                                        .catch(error => {
                                            processingToolResponse = false;
                                            console.error("Error calling tool:", error);
                                        });

                                    return; // ✅ Salir después de iniciar el procesamiento de tool call

                                } catch (error) {
                                    console.error("Error processing tool call:", error);
                                    processingToolResponse = false;
                                }
                            }

                            // Handle non-streaming response with [TOOL_CALLS] format
                            if (parsedData &&
                                parsedData.choices &&
                                parsedData.choices.length > 0 &&
                                parsedData.choices[0].message &&
                                parsedData.choices[0].message.content) {

                                const messageContent = parsedData.choices[0].message.content;

                                if (messageContent.startsWith("[TOOL_CALLS]")) {
                                    console.log("Detected [TOOL_CALLS] format in non-streaming response");

                                    const toolCallMatch = messageContent.match(/^\[TOOL_CALLS\](\w+)(\{.*\})$/);

                                    if (toolCallMatch) {
                                        const toolName = toolCallMatch[1];
                                        const toolParamsStr = toolCallMatch[2];

                                        try {
                                            const toolParams = JSON.parse(toolParamsStr);

                                            console.log("Parsed tool call:", toolName, toolParams);

                                            processingToolResponse = true;

                                            callTool(toolName, toolParams)
                                                .then(toolResponse => {
                                                    console.log("Tool response processed:", toolResponse);
                                                    $(".shimmer-text-fast").removeClass("shimmer-text-fast");

                                                    if (toolResponse.sourcesAdded) {
                                                        console.log("Continuing conversation with added sources");

                                                        newMessageId = "assistant-thinking-" + Date.now();

                                                        messages.addMessage({
                                                            attrs: {
                                                                "data-id": newMessageId,
                                                                "id": newMessageId
                                                            },
                                                            isTitle: false,
                                                            text: '<p>Processing retrieved information...</p>',
                                                            textFooter: footerTemplate,
                                                            name: assistant.name,
                                                            cssClass: 'card no-margin-top padding-half',
                                                            avatar: assistant.avatar,
                                                            type: 'received',
                                                        }, 'append', true);

                                                        saveSourcesForMessage(newMessageId, toolParams);
                                                        onMessageAdded($('#' + newMessageId));

                                                        callCompletion(false, newMessageId)
                                                            .then(() => {
                                                                processingToolResponse = false;
                                                                addSourcesToMessage($('#' + newMessageId));
                                                                addActionsToMessage($('#' + newMessageId));
                                                            })
                                                            .catch(error => {
                                                                processingToolResponse = false;
                                                                console.error("Error in continuation:", error);
                                                            });
                                                    } else {
                                                        processingToolResponse = false;
                                                    }
                                                })
                                                .catch(error => {
                                                    processingToolResponse = false;
                                                    console.error("Error calling parsed tool:", error);
                                                });

                                            return;
                                        } catch (parseError) {
                                            console.error("Error parsing tool parameters:", parseError);
                                        }
                                    }
                                }
                            }

                            // Extract token usage information
                            if (typeof data === 'string') {
                                const lines = data.split('\n');
                                for (const line of lines) {
                                    if (line.startsWith('data: ')) {
                                        try {
                                            const jsonData = line.substring(6).trim();
                                            if (!jsonData || jsonData === '') continue;

                                            const chunkData = JSON.parse(jsonData);
                                            if (chunkData.usage) {
                                                usageData = chunkData.usage;
                                            }
                                        } catch (e) {
                                            console.error("Error parsing chunk:", e);
                                        }
                                    }
                                }
                            } else if (data && data.usage) {
                                usageData = data.usage;
                            } else if (responseData && responseData.length > 0) {
                                const lastChunk = responseData[responseData.length - 1];
                                if (lastChunk && lastChunk.usage) {
                                    usageData = lastChunk.usage;
                                }
                            }

                            if (usageData) {
                                console.log("%c === TOKEN USAGE INFORMATION ===", "color: blue; font-weight: bold");
                                console.log(`Prompt tokens: ${usageData.prompt_tokens}`);
                                console.log(`Completion tokens: ${usageData.completion_tokens}`);
                                console.log(`Total tokens: ${usageData.total_tokens}`);

                                setTimeout(async () => {
                                    try {
                                        const result = await messageManager.optimizeIfNeeded($f7, configManager.getConfig());
                                        if (result && result.optimized) {
                                            console.log(`Optimized: Saved ${result.tokenReduction} tokens!`);
                                        } else {
                                            console.log("No optimization needed");
                                        }
                                    } catch (error) {
                                        console.error("Optimization failed:", error);
                                    }
                                }, 1000);
                            }

                            addCodeHeaders();
                            addActionsToMessage(getMessageElement());

                            $('table').each(function (index) {
                                this.classList.add('data-table');
                                const tableId = this.id || 'data-table-' + Date.now();
                                this.id = tableId;

                                if (!document.getElementById('container-' + tableId)) {
                                    const container = document.createElement('div');
                                    container.className = 'table-container margin-bottom';
                                    container.style.overflow = 'overlay';
                                    container.id = 'container-' + tableId;

                                    const exportButton = document.createElement('span');
                                    exportButton.className = 'export-csv-button link float-right margin-bottom-half margin-right-half';
                                    exportButton.innerHTML = '<i class="fa fa-download"></i> CSV';
                                    exportButton.dataset.table = tableId;
                                    exportButton.addEventListener('click', function (e) {
                                        e.preventDefault();
                                        e.stopPropagation();
                                        const targetTableId = this.dataset.table;
                                        exportTableToCSV(document.getElementById(targetTableId));
                                    });

                                    const chartButton = document.createElement('span');
                                    chartButton.className = 'chart-button link float-right margin-bottom-half margin-right-half';
                                    chartButton.innerHTML = '<i class="fa fa-chart-bar"></i> Chart';
                                    chartButton.dataset.table = tableId;
                                    chartButton.style.marginRight = '10px';
                                    chartButton.addEventListener('click', function (e) {
                                        e.preventDefault();
                                        e.stopPropagation();
                                        const targetTableId = this.dataset.table;
                                        showChartTypeSelector(targetTableId);
                                    });

                                    const parent = this.parentNode;
                                    parent.insertBefore(container, this);
                                    container.appendChild(chartButton);
                                    container.appendChild(exportButton);
                                    container.appendChild(this);
                                }
                            });

                            if (isResponseInBackground && !isToolCallsFormat) {
                                getMessageElement().find('.progress-bar').css('width', '100%');
                                getMessageElement().find('.progress-percentage').text('');

                                if (fullResponse && fullResponse.trim() &&
                                    !messageManager.getHistory().some(msg =>
                                        msg.role === 'assistant' && msg.content === fullResponse)) {
                                    messageManager.addMessage('assistant', fullResponse);
                                    console.log("Adding ASSISTANT in success handler (background mode)");
                                    saveMessageToConversation('assistant', fullResponse, messageId);
                                } else {
                                    console.log("Skipping empty or duplicate assistant message");
                                }
                            }

                            // Handle full completion format (not streaming) - SOLO si no se procesó ya
                            // Handle full completion format (not streaming) - SOLO si no se procesó ya
                            if (parsedData &&
                                parsedData.choices &&
                                parsedData.choices.length > 0 &&
                                parsedData.choices[0].message &&
                                parsedData.choices[0].message.tool_calls &&
                                parsedData.choices[0].message.tool_calls.length > 0 &&
                                !processingToolResponse) {

                                console.log("✅ Detected full completion with tool_calls (non-streaming)");

                                processingToolResponse = true;
                                const toolCall = parsedData.choices[0].message.tool_calls[0];
                                const toolName = toolCall.function.name;
                                let toolParams;

                                try {
                                    toolParams = JSON.parse(toolCall.function.arguments);
                                } catch (e) {
                                    console.warn("Error parsing tool arguments:", e);
                                    const cleanedArgs = toolCall.function.arguments.trim()
                                        .replace(/^['"]+|['"]+$/g, '')
                                        .replace(/\\"/g, '"');

                                    try {
                                        toolParams = JSON.parse(cleanedArgs);
                                    } catch (e2) {
                                        console.error("Could not parse arguments after cleaning:", e2);
                                        toolParams = {text: toolCall.function.arguments};
                                    }
                                }

                                // ✅ NO agregar mensaje del asistente con tool_calls - solo procesar la tool
                                console.log("🔧 Processing tool call without adding empty assistant message");

                                callTool(toolName, toolParams)
                                    .then(toolResponse => {
                                        console.log("Tool response processed:", toolResponse);
                                        $(".shimmer-text-fast").removeClass("shimmer-text-fast");

                                        if (toolResponse.sourcesAdded) {
                                            console.log("Continuing conversation with added sources");

                                            newMessageId = "assistant-thinking-" + Date.now();

                                            messages.addMessage({
                                                attrs: {
                                                    "data-id": newMessageId,
                                                    "id": newMessageId
                                                },
                                                isTitle: false,
                                                text: '<p>Processing retrieved information...</p>',
                                                textFooter: footerTemplate,
                                                name: assistant.name,
                                                cssClass: 'card no-margin-top padding-half',
                                                avatar: assistant.avatar,
                                                type: 'received',
                                            }, 'append', true);

                                            saveSourcesForMessage(newMessageId, toolParams);
                                            onMessageAdded($('#' + newMessageId));

                                            callCompletion(false, newMessageId)
                                                .then(() => {
                                                    processingToolResponse = false;
                                                    addSourcesToMessage($('#' + newMessageId));
                                                    addActionsToMessage($('#' + newMessageId));
                                                })
                                                .catch(error => {
                                                    processingToolResponse = false;
                                                    console.error("Error in continuation:", error);
                                                });
                                        } else {
                                            processingToolResponse = false;
                                        }
                                    })
                                    .catch(error => {
                                        processingToolResponse = false;
                                        console.error("Error calling tool:", error);
                                    });
                            } else {
                                let responseContent;

                                if (chat.tools) {
                                    if (isToolCallsFormat) {
                                        responseContent = JSON.stringify(accumulatedToolCalls, null, 2);
                                    } else {
                                        responseContent = fullResponse;
                                    }
                                } else {
                                    responseContent = fullResponse;
                                }

                                messageManager.updateSystemMessage(messageManager.getHistory()[0].content);
                                setTimeout(() => {
                                    try {
                                        const cleanupResult = cleanSimbaAfterCompletion();

                                        if (cleanupResult.cleaned) {
                                            console.log(`🎉 Post-completion cleanup: ${cleanupResult.savedTokens} tokens saved`);

                                            if (cleanupResult.savedTokens > 1000) {
                                                console.log(`📈 Significant cleanup: ${cleanupResult.efficiencyGain}% efficiency gained`);
                                            }
                                        }
                                    } catch (error) {
                                        console.error('Error in post-completion cleanup:', error);
                                    }
                                }, 2000);

                                resolve({
                                    chunks: responseData,
                                    fullResponse: fullResponse,
                                    content: responseContent,
                                    isNoTool: isNoTool,
                                    processingTool: processingToolResponse,
                                    toolCalls: isToolCallsFormat ? accumulatedToolCalls : null
                                });
                            }
                        },
                        error: function (xhr, status, error) {
                            if (status === 'abort') {
                                console.log("Request cancelled by user");
                                resolve({
                                    status: 'aborted',
                                    message: 'Response interrupted by user'
                                });
                            } else {
                                $f7.toast.show({
                                    text: 'Unable to connect to completion service.',
                                    position: 'center',
                                    closeTimeout: 3000,
                                    cssClass: 'color-red'
                                });

                                if (isResponseInBackground) {
                                    getMessageElement().find('.progress-container').addClass('error');
                                    getMessageElement().find('.progress-percentage').text('Error');
                                }
                            }
                            isResponding = false;
                            updateTemplate();
                            setTimeout(() => {
                                try {
                                    const cleanupResult = cleanSimbaAfterCompletion();
                                    if (cleanupResult.cleaned) {
                                        console.log(`?? Error cleanup: ${cleanupResult.savedTokens} tokens saved`);
                                    }
                                } catch (cleanupError) {
                                    console.error('Error in error cleanup:', cleanupError);
                                }
                            }, 1000);
                            reject(error);
                        }
                    };

                    currentStreamingRequest = $f7.request(requestConfig);

                    window.addEventListener('completion_stop_requested', function handleStop() {
                        if (currentStreamingRequest &&
                            currentStreamingRequest.xhr &&
                            typeof currentStreamingRequest.xhr.abort === 'function') {
                            currentStreamingRequest.xhr.abort();
                        }
                        window.removeEventListener('completion_stop_requested', handleStop);
                    }, {once: true});

                } catch (initError) {
                    console.error("Error starting request:", initError);
                    isResponding = false;
                    updateTemplate();

                    $f7.toast.show({
                        text: 'Unable to connect to completion service.',
                        position: 'center',
                        closeTimeout: 3000,
                        cssClass: 'color-red'
                    });

                    reject(initError);
                }
            });
        };
        let textAreaFocus = function (prompt) {
            prompt = prompt || '';
            const textarea = document.getElementById('prompt');
            if (textarea) {
                textarea.value = prompt;

                setTimeout(() => {
                    textarea.focus();
                }, 100);
            }
        }
        // Instancia global
        let iterativeReasoner = null;

        /**
         * Toggle para activar/desactivar razonamiento iterativo
         */
        let toggleIterativeReasoning = function() {
            const currentConfig = configManager.getConfig();
            iterativeReasoningEnabled = !iterativeReasoningEnabled;

            currentConfig.iterativeReasoningEnabled = iterativeReasoningEnabled;
            configManager.updateConfig(currentConfig);

            $f7.toast.show({
                text: `Iterative reasoning ${iterativeReasoningEnabled ? 'enabled' : 'disabled'}`,
                position: 'center',
                closeTimeout: 1500,
                cssClass: iterativeReasoningEnabled ? 'color-blue' : 'color-orange'
            });

            updateTemplate();
        };
        let renderExecutionPlanInPanel = function(executionPlan, executionLog, collectedInfo) {
            const container = document.getElementById('panel-sources-content');
            if (!container) return;

            const steps = executionPlan.steps || [];

            container.innerHTML = `
        <div class="execution-plan-panel-minimal">
            <div class="plan-header-minimal">
                <i class="fa fa-route"></i>
                <span>Execution Plan</span>
                <span class="plan-badge">${steps.length}</span>
            </div>

            <div class="plan-steps-minimal" id="plan-steps-container">
                ${steps.map((step) => `
                    <div class="st-minimal" data-step-id="${step.step_id}" id="st-${step.step_id}">
                        <div class="st-status-icon">
                            <i class="fa fa-circle"></i>
                        </div>
                        <div class="st-info">
                            <div class="st-title">${step.purpose}</div>
                            <div class="st-tool">${step.tool}</div>
                        </div>
                    </div>
                `).join('')}
            </div>

            <div class="plan-footer-minimal" id="plan-footer" style="display: none;">
                <i class="fa fa-exclamation-triangle"></i>
                <span id="abort-message"></span>
            </div>
        </div>
    `;
        };

        /**
         * ✅ Actualizar estado de un step en tiempo real
         */
        let updateStepStatus = function(stepId, status, data = null) {
            const stepEl = document.getElementById(`st-${stepId}`);
            if (!stepEl) return;

            // Limpiar clases anteriores
            stepEl.classList.remove('pending', 'in-progress', 'completed', 'failed', 'skipped');

            // Añadir nueva clase
            stepEl.classList.add(status);

            // Actualizar icono
            const icon = stepEl.querySelector('.st-status-icon i');
            if (icon) {
                icon.className = 'fa ' + {
                    'pending': 'fa-circle',
                    'in-progress': 'fa-spinner fa-spin',
                    'completed': 'fa-check-circle',
                    'failed': 'fa-times-circle',
                    'skipped': 'fa-ban'
                }[status];
            }

            // Si está completado, permitir ver resultado
            if (status === 'completed' && data) {
                const stepInfo = stepEl.querySelector('.st-info');
                const existingLink = stepInfo.querySelector('.view-result-link');
                const stepId = stepEl.dataset.stepId;
                const info = iterativeReasoner.collectedInfo.find(i => i.step_id == stepId);

                if (info && info.extracted_value) {
                    const resolvedBadge = document.createElement('span');
                    resolvedBadge.className = 'resolved-value-badge';
                    resolvedBadge.innerHTML = `<i class="fa fa-link"></i> ${info.extracted_value}`;
                    stepInfo.appendChild(resolvedBadge);
                }
                if (!existingLink) {
                    const resultLink = document.createElement('a');
                    resultLink.href = '#';
                    resultLink.className = 'view-result-link';
                    resultLink.innerHTML = '<i class="fa fa-eye"></i> Result';
                    resultLink.onclick = function(e) {
                        e.preventDefault();
                        $f7.dialog.alert(
                            `<pre style="text-align: left; max-height: 400px; overflow-y: auto; font-size: 12px;">${data}</pre>`,
                            `Step ${stepId} Result`
                        );
                    };
                    stepInfo.appendChild(resultLink);
                }
            }

            // Actualizar contador en header
            updatePlanHeaderStats();
        };

        /**
         * ✅ Actualizar stats en el header del plan
         */
        let updatePlanHeaderStats = function() {
            const container = document.getElementById('plan-steps-container');
            if (!container) return;

            const completed = container.querySelectorAll('.st-minimal.completed').length;
            const total = container.querySelectorAll('.st-minimal').length;

            const badge = document.querySelector('.plan-badge');
            if (badge) {
                badge.textContent = `${completed}/${total}`;

                if (completed === total) {
                    badge.style.background = '#4CAF50';
                }
            }
        };

        let createStepMessageInChat = function(step, assistantMsgId, planId) {
            const assistantMsg = document.getElementById(assistantMsgId);
            if (!assistantMsg) return null;

            const messageBubble = assistantMsg.querySelector('.message-bubble');
            const messageText = assistantMsg.querySelector('.message-text');
            if (!messageBubble || !messageText) return null;

            let stepsContainer = messageBubble.querySelector('.orchestrator-steps-container');
            if (!stepsContainer) {
                stepsContainer = document.createElement('div');
                stepsContainer.className = 'orchestrator-steps-container';
                messageBubble.insertBefore(stepsContainer, messageText);
            }

            const stepDiv = document.createElement('div');
            stepDiv.className = 'orchestrator-st-message';
            const uniqueId = `${planId}-${step.step_id}`; // 🆕 ID único
            stepDiv.id = `chat-st-${uniqueId}`;
            stepDiv.dataset.stepId = uniqueId;

            stepDiv.innerHTML = `
        <div class="st-header" onclick="window.toggleStepContent('${uniqueId}')">
            <i class="fa fa-chevron-right"></i>
            <span class="st-header-title">${step.purpose || 'Processing...'}</span>
            <div class="st-status-badge pending" id="chat-st-status-${uniqueId}">
                <i class="fa fa-circle"></i>
            </div>
        </div>
        <div class="st-content" id="chat-st-content-${uniqueId}">
            ${step.step_type === 'tool' ? `
                <div class="st-tool-info">Tool: ${step.tool || 'N/A'}</div>
            ` : ''}
            <div class="st-section" id="chat-st-result-${uniqueId}" style="display:none;">
                <div class="st-section-title">Result</div>
                <div class="st-section-content" id="chat-st-result-content-${uniqueId}"></div>
            </div>
            <div id="chat-st-extracted-${uniqueId}"></div>
            <a href="#" class="st-view-full-plan" onclick="window.openExecutionPlanPanel(event)">
                <i class="fa fa-external-link-alt"></i>
                View full execution plan
            </a>
        </div>
    `;

            stepsContainer.appendChild(stepDiv);
            return stepDiv;
        };

        /**
         * 🆕 Toggle contenido del paso
         */
        let toggleStepContent = function(stepId) {
            const header = document.querySelector(`#chat-st-${stepId} .st-header`);
            const content = document.getElementById(`chat-st-content-${stepId}`);

            if (!header || !content) return;

            const isExpanded = content.classList.contains('expanded');

            if (isExpanded) {
                content.classList.remove('expanded');
                header.classList.remove('expanded');
            } else {
                content.classList.add('expanded');
                header.classList.add('expanded');
            }
        };

        /**
         * 🆕 Actualizar estado del paso en el chat
         */
        let updateChatStepStatus = function(stepId, status, result = null, extractedValue = null) {
            // stepId ya viene con el formato "planId-stepId"
            const stepContainer = document.getElementById(`chat-st-${stepId}`);
            if (stepContainer) {
                stepContainer.classList.remove('st-in-progress', 'st-completed', 'st-failed');
                if (status === 'in-progress') {
                    stepContainer.classList.add('st-in-progress');
                } else if (status === 'completed') {
                    stepContainer.classList.add('st-completed');
                } else if (status === 'failed') {
                    stepContainer.classList.add('st-failed');
                }
            }

            // Actualizar badge de estado
            const statusBadge = document.getElementById(`chat-st-status-${stepId}`);
            if (statusBadge) {
                statusBadge.className = 'st-status-badge ' + status;

                const iconMap = {
                    'pending': 'fa-circle',
                    'in-progress': 'fa-spinner fa-spin',
                    'completed': 'fa-check-circle',
                    'failed': 'fa-times-circle',
                    'skipped': 'fa-ban'
                };

                statusBadge.innerHTML = `<i class="fa ${iconMap[status] || 'fa-circle'}"></i>`;
            }

            // Mostrar resultado si está completado
            if (status === 'completed' && result) {
                const resultSection = document.getElementById(`chat-st-result-${stepId}`);
                const resultContent = document.getElementById(`chat-st-result-content-${stepId}`);

                if (resultSection && resultContent) {
                    resultSection.style.display = 'block';

                    // Truncar resultado si es muy largo
                    let displayResult = result;
                    if (typeof result === 'string' && result.length > 500) {
                        displayResult = result.substring(0, 500) + '... [truncated]';
                    }

                    resultContent.textContent = displayResult;
                }

                // Mostrar valor extraído si existe
                if (extractedValue) {
                    const extractedContainer = document.getElementById(`chat-st-extracted-${stepId}`);
                    if (extractedContainer) {
                        extractedContainer.innerHTML = `
                            <div class="st-extracted-value">
                                <div class="label">Extracted Value:</div>
                                <div>${extractedValue}</div>
                            </div>
                        `;
                    }
                }
            }
        };

        /**
         * 🆕 Abrir panel lateral con plan completo
         */
        let openExecutionPlanPanel = function(event) {
            event.preventDefault();

            // Abrir el panel derecho (sources panel)
            const panelRight = document.querySelector('.panel-right');
            if (panelRight && $f7) {
                $f7.panel.open('right');
            }
        };








        /**
         * ✅ Mostrar noticia de aborto en el panel
         */
        let updatePanelAbortNotice = function(message) {
            const footer = document.getElementById('plan-footer');
            const messageEl = document.getElementById('abort-message');

            if (footer && messageEl) {
                messageEl.textContent = message;
                footer.style.display = 'flex';
            }
        };
// ═══════════════════════════════════════════════════════════════
// FUNCIÓN COMÚN: Procesar archivos subidos (imágenes y documentos)
// ═══════════════════════════════════════════════════════════════
        let processUploadedFiles = async function(userMsgId, displayPrompt) {
            if (!window.myFileDropzone || !window.myFileDropzone.getFiles().length) {
                return { userMessageContent: displayPrompt };
            }

            let extractedContents = "";

            // 1. Extraer texto de archivos no-imagen
            try {
                const analysisType = getImageAnalysisType();
                extractedContents = window.myFileDropzone.getCombinedExtractedTextSync(analysisType);
            } catch (error) {
                console.error('Error processing files:', error);
                throw error;
            }

            const currentFiles = window.myFileDropzone.getFiles().slice();
            const hasImages = currentFiles.some(file => window.myFileDropzone._getFileType(file) === 'image');

            // 2. Guardar archivos en memoria
            currentFiles.forEach(file => {
                const fileType = window.myFileDropzone._getFileType(file);
                const fileData = {
                    file: file,
                    url: URL.createObjectURL(file),
                    messageId: userMsgId,
                    timestamp: Date.now(),
                    extractedText: file.extractedText || null
                };

                if (fileType === 'image') {
                    loadedImages[file.name] = fileData;
                } else {
                    loadedFiles[file.name] = { ...fileData, fileType };
                }
            });

            // 3. Renderizar archivos en el mensaje
            window.myFileDropzone.renderFileItems('header-' + userMsgId);
            window.myFileDropzone.clearFiles();

            const currentConfig = configManager.getConfig();
            const contextLocation = currentConfig.documentContextLocation || 'system';
            let userMessageContent = '';

            // 4. Procesar imágenes si existen
            if (hasImages) {
                try {
                    const imageFiles = Object.values(loadedImages)
                        .filter(img => img.messageId === userMsgId)
                        .map(img => img.file);

                    const imageResults = await window.myFileDropzone.processImagesInBackground(
                        'header-' + userMsgId,
                        displayPrompt,
                        imageFiles
                    );

                    imageResults.forEach(result => {
                        if (result.success && result.description) {
                            userMessageContent += `<simba_image data-filename="${result.file.name}">\n${result.description}\n</simba_image>\n\n`;
                        }
                    });
                } catch (error) {
                    console.error('Error processing images:', error);
                }
            }

            // 5. Añadir documentos según configuración
            if (extractedContents && !chat.mainAssistant.excludeDropzoneFromHistory) {
                if (contextLocation === 'system') {
                    messageManager.updateSystemMessage(
                        messageManager.getHistory()[0].content +
                        '\n\n--- UPLOADED DOCUMENTS ---\n' +
                        'The user has uploaded the following documents. Use this information to answer their question:\n\n' +
                        extractedContents
                    );
                } else if (contextLocation === 'user') {
                    userMessageContent = '=== REFERENCE DOCUMENTS ===\n' +
                        'Use the following documents to answer the question below.\n\n' +
                        extractedContents + '\n\n' +
                        '=== END OF DOCUMENTS ===\n\n' +
                        userMessageContent;
                }
            }

            // 6. Añadir pregunta del usuario
            if (contextLocation === 'user' && extractedContents) {
                userMessageContent += '=== QUESTION ===\n';
            }
            userMessageContent += displayPrompt;

            return { userMessageContent };
        };

// ═══════════════════════════════════════════════════════════════
// FUNCIÓN COMÚN: Crear mensaje de usuario en el chat
// ═══════════════════════════════════════════════════════════════
        let createUserMessage = function(displayPrompt) {
            const userMsgId = window.SIMBA.Utils.generateUniqueId("user-msg");

            messages.addMessage({
                attrs: {"data-id": userMsgId, "id": userMsgId},
                isTitle: false,
                text: '<p class="no-margin-top float-left">' + md.render(displayPrompt) + '</p>',
                textHeader: '<div class="margin-bottom margin-left-half padding-bottom" id="header-' + userMsgId + '"></div>',
                cssClass: 'sent card no-margin-top padding-half',
                type: 'received',
                avatar: 'https://ui-avatars.com/api/?name=User',
                textFooter: footerTemplate
            }, 'append', true);

            onMessageAdded($('#' + userMsgId));
            updateTemplate();

            return userMsgId;
        };

// ═══════════════════════════════════════════════════════════════
// FUNCIÓN COMÚN: Limpiar prompt y textarea
// ═══════════════════════════════════════════════════════════════
        let clearPromptInput = function() {
            prompt = null;
            const textarea = document.getElementById('prompt');
            if (textarea) {
                textarea.value = '';
                textarea.style.height = 'auto';
                textarea.style.height = '';
                textarea.dispatchEvent(new Event('input', {bubbles: true}));
            }
            updateTemplate();
        };

// ═══════════════════════════════════════════════════════════════
// ENVÍO CON RAZONAMIENTO ITERATIVO (ORQUESTACIÓN)
// ═══════════════════════════════════════════════════════════════
        let sendPromptWithIterativeReasoning = async function() {
            console.log('🧠 Using iterative reasoning with orchestration');

            if (!prompt || !prompt.trim()) return;

            const displayPrompt = prompt.trim() || "What is this?";
            const userQuery = prompt;

            // 1. Crear mensaje del usuario
            const userMsgId = createUserMessage(displayPrompt);

            // 2. Procesar archivos subidos
            try {
                const { userMessageContent } = await processUploadedFiles(userMsgId, displayPrompt);
                messageManager.addMessage('user', userMessageContent, null, userMsgId);
            } catch (error) {
                console.error('Error processing files:', error);
                return;
            }

            // 3. Limpiar header si no hay archivos
            if ($("#" + userMsgId).find('.message-text-header').find('.file-item').length == 0) {
                $("#" + userMsgId).find('.message-text-header').remove();
            }

            // 4. Limpiar prompt
            clearPromptInput();

            // 5. Crear mensaje del asistente (orquestador)
            const assistantMsgId = window.SIMBA.Utils.generateUniqueId("assistant-orchestrated");

            messages.addMessage({
                attrs: {"data-id": assistantMsgId, "id": assistantMsgId},
                isTitle: false,
                text: '<p><span class="thinking-icon">🎯</span> Planning execution...</p>',
                name: assistant.name,
                cssClass: 'card no-margin-top padding-half',
                textFooter: footerTemplate,
                avatar: assistant.avatar,
                type: 'received',
            }, 'append', true);

            onMessageAdded($('#' + assistantMsgId));

            // 6. Mover mensaje al final después de crear pasos
            setTimeout(() => {
                const assistantMsg = document.getElementById(assistantMsgId);
                const messagesSpace = document.getElementById('messages-space');
                if (assistantMsg && messagesSpace) {
                    messagesSpace.appendChild(assistantMsg);
                }
            }, 100);

            const myConfig = configManager.getConfig();

            try {
                // ══════════════════════════════════════════════════════════
                // ✅ FASE 1: ORQUESTACIÓN (planificar + recopilar)
                // ══════════════════════════════════════════════════════════
                const iterativeReasoner = new IterativeReasoner({
                    maxIterations: maxIterations,
                    orchestratorModel: myConfig.model,
                    conversationHistory: messageManager.getHistory(),
                    maxRecursionDepth: 2
                });

                iterativeReasoner.assistantMessageId = assistantMsgId;
                const enrichedContext = await iterativeReasoner.orchestrate(userQuery, assistantMsgId);

                console.log('✅ PHASE 1 COMPLETE');
                console.log('📋 Enriched context length:', enrichedContext.length);

                // Mostrar transición
                $('#' + assistantMsgId).find('.message-text').html(`
            <div class="phase-transition">
                <div class="phase-complete">
                    <i class="fa fa-check-circle color-green"></i>
                    Information gathering complete
                </div>
                <div class="phase-next">
                    <span class="thinking-icon">${assistant?.thinkIcon || '🤔'}</span>
                    <span>Generating comprehensive answer...</span>
                </div>
            </div>
        `);

                await new Promise(resolve => setTimeout(resolve, 800));

                // ══════════════════════════════════════════════════════════
                // ✅ FASE 2: LLM PRINCIPAL (con contexto enriquecido)
                // ══════════════════════════════════════════════════════════
                const originalSystemMessage = messageManager.getHistory()[0].content;
                messageManager.updateSystemMessage(originalSystemMessage + '\n\n' + enrichedContext);

                console.log('🎯 PHASE 2: Calling main LLM with enriched context...');

                $('#' + assistantMsgId).find('.message-text').html(
                    '<p><span class="thinking-icon">' + (assistant?.thinkIcon || '🤔') + '</span></p>'
                );

                await callCompletion(false, assistantMsgId);

                console.log('✅ PHASE 2 COMPLETE');

                // ✅ Añadir sources y actions
                addSourcesToMessage($('#' + assistantMsgId));
                addActionsToMessage($('#' + assistantMsgId));

                $f7.toast.show({
                    text: '✅ Answer generated with orchestrated context',
                    position: 'center',
                    closeTimeout: 2000,
                    cssClass: 'color-green'
                });

            } catch (error) {
                console.error('Orchestration error:', error);

                $('#' + assistantMsgId).find('.message-text').html(`
            <p class="color-red">
                <i class="fa fa-exclamation-triangle margin-right-half"></i>
                Error in orchestration: ${error.message}
            </p>
        `);
            }
        };

// ═══════════════════════════════════════════════════════════════
// ENVÍO NORMAL (SIN ORQUESTACIÓN)
// ═══════════════════════════════════════════════════════════════
        let sendPrompt = async function () {
            // Si está habilitado el razonamiento iterativo, usar orquestación
            if (iterativeReasoningEnabled) {
                return sendPromptWithIterativeReasoning();
            }

            // Validar que se permiten archivos
            if (!isFileUploadAllowed() && window.myFileDropzone && window.myFileDropzone.hasFiles()) {
                $f7.toast.show({
                    text: 'Please remove uploaded files - this assistant doesn\'t support file upload.',
                    position: 'center',
                    closeTimeout: 5000,
                    cssClass: 'color-red'
                });
                return;
            }

            if ((prompt && prompt.length && myDevice) || !chat.mainAssistant.deviceSelector) {
                if (notFinishedMessage === '') {
                    // Crear conversación si no existe
                    if (!conversationManager || !conversationManager.currentConversationId) {
                        console.log('Creating new conversation with first message...');
                        await conversationManager.createConversation(assistant, chat.title, myDevice);
                        console.log('Conversation saved locally:', conversationManager.currentConversationId);
                    }

                    response = '';
                    updateTemplate();

                    const displayPrompt = prompt && prompt.trim() ? prompt : "What is this?";

                    // 1. Crear mensaje del usuario
                    const userMsgId = createUserMessage(displayPrompt);

                    // 2. Procesar archivos subidos
                    try {
                        const { userMessageContent } = await processUploadedFiles(userMsgId, displayPrompt);
                        messageManager.addMessage('user', userMessageContent, null, userMsgId);
                        saveMessageToConversation('user', userMessageContent, userMsgId);
                    } catch (error) {
                        console.error('Error processing files:', error);
                        return;
                    }

                    // 3. Limpiar header si no hay archivos
                    if ($("#" + userMsgId).find('.message-text-header').find('.file-item').length == 0) {
                        $("#" + userMsgId).find('.message-text-header').remove();
                    }

                    onMessageAdded($('#' + userMsgId));
                    if (debouncedAutoScroll) {
                        debouncedAutoScroll();
                    }

                    // 4. Limpiar prompt
                    clearPromptInput();

                    if (debouncedAutoScroll) {
                        debouncedAutoScroll();
                    }

                    autoScrollEnabled = true;

                    // 5. Crear mensaje del asistente
                    const thinkingMsgId = window.SIMBA.Utils.generateUniqueId("assistant-thinking");

                    messages.addMessage({
                        attrs: {"data-id": thinkingMsgId, "id": thinkingMsgId},
                        isTitle: false,
                        text: '<p><span class="thinking-icon">' + (assistant?.thinkIcon || '') + '</span></p>',
                        name: assistant.name,
                        cssClass: 'card no-margin-top padding-half',
                        textFooter: footerTemplate,
                        type: 'received',
                        avatar: assistant.avatar,
                    }, 'append', true);

                    onMessageAdded($('#' + thinkingMsgId));
                    addActionsToMessage($('#' + thinkingMsgId));
                    setDynamicHeight();

                    // 6. Llamar a completion
                    if (navigator.onLine) {
                        callCompletion(true, thinkingMsgId)
                            .then(() => {
                                if (debouncedAutoScroll) {
                                    debouncedAutoScroll();
                                }

                                // Generar título automáticamente si es necesario
                                if (conversationManager && conversationManager.currentConversationId) {
                                    const history = messageManager.getHistory();
                                    const userMessages = history.filter(msg => msg.role === 'user');

                                    if (userMessages.length === 1 && (chat.title === 'New conversation' || chat.title === assistant.name)) {
                                        conversationManager.generateTitle(messageManager)
                                            .then(generatedTitle => {
                                                if (generatedTitle && generatedTitle !== 'New conversation') {
                                                    chat.title = generatedTitle;
                                                    return conversationManager.updateConversationTitle(conversationManager.currentConversationId, generatedTitle);
                                                }
                                            })
                                            .then(() => {
                                                updateTemplate();
                                            })
                                            .catch(error => {
                                                console.log('Could not generate title automatically:', error);
                                            });
                                    }
                                }
                            });
                    }
                }
            } else {
                $f7.toast.show({
                    text: 'Please select a Training Device before submitting a query.',
                    position: 'center',
                    horizontalPosition: 'center'
                });
            }
        };

        // ===========================================
        // UI HELPER FUNCTIONS
        // ===========================================

        let addSourcesToMessage = function (object) {
            const messageSources = sourceManager.getByMessageId(object.attr('id'));
            if (!messageSources || messageSources.length === 0) return;

            let $footer = object.find('.message-text-footer');
            $footer.appendTo(object.find('.message-text'));

            if ($footer.length === 0) {
                $footer = $('<div class="message-text-footer"></div>');
                object.find('.message-text').append($footer);
                $footer.html(footerTemplate);
            }

            const $leftSection = $footer.find('.sources');

            // Group sources by icon
            const groupedByIcon = {};
            messageSources.forEach(source => {
                const iconClass = source.icon || 'fa-solid fa-question';
                if (!groupedByIcon[iconClass]) {
                    groupedByIcon[iconClass] = {icon: iconClass, count: 0, names: []};
                }
                groupedByIcon[iconClass].count++;
                groupedByIcon[iconClass].names.push(source.name);
            });

            const uniqueIcons = Object.values(groupedByIcon);
            const visibleIcons = uniqueIcons.slice(0, 5);

            let sourcesHTML = '<span id="source-' + object.attr('id') + '" class="link font-size-14 badge badge-round badge-outline">';

            visibleIcons.forEach(iconGroup => {
                const tooltipText = iconGroup.names.join(', ');
                sourcesHTML += `<i data-tooltip="${tooltipText}" class="margin-half ${iconGroup.icon} fa-icon"></i>`;
            });

            sourcesHTML += '<span class="margin-left-half">Sources</span></span>';
            $leftSection.html(sourcesHTML);

            $("#source-" + object.attr('id')).on('click', function () {
                openSourcePanel(object.attr('id'));
            });
        };

        let addActionsToMessage = function (object) {
            let $footer = object.find('.message-text-footer');
            $footer.appendTo(object.find('.message-text'));

            if ($footer.length === 0) {
                $footer = $('<div class="message-text-footer"></div>');
                object.find('.message-text').append($footer);
                $footer.html(footerTemplate);
            }

            $footer.find('.message-footer-content').attr('data-message-id', object.attr('id'));
            const $rightSection = $footer.find('.actions');

            const actionsHTML = `
            <a class="link action-button margin-left-half" data-action="edit" data-message-id="${object.attr('id')}">
                <i class="tooltip-init color-gray font-size-16 icon material-icons-outlined" data-tooltip="Edit content">edit</i>
            </a>
            <a class="link action-button margin-left-half" data-action="copy" data-message-id="${object.attr('id')}">
                <i class="tooltip-init color-gray font-size-16 icon material-icons-outlined" data-tooltip="Copy message">content_copy</i>
            </a>
            <a class="link action-button margin-left-half" data-action="like" data-message-id="${object.attr('id')}">
                <i class="tooltip-init color-gray font-size-16 icon material-icons-outlined" data-tooltip="This response is useful">thumb_up</i>
            </a>
            <a class="link action-button margin-left-half" data-action="dislike" data-message-id="${object.attr('id')}">
                <i class="tooltip-init color-gray font-size-16 icon material-icons-outlined" data-tooltip="This response is not useful">thumb_down</i>
            </a>
        `;

            $rightSection.html(actionsHTML);

            $rightSection.find('.action-button').on('click', function () {
                const action = $(this).data('action');
                const messageId = $(this).data('message-id');

                switch (action) {
                    case 'copy':
                        const targetElement = document.getElementById(messageId);
                        const text = $(targetElement).find(".message-text").text();
                        window.SIMBA.Utils.copyToClipboard(text)
                            .then(() => {
                                $f7.toast.show({
                                    text: 'Message copied to clipboard',
                                    position: 'center',
                                    closeTimeout: 1500
                                });
                            })
                            .catch(err => console.error('Copy failed:', err));
                        break;
                    case 'like':
                        likeMessage(messageId);
                        break;
                    case 'dislike':
                        dialogChoiceChip.open();
                        break;
                    case 'edit':
                        editContent(extractMessageTextWithoutFooter(messageId), "my_editor", "my_file");
                        break;
                    default:
                        console.log('Unknown action:', action);
                }
            });
        };

        function extractMessageTextWithoutFooter(messageId) {
            var targetElement = document.getElementById(messageId);
            if (!targetElement) {
                console.error("Element with ID " + messageId + " not found");
                return null;
            }

            var messageTextElement = targetElement.querySelector(".message-text");
            if (!messageTextElement) {
                console.error("Element with class 'message-text' not found");
                return null;
            }

            var messageTextClone = messageTextElement.cloneNode(true);
            var footers = messageTextClone.querySelectorAll(".message-text-footer");
            footers.forEach(function (footer) {
                footer.parentNode.removeChild(footer);
            });

            return messageTextClone.innerHTML;
        }

        let openPopover2 = function (event) {
            const targetElement = event.target;
            const guid = $(targetElement).attr('data-guid');
            const page = parseInt($(targetElement).attr('data-page'), 10) || "1";
            const section = parseInt($(targetElement).attr('data-section'), 10) || "1";
            const name = $(targetElement).attr('data-filename') || 'Reference not found';
            const content = $(targetElement).attr('data-content') || 'Could not find reference information.';

            const messageElement = $(targetElement).closest('.message');
            const messageId = messageElement.attr('id');
            // Obtener todas las fuentes de localStorage
            const allSources = JSON.parse(localStorage.getItem('sources') || '{}');

            // Crear la clave para buscar la fuente espec�fica
            const sourceKey = `${guid}_${page}_${section}`;
            const sourceObject = allSources[sourceKey];
            console.log(sourceObject, sourceKey)
            let myReference;

            if (!sourceObject) {
                // Si no se encuentra la fuente en localStorage, usar datos por defecto
                myReference = {
                    name,
                    page: page || "1",
                    section: section || "1",
                    content: "..." + content + "..."
                };
            } else {
                // Si se encuentra la fuente, usar sus datos
                myReference = {
                    name: sourceObject.id || sourceObject.name || sourceObject.title || "No name",
                    page: page || (sourceObject.extra && sourceObject.extra.page) || "1",
                    section: section || (sourceObject.extra && sourceObject.extra.section) || "1",
                    content: sourceObject.content || "No content",
                    source: sourceObject.url || ('https://itc.simeng.es/' + sourceObject.source + '#phrase=true&page=' + page + '&search=' + encodeURIComponent(sourceObject.content || ''))
                };
            }

            // Abrir el popover y actualizar template
            popoverText.open(targetElement);
            updateTemplate();

            $update(function () {
                $("#view-source").on('click', function () {
                    // Para openPopover2, podr�as necesitar adaptar esto seg�n tu l�gica
                    // Ya que no tenemos messageId directamente

                    if (messageId) {
                        openSourcePanel(messageId);
                        $(".source").parent().removeClass('bg-color-chrome');
                        $(".source[id='" + guid + "']").parent().addClass('bg-color-chrome');
                    }
                });

                $("#view-document").on('click', function () {
                    console.log(myReference.source);
                    viewDocument(myReference.source, myReference.name, true);
                });
            });
        };




        // ===========================================
        // HIGHLIGHT MANAGEMENT FUNCTIONS
        // ===========================================

        let showHighlights = function () {
            updateTemplate();
            if (!popupHighlights) {
                popupHighlights = $f7.popup.create({
                    el: $el.value.find('#popup-highlights')[0],
                    swipeToClose: false,
                    on: {
                        opened: function () {
                            app.on('sortableSort', function (listEl, data) {
                                updateHighlightsOrder();
                            });
                        }
                    }
                });
            }
            popupHighlights.open();
        };

        let updateHighlightsOrder = function () {
            const sortableEl = document.getElementById('sortable-highlights-list');
            const listItems = sortableEl.querySelectorAll('li[data-highlight-id]');
            const orderedIds = Array.from(listItems).map(item => item.getAttribute('data-highlight-id'));

            highlightManager.updateOrder(orderedIds);
            updateTemplate();
        };

        let removeHighlightFromPopup = function (e, highlightId) {
            e.preventDefault();

            highlightManager.remove(highlightId);

            const highlightEl = document.getElementById(highlightId);
            if (highlightEl) {
                const parent = highlightEl.parentNode;
                parent.insertBefore(document.createTextNode(highlightEl.textContent), highlightEl);
                parent.removeChild(highlightEl);
            }

            updateTemplate();
        };

        let scrollToHighlight = function (highlightId) {
            const highlightElement = document.getElementById(highlightId);
            if (highlightElement) {
                highlightElement.scrollIntoView({
                    behavior: 'smooth',
                    block: 'center',
                    inline: 'nearest'
                });

                highlightElement.style.transition = 'all 0.3s ease';
                highlightElement.style.transform = 'scale(1.05)';
                highlightElement.style.boxShadow = '0 0 20px rgba(255, 255, 0, 0.8)';

                setTimeout(() => {
                    highlightElement.style.transform = 'scale(1)';
                    highlightElement.style.boxShadow = 'none';
                }, 1000);

                app.toast.create({
                    text: 'Scrolled to highlighted text',
                    position: 'center',
                    closeTimeout: 1500,
                }).open();
            } else {
                app.toast.create({
                    text: 'Highlight not found on page',
                    position: 'center',
                    closeTimeout: 1500,
                }).open();
            }
        };

        let toggleSortableDisable = function () {
            const sortableEl = document.getElementById('sortable-highlights-list');
            if (sortableEl) {
                $f7.sortable.toggle(sortableEl);
            }
        };

        let generalAction = function () {
            const highlightTexts = highlightManager.getAllTexts();
            const myText = "Please create a technical report using only the following information: '" + highlightTexts.join('\n') + "'";
            isResponseInBackground = true;
            setPrompt(myText);

            setTimeout(() => {
                isResponseInBackground = false;
            }, 1000);
        };

        // ===========================================
        // EVENT HANDLERS
        // ===========================================

        let handlePromptTextArea = function (e) {
            prompt = e.target.value.length > 0 ? e.target.value : null;
            updateTemplate();
        };

        let handleKeyDown = function (e) {
            if (e.key === 'Enter' && e.shiftKey) return;
            if (e.key === 'Enter' && !e.shiftKey && !mentionManager?.isSuggestionsVisible) {
                e.preventDefault();
                sendPrompt();
            }
        };

        let handleDeviceSelection = function (e) {
            myDevice = e.target.value;
            updateTemplate();
            textAreaFocus(prompt)
        };

        let handleOpenDeviceSelection = function (e) {
            myDevice = null;
            prompt = null;
            updateTemplate();
        };

        let setPrompt = function (myPrompt, isSelection = 0) {
            $("#prompt").val(myPrompt);
            prompt = myPrompt;
            if (isSelection) {
                prompt = prompt + ': ' + selectedText;
            }
            sendPrompt();
            popoverSelection.close();
        };

        /**
         * Handles message addition with sources and actions
         */
        let onMessageAdded = function (object) {
            syncTemplateData();

            if (showBottomBar) {
                const pageToolbar = document.getElementById('page-toolbar');
                const promptArea = document.getElementById('prompt-area');
                if (pageToolbar && promptArea) {
                    pageToolbar.appendChild(promptArea);
                }
            }

            // Style message elements
            object.find('.message-name').addClass('card-header').remove();

            // Handle tables
            object.find('table').each(function (index) {
                this.classList.add('data-table');
                const tableId = this.id || 'data-table-' + Date.now() + '-' + index;
                this.id = tableId;

                // Verificar si ya existe el container para evitar duplicados
                if (!document.getElementById('container-' + tableId)) {
                    const container = document.createElement('div');
                    container.className = 'table-container margin-bottom';
                    container.id = 'container-' + tableId;

                    // BOT�N CSV (existente)
                    const exportButton = document.createElement('a');
                    exportButton.href = '#';
                    exportButton.className = 'export-csv-button float-right margin-bottom-half margin-right-half';
                    exportButton.innerHTML = '<i class="fa fa-download"></i> CSV';
                    exportButton.dataset.table = tableId;
                    exportButton.addEventListener('click', function (e) {
                        e.preventDefault();
                        exportTableToCSV(document.getElementById(tableId));
                    });

                    // NUEVO BOT�N GR�FICA
                    const chartButton = document.createElement('a');
                    chartButton.href = '#';
                    chartButton.className = 'chart-button float-right margin-bottom-half margin-right-half';
                    chartButton.innerHTML = '<i class="fa fa-chart-bar"></i> Chart';
                    chartButton.dataset.table = tableId;
                    chartButton.style.marginRight = '10px'; // Espacio entre botones
                    chartButton.addEventListener('click', function (e) {
                        e.preventDefault();
                        e.stopPropagation();
                        const targetTableId = this.dataset.table;
                        showChartTypeSelector(targetTableId);
                    });

                    const parent = this.parentNode;
                    parent.insertBefore(container, this);

                    // Agregar botones al contenedor
                    container.appendChild(chartButton);  // Bot�n Chart primero
                    container.appendChild(exportButton); // Bot�n CSV segundo
                    container.appendChild(this);         // Tabla al final
                }
            });

            // Handle code blocks
            object.find('pre').each(function () {
                $(this).addClass('block block-strong inset margin-vertical');
                const codeClass = $(this).find('code').attr('class');
                if (codeClass) {
                    const language = codeClass.match(/language-(\w+)/)?.[1];
                    if (language) {
                        $(this).prepend('<div class="bg-color-black float-right padding-half small language-name">' + language + '</div>');
                    }
                }
            });

            // Add hover effects for message actions
            object.on('mouseenter touchstart', function () {
                $(this).find(".message-footer-content .actions").show();
            }).on('mouseleave touchend', function () {
                $(this).find(".message-footer-content .actions").hide();
            });

        };

        /**
         * Stops streaming response
         */
        let stopStreaming = function () {
            isResponding = false;
            autoScrollEnabled = true;
            isUserScrolling = false;
            updateTemplate();

            try {
                if (currentStreamingRequest) {
                    if (typeof currentStreamingRequest.abort === 'function') {
                        currentStreamingRequest.abort();
                    } else if (currentStreamingRequest.xhr && typeof currentStreamingRequest.xhr.abort === 'function') {
                        currentStreamingRequest.xhr.abort();
                    }
                    currentStreamingRequest = null;
                }
            } catch (error) {
                console.error("Error stopping stream:", error);
            }

            const messageElement = $('.message:last-child .message-text');
            if (messageElement.length) {
                messageElement.append('<p><em>Response interrupted by user.</em></p>');
                messageElement.find('.thinking-icon').remove();
            }

            $f7.toast.show({
                text: 'Response interrupted by user',
                position: 'center',
                closeTimeout: 2000,
            });
        };

        /**
         * Scrolls to bottom of chat
         */
        let scrollToBottom = function () {
            if (pageContent) {
                pageContent.scrollTo({
                    top: pageContent.scrollHeight,
                    behavior: 'smooth'
                });
            }
            autoScrollEnabled = true;
            isUserScrolling = false;
        };

        /**
         * Checks scroll position and shows/hides scroll button
         */
        let checkScrollPosition = function () {
            if (!pageContent) return;

            const isAtBottom = (pageContent.offsetHeight + pageContent.scrollTop) >= pageContent.scrollHeight - 50;

            // Mostrar/ocultar bot�n de scroll
            if (isAtBottom) {
                scrollToBottomBtn.classList.add('hidden');
                // Reactivar auto-scroll cuando el usuario llega al fondo
                autoScrollEnabled = true;
            } else {
                scrollToBottomBtn.classList.remove('hidden');
            }
        }

        let handleUserScroll = function () {
            // Si el asistente est� respondiendo y el usuario hace scroll, desactivar auto-scroll
            if (isResponding) {
                isUserScrolling = true;
                autoScrollEnabled = false;

                // Limpiar timeout anterior
                if (scrollTimeout) {
                    clearTimeout(scrollTimeout);
                }

                // Despu�s de 150ms sin scroll, considerar que termin� de hacer scroll
                scrollTimeout = setTimeout(() => {
                    isUserScrolling = false;
                    checkScrollPosition(); // Verificar si est� al fondo para reactivar
                }, 150);
            }
        };

        let autoScrollToBottom = function () {
            if (!pageContent || !autoScrollEnabled || isUserScrolling) {
                return;
            }

            // Solo hacer scroll si el asistente est� respondiendo
            if (isResponding) {
                // Usar requestAnimationFrame para mejor performance
                requestAnimationFrame(() => {
                    autoScrolling = true;
                    pageContent.scrollTo({
                        top: pageContent.scrollHeight,
                        behavior: 'smooth'
                    });
                });
            }
        };

        let createDebouncedAutoScroll = function () {
            return window.SIMBA.Utils.debounce(autoScrollToBottom, 50); // 50ms de debounce
        };

        // ===========================================
        // POPUP AND DIALOG INITIALIZATION
        // ===========================================

        let initializeDialogChoiceChip = function () {
            dialogChoiceChip = $f7.dialog.create({
                el: $el.value.find('#dialog-choice-chip'),
                on: {
                    close: function (dialog) {
                        dialog.$el.find('form')[0].reset();
                    }
                }
            });
        };

        let closeDialogChoiceChip = function () {
            dialogChoiceChip.close();
        };

        let submitFormDialogChoiceChip = function () {
            const form = dialogChoiceChip.$el.find('form');
            const formData = $f7.form.convertToData(form);
            form[0].reset();

            if (formData.interests?.length) {
                $f7.toast.show({
                    text: 'Your feedback(s): ' + formData.interests.join(', ')
                });
            }
            dialogChoiceChip.close();
        };

        let initializePopupTicket = function () {
            popupTicket = $f7.popup.create({
                el: $el.value.find('#popup-ticket')
            });
        };

        let openPopupTicket = function () {
            popupTicket.open();
        };

        let closePopupTicket = function (created = false) {
            if (assistant) {
                if (created) {
                    formTicketValidator.resetForm();
                } else {
                    const newMessageId = window.SIMBA.Utils.generateUniqueId("assistant-thinking");
                    $(".shimmer-text-fast").removeClass("shimmer-text-fast");

                    const message = "<em class='margin-top-half'>Support ticket creation canceled by user</em>";
                    messages.addMessage({
                        attrs: {"data-id": newMessageId, "id": newMessageId},
                        isTitle: false,
                        text: message,
                        textFooter: footerTemplate,
                        cssClass: 'card no-margin-top padding-half',
                        avatar: assistant.avatar,
                        type: 'received',
                    }, 'append', true);

                    messageManager.addMessage('assistant', message);
                }
                popupTicket.close();
            }
        };

        let initializeFormValidator = function () {
            formTicketValidator = jQuery($el.value.find('form[name=ticket]')).validate({
                rules: {
                    problem_title: {required: true},
                    problem_description: {required: true},
                    device: {required: true}
                },
                messages: {
                    problem_title: {required: 'Please enter a quick description of the issue.'},
                    problem_description: {required: 'Please enter a full description and details of the issue.'},
                    device: {required: 'Please enter the simulator/device.'}
                },
                submitHandler: function (form) {
                    const payload = {
                        name: 'action_open_support_ticket',
                        params: $f7.form.convertToData(form),
                        chat: chat.guid
                    };

                    $f7.request({
                        url: window.config.api_methods.call_tool,
                        method: 'POST',
                        data: payload,
                        contentType: 'application/json',
                        dataType: 'json',
                        headers: {'x-auth-token': window.config.token},
                        success: function (data) {
                            if (data?.data?.tool_domain === 'action') {
                                $f7.toast.show({
                                    text: 'Thank you for opening a Service Request. We will get back to you soon.',
                                    cssClass: 'color-green'
                                });

                                const newMessageId = window.SIMBA.Utils.generateUniqueId("assistant-thinking");
                                $(".shimmer-text-fast").removeClass("shimmer-text-fast");

                                const message = md.render(buildServiceRequestMessage(data.data));
                                messages.addMessage({
                                    attrs: {"data-id": newMessageId, "id": newMessageId},
                                    isTitle: false,
                                    text: message,
                                    textFooter: footerTemplate,
                                    cssClass: 'card no-margin-top padding-half',
                                    avatar: assistant.avatar,
                                    type: 'received',
                                }, 'append', true);

                                messageManager.addMessage('assistant', message);
                                closePopupTicket(true);
                            }
                        }
                    });
                    setTimeout(() => {
                        if (updatedConfig.voiceEnabled && !voiceManager) {
                            initializeVoiceManager();
                        }
                        updateTemplate();
                    }, 100);
                }
            });
        };

        let buildServiceRequestMessage = function (response) {
            const {ticket_id, guid, url, created_at} = response;
            const formattedDate = window.SIMBA.Utils.formatDate(created_at);

            return `
## Service Request Created Successfully

Your service request has been submitted and assigned the following ID:

**${ticket_id}**

Created on: ${formattedDate}

You can <a href="#" onclick="viewDocument('${url}','${ticket_id}')" class="link icon-only" target="_blank">click here to view details</a> or track the progress of your request.

Thank you for your patience. Our support team will review your request shortly.
`;
        };

        let initializeActionsCustomLayout = function () {
            actionsCustomLayout = $f7.actions.create({
                el: $el.value.find('#actions-custom-layout'),
                closeByBackdropClick: false,
                closeByOutsideClick: false,
                closeOnEscape: false
            });
        };
        let initializePopoverTools = function () {
            popoverTools = $f7.popover.create({
                el: $el.value.find('#popover-tools')
            });
        };
        let initPopoverSelection = function () {
            popoverSelection = $f7.popover.create({
                el: $el.value.find('#popover-selection')
            });

            document.addEventListener('contextmenu', function (event) {
                const selection = window.getSelection();
                const selectedTextValue = selection.toString().trim();

                if (selectedTextValue.length > 0) {
                    event.preventDefault();
                    selectedText = selectedTextValue; // <-- A�ADIR ESTA L�NEA
                    handleTextSelection(event, selectedTextValue, selection);
                }
            });
        };

        /**
         * Handles text selection for highlighting
         */
        let handleTextSelection = function (event, selectedText, selection) {
            const targetElement = event.target;
            let isMessageText = false;
            let isAlreadyHighlighted = false;

            // Check if already highlighted
            if (targetElement.classList?.contains('highlighted-text') ||
                targetElement.classList?.contains('reporting-highlight')) {

                const elementId = targetElement.id;
                if (elementId) {
                    highlightManager.remove(elementId);

                    // Remove from DOM
                    const parent = targetElement.parentNode;
                    parent.insertBefore(document.createTextNode(targetElement.textContent), targetElement);
                    parent.removeChild(targetElement);

                    updateTemplate();
                    selection.removeAllRanges();
                    return;
                }
            }

            // Check if in message text
            let currentElement = targetElement;
            while (currentElement && currentElement !== document.body) {
                if (currentElement.classList?.contains('message-text')) {
                    isMessageText = true;
                    break;
                }
                currentElement = currentElement.parentElement;
            }

            if (isMessageText && !isAlreadyHighlighted) {
                try {
                    const range = selection.getRangeAt(0);
                    const highlightSpan = document.createElement('span');
                    highlightSpan.style.backgroundColor = '#415c8d';
                    highlightSpan.style.color = 'black';
                    highlightSpan.className = 'highlighted-text';

                    const myId = window.SIMBA.Utils.generateUniqueId('highlight');
                    highlightSpan.id = myId;

                    try {
                        range.surroundContents(highlightSpan);
                    } catch (e) {
                        const contents = range.extractContents();
                        highlightSpan.appendChild(contents);
                        range.insertNode(highlightSpan);
                    }

                    const rect = highlightSpan.getBoundingClientRect();
                    const tempTarget = document.createElement('div');
                    tempTarget.style.cssText = `position:absolute;left:${rect.left}px;top:${rect.bottom}px;width:1px;height:1px;pointer-events:none;`;
                    tempTarget.id = 'temp-popover-target';
                    document.body.appendChild(tempTarget);

                    const popoverEl = document.getElementById('popover-selection');
                    if (popoverEl) {
                        popoverEl.setAttribute('data-selected-text', selectedText);
                        popoverEl.setAttribute('data-selected-id', myId);
                    }

                    popoverEl.addEventListener('popover:close', () => {
                        setTimeout(() => {
                            app.$("#popover-selection").find('.input-clear-button').trigger("click");
                        }, 1000);
                        clearHighlights();
                    });

                    if (popoverSelection) {
                        popoverSelection.open('#temp-popover-target');
                    }

                    setTimeout(() => {
                        const tempEl = document.getElementById('temp-popover-target');
                        if (tempEl) {
                            document.body.removeChild(tempEl);
                        }
                    }, 100);

                } catch (error) {
                    console.error('Error in highlighting process:', error);
                }
            }
        };

        let copyToClipboard = function () {
            const popoverEl = document.getElementById('popover-selection');
            const selectedText = popoverEl.getAttribute('data-selected-text');

            if (selectedText) {
                window.SIMBA.Utils.copyToClipboard(selectedText)
                    .then(() => {
                        app.toast.create({
                            text: 'Text copied to clipboard',
                            position: 'center',
                            closeTimeout: 1500,
                        }).open();
                    })
                    .catch(err => {
                        console.error('Copy failed:', err);
                        app.toast.create({
                            text: 'Failed to copy text',
                            position: 'center',
                            closeTimeout: 1500,
                        }).open();
                    });
            }
        };

        let highlightForReporting = function () {
            const popoverEl = document.getElementById('popover-selection');
            const selectedId = popoverEl.getAttribute('data-selected-id');
            const selectedText = popoverEl.getAttribute('data-selected-text');

            const highlightEl = document.getElementById(selectedId);
            if (highlightEl) {
                highlightEl.style.backgroundColor = '#333333';
                highlightEl.style.color = 'yellow';
                highlightEl.classList.add('reporting-highlight');

                // Use SIMBA highlight manager
                highlightManager.add(selectedId, selectedText);

                highlightEl.setAttribute('data-persistent', 'true');
                updateTemplate();
                popoverSelection.close();
            }
        };

        let clearHighlights = function () {
            // Clear temporary highlights that don't have data-persistent
            document.querySelectorAll('.highlighted-text:not([data-persistent])').forEach(el => {
                const parent = el.parentNode;
                parent.insertBefore(document.createTextNode(el.textContent), el);
                parent.removeChild(el);
            });
        };
        let clearAllFiles = function () {
            // Limpiar imágenes
            Object.keys(loadedImages).forEach(imageName => {
                if (loadedImages[imageName].url) {
                    URL.revokeObjectURL(loadedImages[imageName].url);
                }
            });
            loadedImages = {};

            // 🆕 Limpiar otros archivos
            Object.keys(loadedFiles).forEach(fileName => {
                if (loadedFiles[fileName].url) {
                    URL.revokeObjectURL(loadedFiles[fileName].url);
                }
            });
            loadedFiles = {};

            console.log("✅ All files cleared from loadedImages and loadedFiles");
        };

// 6. OPCIONAL: Modificar clearAllImages existente para que llame a clearAllFiles
        let clearAllImages = function () {
            clearAllFiles(); // Llama a la nueva función que limpia todo
        };

        // ===========================================
        // CONFIGURATION MANAGEMENT
        // ===========================================

        let initializePopupConfig = function () {
            popupConfig = $f7.popup.create({
                el: $el.value.find('#popup-config')
            });
        };

        let openPopupConfig = async function () {
            console.log('🔧 Opening config popup');
            console.log('Current config:', config);

            popupConfig.open();

            const loadingToast = $f7.toast.create({
                text: '⏳ Loading available models...',
                position: 'center',
                closeTimeout: 3000
            });
            loadingToast.open();

            try {
                await loadAvailableModels();

                if (availableModels.length > 0) {
                    loadingToast.close();
                    $f7.toast.show({
                        text: `✅ ${availableModels.length} models loaded`,
                        position: 'center',
                        closeTimeout: 2000,
                        cssClass: 'color-green'
                    });
                } else {
                    loadingToast.close();
                    $f7.toast.show({
                        text: '⚠️ Could not load models, using manual input',
                        position: 'center',
                        closeTimeout: 3000,
                        cssClass: 'color-orange'
                    });
                }
            } catch (error) {
                console.error('Error loading models:', error);
                loadingToast.close();
                $f7.toast.show({
                    text: '⚠️ Models unavailable, using manual input',
                    position: 'center',
                    closeTimeout: 3000,
                    cssClass: 'color-orange'
                });
            }

            // ✅ Renderizar Model con categorías: chat, reasoning
            renderModelField(
                'model',
                'Model',
                config.model || DEFAULT_MODEL,
                '#model-field-container',
                ['chat', 'reasoning']  // ✅ Solo chat y reasoning
            );

            // ✅ Renderizar Summary Model con categorías: chat, reasoning
            renderModelField(
                'summary_model',
                'Summary Model',
                config.summaryModel || SUMMARY_MODEL,
                '#summary-model-field-container',
                ['chat', 'reasoning']  // ✅ Solo chat y reasoning
            );

            // ✅ Renderizar Vision Model con categoría: vision
            renderModelField(
                'vision_model',
                'Vision Model',
                config.visionModel || VISION_MODEL,
                '#vision-model-field-container',
                ['vision']  // ✅ Solo vision
            );

            updateTemplate();
        };

        let closePopupConfig = function () {
            formConfigValidator.resetForm();
            popupConfig.close();
        };

        let initializeConfigFormValidator = function () {
            const formElement = $el.value.find('form[name=config]');

            if (!formElement.length) {
                console.error('❌ Config form not found');
                return;
            }

            console.log('✅ Initializing config form validator');

            formConfigValidator = jQuery(formElement).validate({
                rules: {
                    api_url: {required: true},
                    token: {required: true, minlength: 10},
                    completion_url: {required: true},
                    api_key: {required: true, minlength: 10},
                    model: {required: true},
                    max_tokens: {required: true, min: 100, max: 100000},
                    token_limit: {required: true, min: 1000, max: 200000},
                    temperature: {required: true, min: 0, max: 2},
                    tool_temperature: {required: true, min: 0, max: 2},
                    summary_model: {required: true},
                    voice_language: {required: true},
                    max_recording_time: {required: true, min: 5, max: 300}
                },
                messages: {
                    api_url: {required: 'Please enter the API URL.'},
                    token: {
                        required: 'Please enter the authentication token.',
                        minlength: 'Token seems too short.'
                    },
                    completion_url: {required: 'Please enter the completion URL.'},
                    api_key: {
                        required: 'Please enter the API key.',
                        minlength: 'API key seems too short.'
                    },
                    model: {required: 'Please enter the model name.'},
                    max_tokens: {
                        required: 'Please enter max tokens.',
                        min: 'Minimum is 100 tokens.',
                        max: 'Maximum is 100,000 tokens.'
                    },
                    token_limit: {
                        required: 'Please enter token limit.',
                        min: 'Minimum is 1,000 tokens.',
                        max: 'Maximum is 200,000 tokens.'
                    },
                    temperature: {
                        required: 'Please enter temperature.',
                        min: 'Minimum is 0.',
                        max: 'Maximum is 2.'
                    },
                    tool_temperature: {
                        required: 'Please enter tool temperature.',
                        min: 'Minimum is 0.',
                        max: 'Maximum is 2.'
                    },
                    summary_model: {required: 'Please enter summary model.'},
                    voice_language: {required: 'Please select a voice language.'},
                    max_recording_time: {
                        required: 'Please enter max recording time.',
                        min: 'Minimum is 5 seconds.',
                        max: 'Maximum is 300 seconds (5 minutes).'
                    }
                },
                submitHandler: function (form) {
                    console.log('📝 Config form submitted');

                    const formData = $f7.form.convertToData(form);
                    console.log('📋 Form data:', formData);

                    const updatedConfig = {
                        assistantApiUrl: formData.api_url,
                        assistantAuthToken: formData.token,
                        completionsApiUrl: formData.completion_url,
                        completionsApiKey: formData.api_key,
                        model: formData.model,
                        summaryModel: formData.summary_model,
                        visionModel: formData.vision_model, // ✅ NUEVO
                        maxTokens: parseInt(formData.max_tokens),
                        tokenLimit: parseInt(formData.token_limit),
                        temperature: parseFloat(formData.temperature),
                        toolTemperature: parseFloat(formData.tool_temperature),

                        // Voice config...
                        voiceEnabled: formData.voice_enabled === 'on' || formData.voice_enabled === true || formData.voice_enabled === 'true',
                        voiceLanguage: formData.voice_language,
                        maxRecordingTime: parseInt(formData.max_recording_time),
                        voiceAutoSend: formData.voice_auto_send === 'on' || formData.voice_auto_send === true || formData.voice_auto_send === 'true',
                        voiceShowButton: formData.voice_show_button === 'on' || formData.voice_show_button === true || formData.voice_show_button === 'true',
                        voiceContinuous: formData.voice_continuous === 'on' || formData.voice_continuous === true || formData.voice_continuous === 'true',
                        echoCancellation: formData.echo_cancellation === 'on' || formData.echo_cancellation === true || formData.echo_cancellation === 'true',
                        noiseSuppression: formData.noise_suppression === 'on' || formData.noise_suppression === true || formData.noise_suppression === 'true',
                        autoGainControl: formData.auto_gain_control === 'on' || formData.auto_gain_control === true || formData.auto_gain_control === 'true'
                    };

                    console.log('💾 Saving config:', updatedConfig);

                    configManager.updateConfig(updatedConfig);

                    // Actualizar variables globales
                    TOKEN_LIMIT = updatedConfig.tokenLimit;
                    MAX_TOKENS = updatedConfig.maxTokens;
                    DEFAULT_TEMPERATURE = updatedConfig.temperature;
                    DEFAULT_MODEL = updatedConfig.model;
                    SUMMARY_MODEL = updatedConfig.summaryModel;
                    VISION_MODEL = updatedConfig.visionModel; // ✅ NUEVO
                    updateCurrentModelCategory();
                    console.log('✅ Global variables updated:', {
                        TOKEN_LIMIT,
                        MAX_TOKENS,
                        DEFAULT_TEMPERATURE,
                        DEFAULT_MODEL,
                        SUMMARY_MODEL,
                        VISION_MODEL // ✅ NUEVO
                    });

                    // ... resto del código (VoiceManager, etc.)

                    if (voiceManager && !updatedConfig.voiceEnabled) {
                        voiceManager.destroy().catch(console.error);
                        voiceManager = null;
                        voiceSupported = false;
                    } else if (updatedConfig.voiceEnabled) {
                        if (voiceManager) {
                            voiceManager.switchLanguage(updatedConfig.voiceLanguage);
                            voiceManager.config.maxRecordingTime = updatedConfig.maxRecordingTime * 1000;
                        } else {
                            initializeVoiceManager();
                        }
                    }

                    if (toolManager) {
                        toolManager.updateConfig(configManager.getConfig());
                    }

                    messageManager.MAX_TOKENS = MAX_TOKENS;
                    messageManager.TOKEN_LIMIT = TOKEN_LIMIT;

                    console.log('✅ Configuration saved successfully');

                    $f7.toast.show({
                        text: 'Configuration saved successfully',
                        cssClass: 'color-green',
                        closeTimeout: 3000
                    });

                    updateTemplate();
                    closePopupConfig();
                }
            });

            // ✅ Event listener mejorado - sin llamar a submit()
            formElement.on('submit', function (e) {
                e.preventDefault(); // Prevenir comportamiento por defecto
                e.stopPropagation(); // Evitar que el evento se propague

                console.log('🔧 Form submit event triggered');

                // jQuery Validate se encarga automáticamente de:
                // 1. Validar el formulario
                // 2. Si es válido, ejecutar submitHandler
                // 3. Si no es válido, mostrar errores

                // ❌ NO HACER ESTO: $(this).submit();
                // ✅ jQuery Validate ya maneja todo automáticamente
            });

            console.log('✅ Config form validator initialized');
        };

        let initializePopoverText = function () {
            popoverText = $f7.popover.create({
                el: $el.value.find('#popover-text'),
                on: {
                    closed: function () {
                        myReference = null;
                        updateTemplate();
                    }
                }
            });
        };

        // ===========================================
        // UTILITY FUNCTIONS
        // ===========================================

        let setupDocumentUpload = function () {
            const fileInput = document.getElementById('document-upload');
            fileInput.addEventListener('change', function (e) {
                // AGREGAR ESTA VERIFICACI�N AL INICIO
                if (!isFileUploadAllowed()) {
                    $f7.toast.show({
                        text: 'File upload is disabled for this assistant.',
                        position: 'center',
                        closeTimeout: 3000,
                        cssClass: 'color-red'
                    });
                    e.target.value = ''; // Limpiar input
                    return;
                }

                // C�digo original
                if (e.target.files && e.target.files.length > 0) {
                    if (window.myFileDropzone) {
                        window.myFileDropzone.handleFiles(e.target.files);
                    }
                }
            });
        };

        let handleFileUploadClick = function () {
            if (!isFileUploadAllowed()) {
                $f7.toast.show({
                    text: 'File upload is disabled for this assistant.',
                    position: 'center',
                    closeTimeout: 3000,
                    cssClass: 'color-red'
                });
                return;
            }

            // C�digo original
            const fileInput = document.getElementById('document-upload');
            fileInput.click();
        };

        let openSourcePanel = function (messageId) {
            if (messageId) {
                const messageSources = sourceManager.getByMessageId(messageId);
                if (messageSources && messageSources.length > 0) {
                    renderSourcesInPanel(messageSources);

                    $(".source").each(function () {
                        $(this).on('mouseover touchstart', function () {
                            const elementId = $(this).attr('id');
                            $('.reference[data-guid="' + elementId + '"]').addClass('listening-button');
                        }).on('mouseout touchend', function () {
                            const elementId = $(this).attr('id');
                            $('.reference[data-guid="' + elementId + '"]').removeClass('listening-button');
                        });
                    });

                    app.panel.open('right');
                }
            }
        };

        let renderSourcesInPanel = function (sources) {
            const container = document.getElementById('panel-sources-content');
            if (!container) return;

            container.innerHTML = `
    <div class="no-shadow">
        <div class="card-content">
            <div class="list media-list margin-top-auto">
                <ul>
                    ${sources.map((item) => {
                const sourceUrl = item.source || item.url || '';
                const finalSource = (sourceUrl && (sourceUrl.startsWith('http://') || sourceUrl.startsWith('https://')))
                    ? sourceUrl
                    : (sourceUrl ? 'https://itc.simeng.es/' + sourceUrl : '#');

                return `
                        <li>
                            <a href="#" onclick="handleSourceClick('${item.guid}', '${finalSource}', '${item.name}')" id="${item.guid}" class="source color-white link icon-only">
                                <div class="item-content">
                                    <div class="item-media"><i class="${item.icon || 'fa-file'}"></i></div>
                                    <div class="item-inner">
                                        <div class="source-title item-title">${item.name || 'Unnamed'}</div>
                                        <div class="source-summary item-text">${item.summary || ''}</div>
                                        <div class="source-extra item-text">${item.site || ''} - ${item.device || ''} - ${item.id || ''}</div>
                                    </div>
                                </div>
                            </a>
                        </li>
                        `;
            }).join('')}
                </ul>
            </div>
        </div>
    </div>
    `;
        };



        let getObjectAndTextByGuid = function (sources, guid, page, section) {
            console.log(sources);
            if (!sources) return null;

            const foundObject = sources[guid];//.find(item => item.guid === guid);
            console.log(getObjectAndTextByGuid, guid,foundObject)
            if (!foundObject) return null;

            let extractedText = null;
            if (page !== undefined && section !== undefined && foundObject.references) {
                const foundReference = foundObject.references.find(ref =>
                    ref.page === page && ref.section === section
                );
                if (foundReference) {
                    extractedText = foundReference.text;
                }
            }

            if (extractedText === null && foundObject.text) {
                const words = foundObject.summary ? foundObject.summary.split(/\s+/) : foundObject.text.split(/\s+/);
                extractedText = words.slice(0, 10).join(' ') + (words.length > 10 ? '...' : '');
            }

            return {
                sourceObject: foundObject,
                extractedText: extractedText
            };
        };


        let likeMessage = function (messageId) {
            console.log('Message liked:', messageId);
            $f7.toast.show({
                text: 'Thank you for your feedback!',
                cssClass: 'color-green',
                closeTimeout: 2000
            });
        };


        /**
         * Handles stask execution from file dropzone
         */
        let handleStaskExecution = function (file, text) {
            const stask = {file: file, procedure: text};
            localStorage.setItem('stask', JSON.stringify(stask));

            popupTask = app.popup.create({
                destroyOnClose: false, //
                content: `
                <div class="popup popup-tablet-fullscreen">
                    <div class="view">
                        <div class="page">
                            <div class="navbar">
                                <div class="navbar-bg"></div>
                                <div class="navbar-inner">
                                    <div class="title">${text.procedure.name}</div>
                                    <div class="right">
                                        <a href="#" class="link popup-close"><i class="fa fa-close"></i></a>
                                    </div>
                                </div>
                            </div>

                            <div class="page-content hide-navbar-on-scroll">
                                <iframe src="https://mysimba.simeng.es/#!/screens/walkthrough/"
                                    style="width:100%; height:100%; border:none;"
                                    frameborder="0"></iframe>
                            </div>
                        </div>
                    </div>
                </div>
            `,
                on: {
                    opened: function () {
                        console.log('Stask popup opened');
                    }
                }
            }).open();
            $update();
        };

        // ===========================================
        // INITIALIZATION FUNCTIONS
        // ===========================================

        let initializeMessagebar = function () {
            messagebar = $f7.messagebar.create({
                el: $el.value.find('.messagebar-chat'),
                textareaEl: $el.value.find('.messagebar-chat textarea')
            });
        };

        let initializeMessages = function () {
            messages = $f7.messages.create({
                el: $el.value.find('.messages'),
                scrollMessages: true,
                autoLayout: true,
                scrollMessagesOnEdge: true,
                firstMessageRule: function (message, previousMessage, nextMessage) {
                    if (message && !message.isTitle && (!previousMessage || previousMessage.type !== message.type || previousMessage.name !== message.name)) {
                        return true;
                    }
                    return false;
                },
                lastMessageRule: function (message, previousMessage, nextMessage) {
                    if (message && !message.isTitle && (!nextMessage || nextMessage.type !== message.type || nextMessage.name !== message.name)) {
                        return true;
                    }
                    return false;
                },
                tailMessageRule: function (message, previousMessage, nextMessage) {
                    if (message && !message.isTitle && (!nextMessage || nextMessage.type !== message.type || nextMessage.name !== message.name)) {
                        return true;
                    }
                    return false;
                }
            });
        };
        let initializeFileDropzone = function () {
            if (chat && chat.mainAssistant && chat.mainAssistant.activeDropzone === false) {
                console.log('File dropzone disabled for this assistant');
                return null;
            }

            const imageAnalysisType = getImageAnalysisType();

            const dropzone = new FileDropzone({
                dropzoneId: 'file-dropzone',
                fileInputId: 'file-upload',
                textareaId: 'prompt',
                useSimbaDocumentTags: true,
                framework7: $f7,
                enableSqlQueries: true,

                // NUEVO: Configurar capacidades de imagen
                imageAnalysisType: imageAnalysisType, // 'OCR', 'Vision', o null
                allowImages: imageAnalysisType !== null,

                onFileAdded: function (file) {
                    console.log("File added:", file.name);

                    // Verificar si es imagen y est� permitida
                    if (file.type.startsWith('image/') && !isImageUploadAllowed()) {
                        if ($f7) {
                            $f7.toast.show({
                                text: 'Images are not allowed for this assistant.',
                                position: 'center',
                                closeTimeout: 3000,
                                cssClass: 'color-red'
                            });
                        }
                        return false; // Rechazar el archivo
                    }
                },

                onFileRemoved: function (file) {
                    console.log("File removed:", file.name);


                },
                onTextExtracted: function (file, text) {
                    console.log("Text extracted from", file.name);
                },
                onStaskExecuted: function (file, text) {
                    handleStaskExecution(file, text);
                },
                onAllFilesProcessed: function (files) {
                    console.log("All files processed:", files.length);
                }
            });

            return dropzone;
        };
        /**
         * Actualiza el estado del dropzone seg�n activeDropzone
         */
        let updateDropzoneState = function () {
            const isDropzoneActive = chat && chat.mainAssistant && chat.mainAssistant.activeDropzone !== false;
            const imageAnalysisType = getImageAnalysisType();

            console.log('?? Updating dropzone state:', {
                isDropzoneActive,
                imageAnalysisType,
                allowImages: imageAnalysisType !== null,
                currentAssistant: assistant?.name
            });

            if (!isDropzoneActive) {
                // Deshabilitar dropzone completamente
                if (window.myFileDropzone) {
                    // ? Limpiar TODOS los archivos antes de deshabilitar
                    if (window.myFileDropzone.hasFiles()) {
                        window.myFileDropzone.clearFiles();
                    }
                    window.myFileDropzone.disable();
                }
            } else {
                // Habilitar dropzone
                if (!window.myFileDropzone) {
                    // Crear nuevo dropzone con la configuraci�n correcta
                    window.myFileDropzone = initializeFileDropzone();
                } else {
                    // ? IMPORTANTE: Habilitar ANTES de actualizar configuraci�n
                    window.myFileDropzone.enable();

                    // Actualizar configuraci�n de an�lisis de im�genes
                    window.myFileDropzone.updateImageAnalysisType(imageAnalysisType);

                    // Si el nuevo asistente no permite im�genes, remover im�genes existentes
                    if (imageAnalysisType === null) {
                        const currentFiles = window.myFileDropzone.getFiles();
                        const imageFiles = currentFiles.filter(file =>
                            window.myFileDropzone._getFileType(file) === 'image'
                        );

                        if (imageFiles.length > 0) {
                            console.log('Removing ' + imageFiles.length + ' images (not allowed by new assistant)');

                            imageFiles.forEach(function (imageFile) {
                                window.myFileDropzone.removeFile(imageFile.name);
                            });

                            if ($f7) {
                                $f7.toast.show({
                                    text: 'Images removed - not supported by this assistant',
                                    position: 'center',
                                    closeTimeout: 3000,
                                    cssClass: 'color-orange'
                                });
                            }
                        }
                    }
                }
            }

            updateTemplate();
        };
        /**
         * Verifica si est� permitido subir archivos
         */
        let isFileUploadAllowed = function () {
            return chat && chat.mainAssistant && chat.mainAssistant.activeDropzone !== false;
        };
        let cleanupCharts = function () {
            if (chartGenerator) {
                chartGenerator.destroyAllCharts();
                console.log('?? All charts cleaned up');
            }
        };

        let initializeVoiceManager = function () {
            try {
                // Inicializar configuraci�n de voz
                const voiceConfigData = initializeVoiceConfig();

                // Verificar si voice est� habilitado
                if (voiceConfigData.voiceEnabled === false) {
                    console.log('?? Voice features disabled by configuration');
                    voiceSupported = false;
                    updateTemplate();
                    return;
                }

                voiceManager = new window.SIMBA.VoiceManager({
                    engine: 'webspeech',
                    language: voiceConfigData.voiceLanguage || 'en-US',
                    maxRecordingTime: (voiceConfigData.maxRecordingTime || 30) * 1000, // convertir a ms
                    continuous: voiceConfigData.voiceContinuous || false,
                    onRecordingStart: () => {
                        isRecording = true;
                        isProcessingVoice = false;
                        updateTextareaPlaceholder();
                        updateTemplate();
                    },
                    onRecordingStop: () => {
                        isRecording = false;
                        updateTextareaPlaceholder();
                        updateTemplate();
                    },
                    onProcessingStart: () => {
                        isProcessingVoice = true;
                        updateTextareaPlaceholder();
                        updateTemplate();
                    },
                    onProcessingEnd: () => {
                        isProcessingVoice = false;
                        updateTextareaPlaceholder();
                        updateTemplate();
                    },
                    onTranscriptionComplete: (result) => {
                        handleTranscriptionResult(result, voiceConfigData.voiceAutoSend);
                    },
                    onError: (error) => {
                        handleVoiceError(error);
                    }
                });

                voiceSupported = voiceManager.isSupported();

                if (voiceSupported) {
                    voiceManager.initialize()
                        .then(() => {
                            console.log('? Voice Manager initialized successfully');
                            updateTemplate();
                        })
                        .catch((error) => {
                            console.error('? Voice Manager initialization failed:', error);
                            voiceSupported = false;
                            updateTemplate();
                        });
                } else {
                    console.warn('?? Voice recording not supported in this browser');
                }

            } catch (error) {
                console.error('? Error creating Voice Manager:', error);
                voiceSupported = false;
                updateTemplate();
            }
        };

        let showVoiceDisabledMessage = function () {
            $f7.toast.show({
                text: 'Voice features are disabled. Enable them in settings.',
                position: 'center',
                closeTimeout: 3000,
                cssClass: 'color-orange'
            });
        };


        let updateVoiceConfigByAssistant = function () {
            if (chat && chat.mainAssistant) {
                const assistantVoiceEnabled = chat.mainAssistant.voiceEnabled !== false;
                voiceConfig.enabled = assistantVoiceEnabled;

                if (assistantVoiceEnabled && !voiceManager) {
                    initializeVoiceManager();
                }

                updateTemplate();
            }
        };

        let handleVoiceButtonClick = function () {
            if (!voiceManager || !voiceSupported) {
                $f7.toast.show({
                    text: 'Voice recording is not supported in your browser',
                    position: 'center',
                    closeTimeout: 3000,
                    cssClass: 'color-red'
                });
                return;
            }

            if (isRecording) {
                stopVoiceRecording();
            } else {
                startVoiceRecording();
            }
        };
        let toggleVoiceFeatures = function (enabled) {
            const currentConfig = configManager.getConfig();
            currentConfig.voiceEnabled = enabled;
            configManager.updateConfig(currentConfig);

            if (enabled && !voiceManager) {
                initializeVoiceManager();
            } else if (!enabled && voiceManager) {
                voiceManager.destroy().catch(console.error);
                voiceManager = null;
                voiceSupported = false;
                isRecording = false;
                isProcessingVoice = false;
            }

            updateTemplate();

            $f7.toast.show({
                text: `Voice features ${enabled ? 'enabled' : 'disabled'}`,
                cssClass: enabled ? 'color-green' : 'color-orange'
            });
        };

// 6. FUNCI�N PARA CAMBIAR IDIOMA DIN�MICAMENTE
        let changeVoiceLanguage = function (languageCode) {
            if (voiceManager) {
                voiceManager.switchLanguage(languageCode)
                    .then(() => {
                        const currentConfig = configManager.getConfig();
                        currentConfig.voiceLanguage = languageCode;
                        configManager.updateConfig(currentConfig);

                        $f7.toast.show({
                            text: `Voice language changed to ${languageCode}`,
                            cssClass: 'color-blue'
                        });
                    })
                    .catch((error) => {
                        console.error('Error changing language:', error);
                        $f7.toast.show({
                            text: 'Failed to change voice language',
                            cssClass: 'color-red'
                        });
                    });
            }
        };
        let startVoiceRecording = function () {
            if (!voiceManager) return;

            voiceManager.startRecording()
                .catch((error) => {
                    console.error('? Failed to start recording:', error);
                    $f7.toast.show({
                        text: 'Failed to start recording. Please check microphone permissions.',
                        position: 'center',
                        closeTimeout: 4000,
                        cssClass: 'color-red'
                    });
                });
        };

        let stopVoiceRecording = function () {
            if (!voiceManager) return;

            voiceManager.stopRecording()
                .catch((error) => {
                    console.error('? Failed to stop recording:', error);
                });
        };

        let checkMicrophonePermissions = function () {
            if (navigator.permissions && navigator.permissions.query) {
                navigator.permissions.query({name: 'microphone'})
                    .then((permissionStatus) => {
                        console.log('?? Microphone permission status:', permissionStatus.state);

                        permissionStatus.onchange = function () {
                            console.log('?? Microphone permission changed to:', this.state);
                            if (this.state === 'denied' && voiceManager) {
                                voiceSupported = false;
                                updateTemplate();
                            }
                        };
                    })
                    .catch(console.warn);
            }
        };

        let updateTextareaPlaceholder = function () {
            const textarea = document.getElementById('prompt');
            if (!textarea) return;

            const originalPlaceholder = assistant ? assistant.placeholder : 'Type your message...';

            if (isRecording) {
                textarea.placeholder = '?? Recording... Speak now';
            } else if (isProcessingVoice) {
                textarea.placeholder = '?? Processing voice...';
            } else {
                textarea.placeholder = originalPlaceholder;
            }
        };

        let handleTranscriptionResult = function (result, autoSend = false) {
            console.log('?? Transcription result:', result);

            if (result.text && result.text.trim()) {
                // Obtener el textarea y agregar el texto transcrito
                const promptTextarea = document.getElementById('prompt');
                if (promptTextarea) {
                    const currentText = promptTextarea.value || '';
                    const newText = currentText + (currentText ? ' ' : '') + result.text.trim();
                    promptTextarea.value = newText;
                    prompt = newText;

                    // Hacer focus y posicionar cursor al final
                    textAreaFocus(prompt)
                    promptTextarea.setSelectionRange(newText.length, newText.length);

                    // Trigger input event para actualizar el estado
                    promptTextarea.dispatchEvent(new Event('input', {bubbles: true}));
                }

                updateTemplate();

                // Auto-send si est� habilitado
                if (autoSend) {
                    $f7.toast.show({
                        text: `Voice transcribed and sending: "${result.text.trim()}"`,
                        position: 'center',
                        closeTimeout: 2000,
                        cssClass: 'color-blue'
                    });

                    // Enviar autom�ticamente despu�s de un breve delay
                    setTimeout(() => {
                        sendPrompt();
                    }, 500);
                } else {
                    // Mostrar toast de confirmaci�n normal
                    $f7.toast.show({
                        text: `Voice transcribed: "${result.text.trim()}"`,
                        position: 'center',
                        closeTimeout: 3000,
                        cssClass: 'color-green'
                    });
                }
            } else {
                $f7.toast.show({
                    text: 'No speech detected. Please try again.',
                    position: 'center',
                    closeTimeout: 3000,
                    cssClass: 'color-orange'
                });
            }
        };

        let handleVoiceError = function (error) {
            console.error('?? Voice error:', error);

            isRecording = false;
            isProcessingVoice = false;
            updateTemplate();

            let errorMessage = 'Voice recording failed';

            if (error.message.includes('Permission')) {
                errorMessage = 'Microphone permission denied. Please allow microphone access.';
            } else if (error.message.includes('NotFound')) {
                errorMessage = 'No microphone found. Please connect a microphone.';
            } else if (error.message.includes('initialization')) {
                errorMessage = 'Voice recognition service failed to initialize';
            }

            $f7.toast.show({
                text: errorMessage,
                position: 'center',
                closeTimeout: 4000,
                cssClass: 'color-red'
            });
        };

        let initializeVoiceConfig = function () {
            const defaultVoiceConfig = {
                voiceEnabled: true,
                voiceLanguage: 'en-US',
                maxRecordingTime: 30, // segundos
                voiceAutoSend: false,
                voiceShowButton: false,
                voiceContinuous: false,
                echoCancellation: true,
                noiseSuppression: true,
                autoGainControl: true
            };

            // Obtener configuraci�n actual y hacer merge con defaults
            const currentConfig = configManager.getConfig();
            const mergedConfig = {...defaultVoiceConfig, ...currentConfig};

            // Actualizar solo si hay campos nuevos
            if (!currentConfig.voiceLanguage) {
                configManager.updateConfig(mergedConfig);
            }

            return mergedConfig;
        };
        let openConversationsSidebar = function () {
            // Cargar la p�gina del sidebar
            app.views.sidebar.router.navigate('/screens/conversation-list');
            // Abrir el sidebar

            app.panel.open('left');
        };
        let renderExistingMessages = function (messagesArray) {
            const visibleMessages = messagesArray.filter(msg => msg.role !== 'system');
            const currentConfig = configManager.getConfig();
            const contextLocation = currentConfig.documentContextLocation || 'system';

            visibleMessages.forEach((message, index) => {
                const messageId = message.id || `restored-msg-${Date.now()}-${index}`;

                if (message.role === 'user') {
                    let displayContent = message.content;

                    // Si los documentos est�n en el mensaje de usuario, limpiarlos para UI
                    if (contextLocation === 'user') {
                        displayContent = displayContent.replace(/=== REFERENCE DOCUMENTS ===[\s\S]*?=== END OF DOCUMENTS ===/g, '');
                        displayContent = displayContent.replace(/=== QUESTION ===/g, '').trim();
                    }

                    // Limpiar im�genes (se muestran en header)
                    displayContent = displayContent.replace(/<simba_image[^>]*>[\s\S]*?<\/simba_image>/g, '');

                    messages.addMessage({
                        attrs: {"data-id": messageId, "id": messageId},
                        isTitle: false,
                        text: `<p class="no-margin-top float-left">${md.render(displayContent)}</p>`,
                        name: 'User',
                        cssClass: 'sent card no-margin-top padding-half',
                        type: 'received',
                        avatar: 'https://ui-avatars.com/api/?name=User',
                        textFooter: footerTemplate
                    }, 'append', false);

                } else if (message.role === 'assistant') {
                    messages.addMessage({
                        attrs: {"data-id": messageId, "id": messageId},
                        isTitle: false,
                        text: md.render(processAndRenderMarkdown(message.content)),
                        name: assistant.name,
                        cssClass: 'card no-margin-top padding-half',
                        textFooter: footerTemplate,
                        avatar: assistant.avatar,
                        type: 'received',
                    }, 'append', false);

                    // Agregar fuentes y acciones para mensajes del asistente
                    const $messageEl = $('#' + messageId);
                    addSourcesToMessage($messageEl);
                    addActionsToMessage($messageEl);
                }

                // Procesar el mensaje agregado
                onMessageAdded($('#' + messageId));
            });

            // Hacer referencias clickeables
            makeClickableReferences();
            makeClickableSuggestions()

            // Scroll al final
            setTimeout(() => {
                scrollToBottom();
            }, 500);
        };
        let loadAssistantData = function (assistantGuid) {
            return new Promise((resolve, reject) => {
                $f7.request({
                    url: `${window.config.api_methods.load_assistant}?assistant=${assistantGuid}`,
                    method: 'GET',
                    headers: {
                        'x-auth-token': window.config.token,
                        'Content-Type': 'application/json'
                    },
                    dataType: 'json'
                }).then((response) => {
                    console.log('Assistant data loaded:', response.data);
                    resolve(response.data.data);
                }).catch((error) => {
                    console.error('Error loading assistant data:', error);
                    reject(error);
                });
            });
        };
        let loadExistingConversation = async function (conversationId) {
            try {
                console.log('Loading existing conversation:', conversationId);

                // Cargar la conversaci�n desde localStorage
                const conversation = await conversationManager.loadConversation(conversationId);

                if (!conversation) {
                    console.error('Conversation not found:', conversationId);
                    $f7.toast.show({
                        text: 'Conversation not found',
                        cssClass: 'color-red'
                    });
                    return;
                }

                // Actualizar el asistente actual
                const foundAssistant = assistants.find(a => a.guid === conversation.assistant.guid);
                if (foundAssistant) {
                    assistant = foundAssistant;
                } else {
                    assistant = conversation.assistant;
                }

                // NUEVO: Cargar informaci�n completa del asistente desde la API
                const assistantData = await loadAssistantData(conversation.assistant.guid);

                if (!assistantData) {
                    throw new Error('Failed to load assistant data');
                }

                // Configurar el chat con la informaci�n completa del asistente
                chat = {
                    guid: conversationId,
                    title: conversation.title,
                    mainAssistant: assistantData.mainAssistant,
                    tools: assistantData.tools || [],
                    tools_setup: assistantData.tools_setup || {},
                    activeTools: conversation.tools || assistantData.tools || [],
                    instructions: assistantData.instructions || [],
                    noSelectionInstructions: (assistantData.instructions || []).filter(instruction => !instruction.isSelection)
                };

                // Actualizar assistant con la informaci�n completa
                assistant.name = assistantData.mainAssistant.name;
                assistant.avatar = window.config.domain + assistantData.mainAssistant._myMedias.avatars[0].realPath;
                assistant.mainImage = window.config.domain + assistantData.mainAssistant._myMedias.mainImage[0].realPath;
                assistant.greeting = assistantData.mainAssistant.greeting;
                assistant.placeholder = assistantData.mainAssistant.placeholder;
                assistant.thinkIcon = assistantData.mainAssistant.thinkIcon || '??';

                // Restaurar device si existe
                if (conversation.device) {
                    myDevice = conversation.device;
                }

                // Inicializar tool manager con el chat cargado
                toolManager = new window.SIMBA.ToolManager(chat, configManager.getConfig());

                // Inicializar herramientas activas
                initializeActiveTools();
                initializeProxyTool(chat,assistant).catch(error => {
                    console.error('Error initializing proxy tool:', error);
                });
                updateChatTools();

                // Restaurar el estado completo
                const restored = await conversationManager.restoreConversationState(
                    conversation,
                    messageManager,
                    sourceManager,
                    highlightManager,
                    window.myFileDropzone
                );

                if (restored) {
                    console.log('? Conversation state restored successfully');

                    // Renderizar mensajes en la UI
                    renderExistingMessages(conversation.messages);

                    // Actualizar dropzone y template
                    updateDropzoneState();
                    updateTemplate();

                    $f7.toast.show({
                        text: 'Conversation loaded successfully',
                        cssClass: 'color-green',
                        closeTimeout: 2000
                    });
                } else {
                    throw new Error('Failed to restore conversation state');
                }

            } catch (error) {
                console.error('Error loading conversation:', error);
                $f7.toast.show({
                    text: 'Error loading conversation',
                    cssClass: 'color-red'
                });
            }
        };
        /**
         * Verifica si las API keys est�n configuradas
         * @returns {Object} - Estado de las API keys
         */
        let checkRequiredApiKeys = function () {
            const config = configManager.getConfig();

            return {
                hasAssistantApi: !!(config.assistantApiUrl && config.assistantAuthToken),
                hasCompletionApi: !!(config.completionsApiUrl && config.completionsApiKey),
                isComplete: function () {
                    return this.hasAssistantApi && this.hasCompletionApi;
                }
            };
        };
        /**
         * Inicializa el popup de API keys
         */
        let initializePopupApiKeys = function () {
            popupApiKeys = $f7.popup.create({
                el: $el.value.find('#popup-api-keys'),
                closeByBackdropClick: false,
                closeOnEscape: false,
                swipeToClose: false
            });
        };

        /**
         * Inicializa el validador del formulario de API keys
         */
        let initializeApiKeysFormValidator = function () {
            formApiKeysValidator = jQuery($el.value.find('form[name=api-keys]')).validate({
                rules: {
                    assistant_auth_token: {required: true, minlength: 10},
                    completion_api_key: {required: true, minlength: 10}
                },
                messages: {
                    assistant_auth_token: {
                        required: 'Please enter your mySim API key.',
                        minlength: 'API key seems too short.'
                    },

                    completion_api_key: {
                        required: 'Please enter your Completion API key.',
                        minlength: 'API key seems too short.'
                    }
                },
                submitHandler: function (form) {
                    const formData = $f7.form.convertToData(form);

                    // Actualizar configuraci�n con las API keys
                    const updatedConfig = {
                        assistantAuthToken: formData.assistant_auth_token,
                        completionsApiKey: formData.completion_api_key
                    };

                    configManager.updateConfig(updatedConfig);

                    // Actualizar variables globales si existen
                    if (typeof window.config !== 'undefined') {
                        window.config.api_methods = window.config.api_methods || {};
                        window.config.token = formData.assistant_auth_token;
                        window.config.completion = {
                            url: formData.completion_api_url,
                            apiKey: formData.completion_api_key
                        };
                    }

                    $f7.toast.show({
                        text: 'API keys saved successfully!',
                        cssClass: 'color-green',
                        closeTimeout: 2000
                    });

                    // Cerrar popup y continuar con la inicializaci�n
                    popupApiKeys.close();

                    // Continuar con la carga normal de la aplicaci�n
                    continueAppInitialization();
                }
            });
        };
        let processAndRenderMarkdown = function (text) {
            let processedText = window.SIMBA.Utils.preprocessMarkdown(text);
            let renderedHtml = md.render(processedText);

            // ✅ DECODIFICAR CORRECTAMENTE UTF-8
            renderedHtml = renderedHtml.replace(/\[\[SIMBA_SUGGESTION:([^\]]+)\]\]/g, function (match, encoded) {
                try {
                    const decoded = atob(encoded);
                    return decodeURIComponent(decoded.split('').map(function(c) {
                        return '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2);
                    }).join(''));
                } catch (e) {
                    console.error('Error decoding suggestion:', e);
                    return '';
                }
            });

            return renderedHtml;
        };

        let cleanSimbaAfterCompletion = function () {
            console.log('?? Post-completion: Checking simba_document cleanup...');

            if (!messageManager) {
                console.warn('?? MessageManager not available');
                return {cleaned: false, reason: 'No messageManager'};
            }

            const totalTokens = messageManager.getTotalTokens();
            const tokenLimit = messageManager.TOKEN_LIMIT || TOKEN_LIMIT;

            // Contar simba_document actuales
            const systemContent = messageManager.messagesHistory[0]?.content || '';
            const simbaDocumentCount = (systemContent.match(/<simba_document[^>]*>/g) || []).length;

            console.log('?? Post-completion analysis:', {
                totalTokens,
                tokenLimit,
                simbaDocumentCount,
                tokenUsagePercent: Math.round((totalTokens / tokenLimit) * 100)
            });

            // CRITERIOS PARA LIMPIAR:
            // 1. Hay simba_document para limpiar
            // 2. Y CUALQUIERA de estas condiciones:
            //    - Estamos sobre 70% del l�mite
            //    - Hay m�s de 10 simba_document blocks
            //    - El sistema est� cerca de optimizaci�n

            const shouldClean = simbaDocumentCount > 0 && (
                totalTokens >= tokenLimit * 0.7 ||           // 70% del l�mite
                simbaDocumentCount > 10 ||                   // M�s de 10 blocks
                totalTokens >= tokenLimit * 0.85            // 85% - muy cerca del l�mite
            );

            if (shouldClean) {
                console.log(`?? Cleaning ${simbaDocumentCount} simba_document blocks...`);

                const result = messageManager.cleanAllSimbaDocumentsFromSystem();

                const newTotalTokens = messageManager.getTotalTokens();
                const efficiencyGain = Math.round(((tokenLimit - newTotalTokens) / tokenLimit) * 100);

                console.log(`? Cleanup completed: ${result.savedTokens} tokens saved`);
                console.log(`?? New usage: ${newTotalTokens}/${tokenLimit} (${100 - efficiencyGain}%)`);

                // Mostrar notificaci�n discreta
                $f7.toast.show({
                    text: `?? Context optimized: ${result.savedTokens} tokens freed`,
                    position: 'bottom',
                    closeTimeout: 2000,
                    cssClass: 'color-blue'
                });

                return {
                    cleaned: true,
                    ...result,
                    newTotalTokens,
                    efficiencyGain
                };
            } else {
                const reason = simbaDocumentCount === 0 ? 'No simba_document found' : 'Usage below threshold';
                console.log(`?? No cleanup needed: ${reason}`);
                return {cleaned: false, reason};
            }
        };
        /**
         * Obtiene el estado actual de reasoning directamente desde config
         * @returns {boolean}
         */
        let isReasoningEnabled = function () {
            const currentConfig = configManager.getConfig();
            // Si no existe en config, default es true
            return currentConfig.reasoningEnabled !== false;
        };
        // ===========================================
        // FRAMEWORK7 LIFECYCLE HOOKS
        // ===========================================

        $on('pageBeforeIn', function () {
            scrollToBottomBtn = document.getElementById('scrollToBottom');
            pageContent = document.getElementById('conversationPage');

            // Initialize various dialogs and popups
            initializeDialogChoiceChip();
            initializePopupTicket();
            initializeActionsCustomLayout();
            initializeFormValidator();
            initPopoverSelection();
            initializePopupApiKeys();
            initializeApiKeysFormValidator();
        });
        $on('pageBeforeRemove', function () {
            stopProxyMonitoring()
        });
        $on('pageBeforeOut', function () {
            // Resetear variables
            originalAssistant = null;
            showAssistantChip = false;
        });

        $on('pageAfterIn', function () {
            const hasAcceptedTerms = localStorage.getItem('terms_accepted');

            if (!hasAcceptedTerms) {
                $f7.views.main.router.navigate('/screens/terms/', {
                    reloadCurrent: true,
                    clearPreviousHistory: true
                });
                return;
            }

            // Verificar API keys DESPUÉS de los términos
            const apiKeysStatus = checkRequiredApiKeys();
            if (!apiKeysStatus.isComplete()) {
                console.log('API keys missing, showing configuration modal');

                // Inicializar popup si no existe
                if (!popupApiKeys) {
                    initializePopupApiKeys();
                    initializeApiKeysFormValidator();
                }

                // Mostrar popup
                popupApiKeys.open();
                return; // No continuar hasta que se configuren
            }
            loadAvailableModels().then(() => {
                console.log('✅ Models loaded on page init');


                // 3. Luego actualizar categoría (que ya tiene los modelos cargados)
                updateCurrentModelCategory();

                // 4. Finalmente actualizar template
                updateTemplate();

            }).catch(error => {
                console.error('❌ Error loading models on init:', error);
            });

            conversationManager = new SIMBA.ConversationManager(
                new SIMBA.LocalStorageProvider(),
                {autoSave: true, autoSaveInterval: 30000}
            );

            loadAssistants().then(myAssistant => {
                console.log("Assistant loaded:", myAssistant);
                if (myAssistant) {
                    // Verificar si viene de "New conversation" con un asistente específico
                    const assistantGuid = $f7route.query.assistant;

                    if (assistantGuid && $f7route.params.guid === 'new') {
                        // Caso: Nueva conversación con asistente específico
                        console.log('🆕 Creating new conversation with assistant:', assistantGuid);

                        // Primero cambiar al asistente correcto
                        const targetAssistant = assistants.find(a => a.guid === assistantGuid);
                        if (targetAssistant) {
                            assistant = targetAssistant;

                            // Crear conversación con ese asistente
                            createConversation(assistantGuid).then(() => {
                                console.log('✅ New conversation created with assistant');
                                updateCurrentModelCategory();

                                // Initialize mention manager
                                if (mentionManager) {
                                    mentionManager.init();
                                }

                                updateDropzoneState();

                                const shouldInitVoice = voiceConfig.enabled;

                                if (shouldInitVoice) {
                                    initializeVoiceManager();
                                    checkMicrophonePermissions();
                                } else {
                                    console.log('🔇 Voice features disabled by configuration');
                                    voiceSupported = false;
                                }

                                scrollToBottomBtn = document.getElementById('scrollToBottom');
                                debouncedAutoScroll = createDebouncedAutoScroll();
                                console.log('✅ Debounced auto-scroll initialized');
                                pageContent.addEventListener('scroll', checkScrollPosition);
                                pageContent.addEventListener('scroll', handleUserScroll);
                                checkScrollPosition();

                                updateTemplate();
                            }).catch(error => {
                                console.error('Error creating new conversation:', error);
                                $f7.toast.show({
                                    text: 'Error creating conversation',
                                    cssClass: 'color-red'
                                });
                            });
                        } else {
                            console.error('Assistant not found:', assistantGuid);
                            $f7.toast.show({
                                text: 'Assistant not found',
                                cssClass: 'color-red'
                            });
                        }
                    } else if ($f7route.params.guid && $f7route.params.guid !== 'new') {
                        // Caso: Cargar conversación existente
                        loadExistingConversation($f7route.params.guid);

                        // Initialize mention manager
                        if (mentionManager) {
                            mentionManager.init();
                        }

                        updateDropzoneState();
                        const shouldInitVoice = voiceConfig.enabled;

                        if (shouldInitVoice) {
                            initializeVoiceManager();
                            checkMicrophonePermissions();
                        } else {
                            console.log('🔇 Voice features disabled by configuration');
                            voiceSupported = false;
                        }
                        scrollToBottomBtn = document.getElementById('scrollToBottom');
                        debouncedAutoScroll = createDebouncedAutoScroll();
                        console.log('✅ Debounced auto-scroll initialized');
                        pageContent.addEventListener('scroll', checkScrollPosition);
                        pageContent.addEventListener('scroll', handleUserScroll);
                        checkScrollPosition();
                        updateTemplate();
                    } else {
                        // Caso: Primera carga o conversación nueva sin asistente específico
                        // Initialize mention manager
                        if (mentionManager) {
                            mentionManager.init();
                        }

                        updateDropzoneState();
                        const shouldInitVoice = voiceConfig.enabled;

                        if (shouldInitVoice) {
                            initializeVoiceManager();
                            checkMicrophonePermissions();
                        } else {
                            console.log('🔇 Voice features disabled by configuration');
                            voiceSupported = false;
                        }
                        scrollToBottomBtn = document.getElementById('scrollToBottom');
                        debouncedAutoScroll = createDebouncedAutoScroll();
                        console.log('✅ Debounced auto-scroll initialized');
                        pageContent.addEventListener('scroll', checkScrollPosition);
                        pageContent.addEventListener('scroll', handleUserScroll);
                        checkScrollPosition();
                        updateTemplate();
                    }
                } else {
                    $f7.toast.show({
                        text: 'No assistant is available',
                        cssClass: 'color-red'
                    });
                }
            }).catch(error => {
                console.error("Error loading assistants:", error);
            });

            updateChatTools();
            initializeChartGenerator();
            initializeMessagebar();
            initializeMessages();
            setupDocumentUpload();
            initializePopupConfig();
            initializePopoverText();
            initializeConfigFormValidator();
            initializePopoverTools();

            window.addEventListener('storage', function (e) {
                if (e.key === 'walkthroughProgress' && e.newValue === null) {
                    popupTask = null;
                    $update();
                    console.log('walkthroughProgress fue eliminada');
                }
            });
            window.addEventListener('proxy-status-changed', function() {
                updateTemplate();
            });
        });

        // ===========================================
        // RETURN TEMPLATE RENDERER
        // ===========================================
        window.toggleStepContent = toggleStepContent;
        window.openExecutionPlanPanel = openExecutionPlanPanel;
        window.createVariablesBadges = createVariablesBadges;
        window.updateVariableBadge = updateVariableBadge;
        return $render;
    }
</script>